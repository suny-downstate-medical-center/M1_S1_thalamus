* 15may27 Modularized framework for NEURON/Python network simulations with MPI
** Overview
Using this modularized structure can select different cell types, populations, connectivities, etc. just by modifying the
parameters in params.py.

An example is provided in params.py which switches from a single Hodgkin-Huxley population, randomly connected model
(mpiHHTut); to a multiple Izhikevich populations, yfrac-dependent connected M1 model.
To test this just modify the variable simType in params.py:
simType = 'M1model' # 'mpiHHTut'

** README with description of the different files
List of files:

- main.py: Main executable; calls functions from other modules.

- params.py: Contains all static parameters. It is imported as "p" from all other modules, so that params can be referenced from any file using p.paramName

- shared.py: Contains all the model shared variables and modules (except params.py). It is imported as "s" from all other file, so that any variable or module can be referenced from any file using s.varName

- sim.py: Simulation control functions (eg. runSim)

- network.py: Network related functions (eg. createCells)

- cell.py: contains cell and population classes

- conn.py: contains class 'Conn' used to instantiate connections, and contains methods to connect cells (eg. random, yfrac-based)

- analysis.py: functions to plot and analyse data

- stimuli.py: functions and parameters for differnt types of neural stimulation

- izhi2007.mod: NMODL definition of Izhikevich 2007 neuron model

- evol.py: Functions to run evolutionary algorithms (using inspyred) to optimize model parameters

** Known issues, potential improvements, and alternative implementations
*** Saving only happens at the end (instead of at fixed intervals)
*** Need to add a DEBUG mode or similar (like mpiHHTut had)
- currently have a verbose flag, that prints some additional info
*** Have print messages along the code, which could be made optional
*** Structure of data saved to file - solved in simsetup
- some nested lists with inhomogeneous dimensionality were converted to 'object' data types in order to be saved -- check if
  structure makes sense when reading from python/matlab
*** Some attributes/variables of the class 'Cell' and 'Pop' are not used but still initialized to [ ]
- maybe can find alternative using different constructors for different cell types
*** Labels (eg. AMPA, IT, HH,...) are defined by assigning numeric values to variables
- can use dictionaries instead
- need to check pros and cons of each -- are dicts slower or have any limitations compared to lists/arrays ?
*** stimuli.py not tested with this model
- left there cause thought could be useful for future
*** Some variables inherited from cliff still have too long names, eg. backgroundSpikevec
*** BasicPop and YfracPop
*** if increase p.backgroundNoise > 0.0 get memory error - solved in simsetup
*** Find a way to save lambda funcs (can't be pickled)
*** Clearing vector in simdata now gives error because also has python variables - solved in simsetup
for v in s.simdata.itervalues() -- fix error
*** 'Cell' class record method uses eval() which is unsafe
*** currently setup to record traces from all cells - solved in simsetup
*** bug when saving cell traces using multiple cores - solved in simsetup
Gathering spikes...
>>> >>> >>> Traceback (most recent call last):
  File "main.py", line 46, in <module>
    runSeq()
  File "main.py", line 37, in runSeq
    s.sim.gatherData()
  File "sim.py", line 117, in gatherData
    for d in gather: tmp.extend(d[k])
KeyError: 'cellTraces_233'
*** analysis.py still has many functions which havent been adapted to new structure
*** Distribution of cells over nodes starts from scratch for every population
- this can lead to cases where nodes end up with no cells
- eg. 2 pops of 15 cells, distributed on 16 nodes
- pop 1 cells go from 1-15
- pop 2 cells also go from 1-15
-- max difference of cells between nodes will be equal to num populations
*** Export to NSDF format
* 15jun22 Meeting and NineML
** meeting
- padraig define conn in python cde (20 lines) and save network instantiation in xml
- func/Excel -> xml instance -> infer func to compare
- long way to calculate xml instance from func - then reverse calculate
- send code and can come up with generic scripts for yfrac conn
1) send data
2) matlab -> text format
3) generic python functions to load format and instantiate network - independent of sim functions (reuse our code)
4) reuse our simulation functions?

- talk with ben:
- subcell conn mostly anatomical, but we can have more functional approach
- alan inst mostly anatomical
- paper: validate our format with example from our data and some other lab
- define conceptual format (independent of simulator) that bridges experimental with computational modeling
- separate data from sim - very interrelated (need one to to work with the other)

** NineML: http://incf.github.io/nineml/
- "Network Interchange for NEuroscience (NineML) is a simulator-independent language with the aim of providing an unambiguous
  description of neuronal network models for efficient model sharing and reusability."
- "An Abstraction Layer that provides the core cocepts and mathematical descriptions with which model variables and state
  update rules are explicitly described in parametrized form"

Ben:
Good find! I had a quick look at the connectivity parts of their
specification. It seems they don't currently support what we need, but
their future plans seem relevant:

From http://incf.github.io/nineml/9ML/1.0/NineML_v1.0.pdf:

Connection rules must be one of 6 standard library types, all-to-all,
one-to-one, probabilistic, explicit, 11 random-fan-out and
random-fan-in, provided to the standardLibarary attribute. Note: In
future versions, built-in connectivity rules are to be replaced with
mathematically expressed connection rules.

However, it remains unclear what properties of the neurons/areas can
be referenced in these future "mathematically expressed connection
rules".

Padraig: Yes, we've been working with NineML for a while. There is actually a NeuroML to NineML converter implemented (using
jNeuroML -nineml) which should mean that generated networks (e.g. from libNeuroML python scripts) could eventually be
converted to NineML. However, the focus in that project so far has been individual neuron models, and that's where the focus
of the working implementations are, as opposed to full network models.

There will certainly be a chance to convert to this format as is becomes more stable. Plans are currently focussed on better
integration of their Python libraries (lib9ml) with PyNN. One issue though is that there is no support yet for
multicompartmental cells in NineML, which would be an issue as we start to build more detailed networks.

** next meeting
- Separate data (sim-independent) from sim so can send to Padraig
- Discuss in CNS with Ben specific format - settle so can send to Padraig
- Paper to validate this format using data from our lab and other lab
- NineML will include mathematically expressed connection rules - Adrian said De Schutter very meticulous and little advance
  - currently just individual neuron models, no support for MC cell
* 15jul22 CNS15 Workshop (Ben + talks)
** Ben  model+data structure discussion
- might make more sense to move connProbs and connWeights to params.py
- theoretical node subsumes experimental and computational nodes - biggest gap is formalism of theoretical - we are tryin to
  do
- hierarchy from theory to simulation - lowest level is specific implementation (eg 500 cells) - eg NeuroML - can have large
  collection of those
- how to model the difffernet levels from theory to model? midpoint = domain-specific language - shoudln have to do with
  functionso or variables -- but practically its iterartive
- DSL interepret/parse file and implement
- keep separation between specific simulation and DSL definiton of models - eg. cell model type will be specified at lowest
  level

- populaton concept useful for presyn - also have aditional pops for background input - not necessarily part of M1 - in terms
  of implementation should be same as model pops
- background pops defined by area, yfracrange, cell type, synapse type (combination of these / tags)
- on postsyn side: all of above + dendritic location (depends of num of compartments) - should be topological, posittion
  relative to soma, or yfrac and radius distance

- cell types defined as: projection target (populations), type (neurotransmitter involved), laminar location of cell
- topclass and subclass reuired? any benefits? no one answer, depends who ask. create list of cell types thats extendable
- at theoretical level: define pops and synapses in a "free" way - dependsing on how much we know + what kind of model we are
  using

Ben Questions:
q1,q2: nonc-cells? layers, areas, pops (define hierarchy?) - not necessarily instantiated as cells - need to define these
properties? function in simulation? can implement these features using conn params?

q3: mixed implementations - as max as possible depending on machines?  define criteria/%

q4: variability in conn - heterogneity in cells in pop - for intrinsic properties how can we implement this variability?
- long-range conn may need to eb directed toward specific subsets - same subset will receive inputs from S2 and M2 -
  convergence and divergence
- convergence parameter - probabilistic conn but targeted at specific subsets - use yfrac, labels, subpopulation
- labels - totally arbitrary attributes to tag subsets and affect connectivity rules - can be used to extend model, define
  new properties
- maybe replace populations with attributes
- instantiate all cells in model first - in full column - then define attributes based on yfrac - almost as inverse of
  starting with pops - could have difficulties: circular, numbers have to match, need % of cell types - consistency

- topClass and subClass - substitute with attributes
- attributes could be python dictionary: key=value --> yfrac=0.4, projection-type=PT

- serialize net definition - maybe use database instead of python to store (interfaced with python) - would solve separation
  of data and simulation
q6: separation of definition, instantiation, and implementation - features such as model type, synapses should be lowst level


My questions/comments:
- compromise between time in project (3 years) and level of detail of DSL (bill's constraints)
- problem with substituting pops with just cells+tags:
-- have to initialize all cells with locations/densities for full column
-- how to calculate densities to match model definition? need all celltypes and yfrac-dependent densities

*** Conclusions / features to include
Short-term:
- Use dictionary of 'tags' instead of fixed parameters - more flexible, depends on how much we know, type of model etc
- Tags for populations: projection target, type (neurotransmitter involved), yfracrange, extensible
- Include populations used for 'background input' (include area, yfrac range, cell type, synapse type,...)

Long-term/optional:
- Domain-specific language: NeuroML, NineML or CSA are potential candidates. Implement in future if required/useful and have time.
- Separation between specific simulation and abstract DSL model definition. Implement in future, but try to separate
  parameters now in Python (eg. cell model is simulation specific, % of population?)
- Allow for variability/heterogeneity within population - use tags for subsets of cells, convergence parameter?
- Define non-cell objects such as layers, areas, pops? advantages? can be defined using conn or other params?
- Replace populations with simply using tags/attributes - requires instantiating all cells initially with correct densities,
  and then assigning tags to different cells - needs to be consistent. how to define initial cell density without specifying
  population properties (circular)?


** HBP talk workshop CNS15
- each modeler is inventing the wheel independently
- sparse data - inductive principles + algorithms
- "Reconstruction and simulation of neocortical microcircuitry"
- cellular anatomy:
- 14k cell, 55 types (inhibotry) - nice 3d rotating view
- fractional neuronal compostition - for each layer/cell type
- spatial dimensions - volume based on morphology ?
- morphology selection - martinotti cells differen at top and bottom of layer (yfrac) - constraint algorithm
- cellular physiology:
- with Idan Segev (Hay et al 2011; Druckmann 2007,08)
- electrical diversity - classified into 13 types
- high troughput workflow to model electricl bahvior of neurons
- build nueron model of all 13 types; create different morphologies = 124'489 model neurons - throw out 20-50% of models
- validate dendritic attenuation  - dist from soma vs dendPSP/somaPSP
- synpatic anatomy:
- boutons/mm; distance vs conn plasticity
- synapses/connection - peters rules - general pruning, multi-contact pruning, plasticity pruning
- "An algorithm to predict th the connectome of neural microcircuits"
- validation: synapses per connection - when have experimental data; fill in based on patterns (eg boutons preserved across classes)
- interbouton interval distribution
- validating the predicted connectome
- predicted connection probabilites - don't use - has to be reported from epxerimentalists - need to normalize and very
  difficults
- conn probability as a func of distance - dpeneds on recurrent connect
- prediction of extrinsic connectivity - many exc coming from the outside - knowing density of spikes allos to calcualte how
  many are captured per layer
- quantal conductances - use PSP - generalzie synaptic conductances - approach also used by Ben
- In silico experiments:
- spontanteous sync activity under depolarization - slow oscillations happened why? looking for nework state thats good for
  information processing - small input and large response
- differential synpatic sensitivity to extracellular calcium - correct Ca2+ levels  - osc go away
- make synapses less reliable (contrain by the data) - new insight - in vitro vs in vivo Ca2+ videos - known anatomy + physio
  of thalamocortical inputs
- recereating in-vivo experiments
models at the level of the data facilitate the integration generalization from sparse data and valdiation
- multilvel broad valdiation should chase out over-fitting
- adhoc simplification
** Allen Inst
- http://celltypes.brain-map.org/
- biophysical models of single cells
- database stats
- GLIF cell model (generalized LIF)
- pv cells - affect tuning
- vip - gain control
- sst - intercolumn comm
- point neuron models in V1
- if inputs to a cortical column are not cell type specfic and only depend on layer, the colum is clsoe to linear

* 15aug11 Implementing changes discussed in CNS15 with Ben
** Check and consolidate differences between simsetup and m1
*** cell.py
- backgroundRand and backgroundSource now part of self. to avoid mem leakeges
- record in recdict with 2d structure for cells in simdata
- izhi params stored in orderedDict
- dummy renamed to sec
- includes izhi2007a and izhi2007b
*** conn.py
- YfracConn passes as argument synapse instead of cell object (won't work for PP izhi?)
*** params.py
- set syn receptors to same index - just 1 receptor for simiplicity for now
- set weight and background params to lower values to make izhi2007a work
- set recording using recdict
*** sim.py
- minor changes for recording Vectors and storing in allsimdata dict
*** copied izhi2007a,b.mod sym links
*** In summary: made m1 identical to simsetup
** testing
- 'M1model' runs ok
- 'mpiHHTut':
-- with 1 core gives error when saving to .dpk:
Traceback (most recent call last):
  File "main.py", line 45, in <module>
    runSeq()
  File "main.py", line 37, in runSeq
    s.sim.saveData()
  File "sim.py", line 153, in saveData
    gzip.open(file, 'wb').write(pk.dumps(s.allsimdata)) # write compressed string
TypeError: HocObject: Only Vector instance can be pickled

-- with multiple cores:
memory leak during gathering spikes (pickle)
error in line:     gather=s.pc.py_alltoall(data)
FIXED: had to remove 'soma', 'stim' from variables saved
** Population/cell tags
eg.
net['popParams'] = []  # create list of populations, where each item contains a dict with the pop params

net['popParams'].append({'cellModel':'Izhi2007b', 'EorI':'E', 'topClass':'IT', 'subClass':'other', 'yfracRange':[0.1, 0.26], 'density':lambda y:2e3*y}) #  L2/3 IT

net['popParams'].append({'cellModel':'Izhi2007b', 'EorI':'E', 'topClass':'IT', 'subClass':'other', 'yfracRange':[0.26, 0.31], 'density':lambda y:2e3*y}) #  L4 IT

** Connectivity rules
Several options using combination of lists and dicts:

     # class variables to store matrix of connection probabilities (constant or function) for pre and post cell topClass
        # net['connProbs'] = []  # create list of connectivity rules
        # net['connProbs'].append({('topClass','IT','topClass','IT'): (lambda x,y: 0.1*x+0.01/y)})  # option 1: list of dict with single tuple key and value
        # net['connProbs'].append({('topClass','IT','topClass','PT'): (lambda x,y: 0.02*x+0.01*y)})

        # net['connProbs'] = {}  # dict of conn rules
        # net['connProbs'][('topClass','IT','topClass','PT')] = (lambda x,y: 0.1*x+0.01/y)  # option 2: single dict with multiple tuple keys and values
        # net['connProbs'][('topClass','IT','topClass','PT')] = (lambda x,y: 0.02*x+0.01*y)


        # net['connProbs'] = []  # create list of connectivity rules
        # net['connProbs'].append({'preTag':'topClass', 'preValue':'IT', 'postTag': 'topClass', 'postValue':'IT', 'connFunc': (lambda x,y: 0.1*x+0.01/y)})
        # net['connProbs'].append({'preTags':['topClass','subClass'], 'preValues':['IT','other'], 'postTags': ['topClass'], 'postValues':['IT'], 'connFunc': lambda x,y: 0.1*x+0.01/y})


Current choice allows to define arbitrary connectivity rules based on presyn and postsyn cell tags/attributes (or
combinations of these), and defines the connWeight and connProb within the same rule dict (very flexible, but maybe slow,
difficult to read?)

        net['connRules'] = []  # create list of connectivity rules
        net['connRules'].append({'preTags':['topClass'], 'preValues':['IT'], 'postTags':['topClass'], 'postValues':['IT'], \
            'connProb':(lambda prey,posty: 0.1*prey+0.01/posty), 'connWeight':(lambda prey,posty: 1), 'receptor':'AMPA'})  # IT->IT rule

        net['connRules'].append({'preTags':['topClass'], 'preValues':['IT'], 'postTags':['topClass'], 'postValues':['IT'], \
            'connProb':(lambda prey,posty: 0.1*prey+0.01/posty), 'connWeight':(lambda prey,posty: 1), 'receptor':'AMPA'})  # IT->PT rule

** Tags/attributes for cells and pops (discussion with Ben)
*** Sal email - asking about attributes and values, specially for inh
Hey Ben, Im working on some of the changes we discussed. I've replaced variables with dictionaries of tags/attributes. For
now, I've kep the 'population' concept, although can replace in future version if makes sense.

For both the 'population' and 'cell' objects you suggested replacing the 'topClass' and 'subClass' tags with 'projectionType'
and 'cellType' if my notes are correct. I know projType for Exc cells will be 'IT', 'PT' or 'CT', but not sure what would be
the best classification for Inh cells? Same thing for cellType, I think you mentioned neurotransmitters involved, but could
you elaborate on what would be the list of possible values for both 'Exc' and 'Inh' cells/pops ?

We can use the google chat or this google doc to bounce ideas back and forth (link points to new section ready to be filled
in).
*** Ben notes - discussion of cell types and proposal
Notes ongoing: all neurons fire action potentials (ignoring some weird cases), the effect of this AP becomes excitatory or
inhibitory when it reaches a terminal and induces synaptic transmission - really it becomes E or I on the postsynaptic cell
(depending in the transmitters, and the AP threshold of that cell). But I digress. Because most neurons release either
excitatory or inhibitory transmitters (but not or rarely both), it makes sense to classify cells as E or I. However, this is
confounded by the fact that (at least in cortex) most (or maybe all!) excitatory neurons send an axon out of the “local
circuit” (really, it’s worth thinking about what a local circuit is, and whether it even exists as such - but save that for
another day), while inhibitory neurons tend to project only locally / nearby. Another point is that most cortical excitatory
neurons share a “pyramidal” soma shape with a single apical dendrite (but in some cortical areas there are spiny stellates,
for example). So I’ve been thinking along the lines of categorizing cells by long-range projection (IT, PT, CT, interneuron)
first and foremost; and making the E/I a property of the “synapse” (connection onto other cells), rather than a property of
the cell itself. Maybe this is silly?

Then instead of “interneuron” (which really means that it doesn’t project long range, but often is used as “inhibitory”), we
might have specific types: IT, PT, CT, Sst, Pvalb or similar.

I guess one question is: will it be useful to specifically represent superclasses and subclasses, i.e. “interneuron->Sst”, or
“pyramidal->IT”? Or can we just keep it simple and have one property “cellType” taking arbitrary string values (generally:
IT, PT, CT, SOM, PV, VIP).

Further along those lines: for each of the above classes, we may find that their intrinsic properties vary by yfrac, layer,
or that there are subclasses (perhaps uniformly intermixed in space). Right now this is not the case for M1, but it could
become so (as for example for S1 L2/3, per Petersen). The question then will be whether such within-class differences would
require new “celltype” subdivisions/subclasses? My feeling is “no”. I would say that such additional “splitting” would be
handled by adding a new attribute for that purpose specifically.

A different but related issue: “PT”, for example, is adequate for describing the projection pattern relative to other nearby
neurons (IT, CT), but we may find that more detail is necessary. Again the S1 L2/3 example, where ITs projecting to M1 are
different than ITs projecting to S2. There is also evidence that PTs projecting to the lumbar spinal cord are intermixed in
M1 with those projecting to the cervical cord, but different. There again, one could modify the “celltype” (from PT to
CSP-lumbar), but I think a better approach is to add a new attribute as needed (e.g. spinalcordtarget=lumbar).

Which brings me to the next point: multiple projection targets. Most pyramidal neurons project to multiple long range
targets. This complexity would result in potentially many subclasses, but I’d prefer to add a list property
“longRangeTargets”, where we can specify the targets as necessary. This would be optional, but standardized. The list could
contain just string values, but I could imagine using IDs of cortical areas, or even layers in other cortical areas, and so
on, as we eventually move to a model beyond just M1.

In summary, where do I stand after this writing?

List of properties for each population after discussion with Ben v2
cellType: {IT, PT, CT, SOM, PV, VIP}
or if we initially only have one interneuron type, for example, then “InhInt” or such
YfracRange: eg. [0.3, 0.6]

Note: there’s a separate issue, namely the difference between a “celltype” and a population. I think it’s maybe useful to
differentiate. But I’m not sure about that, and we should discuss further. Hmm, nope, I think I’m wrong ;) In my mind, I
guess “population” and “cell type” are the same thing, almost. Where I get a bit hung up is for example: let’s say we want
two populations of L2/3 IT neurons, because we find that connectivity is different for those projecting callosally versus
those projecting to only S1, say. But we want them to have the same intrinsic properties. This is a roundabout way of me
saying that cell type and population sorta mean different things to me. But having thought about this, I think I’m happy with
what you have here!  So: a population is both an abstract definition of a type of cell (including morphology and intrinsic
properties) and its typical distribution in space, as well as the concrete instantiation as a set of N such neurons. My
question: is there a benefit in differentiating formally between the abstract definition and the instantiation? Maybe not.

*** Sal comment (ok to use cellType, projType)
For the example above (L2/3 IT) we would need to instantiate 2 'model populations' which differ in the attribute
"projectionTarget" (callosaly vs S1). Thus in this case, 'population' and 'cell type' would differ; so, in terms of the
modeling it would make sense to use 'population' to refer to the instantiation definition; and use 'cell type' for the
abstract definition.

Thanks for notes, in general I think they make sense (added a couple comments to gdoc), and will implement it that way:

cellType={IT, PT, CT, SOM, PV, VIP), and
projTarget={M1_L5A, S2_L23, lumbar, cervical,...}  (labels to be defined; with option of including multiple targets; but for now will leave blank)

*** Ben comment - redundancy/conceptual issue with celltype related to projection
Sounds good!

I agree - I think it is okay to classify cells as "PT" without further
specifying the target. Though I realize that there is some redundancy
/ conceptual issue with having the type be related to projection, and
also having the separate projTarget. But okay hopefully.
* 15aug20 Incorporating more detalied cell and synaptic parameters
** chat with sam
sal:
hey can u give me pointer to one of the SPI cells and code to run it, so I can have a look at the type of cell/syn params
that need to be incorporated to the network model?

sam: sure
repo of project i'm working on for tuning the SPI cell is /u/samn/PTfit
ctune.py there loads the PTcell template, which is located in /usr/site/nrniv/local/hoc/PTcell.hoc
there's also a small py wrapper in /usr/site/nrniv/local/python/PTcell.py
Ash/we started putting an old version of the PTcell into a network of INTF cells in /u/samn/hybsim

the ion channels / mod files you'd need are mentioned in mod/parameters.multi but they should all be in central repo
** Cells
-Cell topology, morphology, geometry, biophysics? -- all need to be included as params in framework? imported from other file?
*** Neuron cell templates?
http://www.neuron.yale.edu/neuron/static/new_doc/programming/oop.html?highlight=begintemplate - HOC equivalent to Python classes
http://www.anc.ed.ac.uk/school/neuron/tutorial/tutC.html

sal: after hoc was mostly replaced by python, are hoc templates still supposed to be used? or is there a python alternative
to do the same thing?  ie. python classes

sam: Can still use them but for new code better to use python classes Can create them easily from python (hoc templates) As
done in ctune.py and PTcell.py (eg. cell = h.PTcell(0,19,0); cell.soma; cell.dend; cell.reconfig() )

*** Replace Cells structures - 1 class/cellType instead of /cellModel ?!
eg: /u/samn/mtlhpc/Cells.py
- more cell types than cell models
- consistent with HOC cell templates
- issues: functions shared among HH cells (eg.create sections, etc) - redundant to repeat for each cellType
- multiple inheritance? from HH and Cell classes?


1) class IT (Cell):
    make (self):
     if cellModel== Izhi:
     ...
     elif cellModel == HH:
     ...

    addBackground (self):
     if cellModel== Izhi:
     ...
     elif cellModel == HH:
     ...

2) class IT (Cell):
    makeIzhi(self):

    makeHH(self):

    addBackgroundIzhi(self):

    addBackgroundIzhi(self):


3) class HH(Cell):
    make()
    addBack()

   class Izhi(Cell):
    make()
    addBack()

*** Morphology, biophysics and synapses parameters in params.py or in cellParams.py ??
- differentiate params from code
- can then have generic functions in cell class to add morphology, biophysics etc? redundant?
- what about default cell template params, vs specific for a simulation?

*** New structure for cell.py
class Cell:
 setMorphology(self):
  for sect in self.morphParams['Sects']:
   self.__dict__[comp.name] = h.Section()
   for mech in comp.mechs:
    self.__dict__[comp.name].insert(mech)
  ...

  or
  for sect in self.sectParams:
   self.__dict__[comp['name']] = h.Section()
   compRef = self.__dict__[comp['name']]
   h.pt3dclear(sec=compRef)
   h.pt3dadd(self.x, self.y, self.z, 20, sec=compRef)
  ...

 setBioPhysics(self):
  for comp in self.morphParams['Comps']:
   compRef=self.__dict__[comp['name']]
   for mech in comp['mechs']:
    self.__dict__[comp['name']].insert(mech['name'])
    mechRef=getattr(compRef, mech['name'])
    for prop in mech['props']
     mechRef.prop['name'] = prop['value']
  ...

 setSynapses:
  self.syns=[]
  self.syns.append(Syn(..))

 make:
  if self.cellType = 'Izhi2007':
    makeIzhi2007
  elif self.cellType = 'HH':
    makeHH

 makeHH:
  setMorphology
  setBiophysics
  ...

 makeIzhi2007:
  ...


class IT(Cell):
  % as dict of dicts
  sectionParams={'soma':{}, 'dend1':{}, 'dend2':{});
  sectionParams['soma']['props'] = {'nseg':4, 'cm': 1})
  sectionParams['soma']['mechs'] = {'HH': {}}
  sectionParams['soma']['mechs']['HH'] = {'gnbar': 1})

compParams = {
 'soma': {
  'props': {
   'nseg':4,
   'cm': 1}

  'mechs': {
   'HH': {
    'gnbar': 1}
  }
 }
}

  %as list of dicts
  compParams.append({'name':'soma', 'props':[], 'mechs': []});
  compParams[0]['props'] = {'nseg':4, 'cm': 1})
  compParams[0]['mechs'].append({'name':'HH', 'props': []})
  compParams[0]['mechs'][0] = {'gnbar':1}


- iteratively scan dicts: http://stackoverflow.com/questions/14692690/access-python-nested-dictionary-items-via-a-list-of-keys

- Note: compartments = section eg. Soma, dendrite (according to neurosim discussions, literature);
compartments = segments of a section (according to NEURON book, workshop etc);
if 1 segment/section, then Compartment = Section = Segment

- since IT class only stores params maybe dont need a class - just dict like popParams in params.py; and can keep class
  structure for different cell models ?
-- can have methods specific to that cell type - eg. for PT cells replace channel X with X
-- if IT is class, it can inherit from parent class cell; so sectionParams is contained within cell

*** sectionParams as class or object attr? duplicate info? maybe in params.py
- needs to be object attr because needs to permanently and accurately store network description -- identical copy for each
  cell
- can have as class attr; and each object points to it, unless there is change
-- this is actually default behavior in python if unmutable variable: if modify a class variable through an instance, a copy of that variable is
   made in the object (avoid append or mutable funcs; use assignment = )
   (http://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide)
-- conclusion: for lists or dicts, the class attr gets changed if modify the object attr

-- once create Neuron object Section(), all params will also be set there (within Neuron objects), for each cell instance


*** how are we gonna define cell attributes differently for subpopulations of IT cells?:
- create cells differently based on pop tags: cellType=IT, projTarget=X, yfracRange=X
- how to store these rules in dictionary independently of simulation?
-- could just store properties for each cell - equivalent to NeuroML; redundant if just multiple subpopulations
-- define set of 'cell property rules' similar to 'conn rules', eg:
{'cellTags':, 'cellValues':, 'sectParams': {...}}

-- rules executed sequentially; if sect/mech exists it overwrites it; if not creates it

-- perfect to define a specific set of properties for those cells containing a given cell tag; or yfrac-dep properties!
--- is this recursive? how to give cell tags to cells in a non-programatic way? just through populations! then what's the point?
--- except that 1 cell rule can apply to many pops (eg. all 'IT'), can have a subset of pop tag (eg. yfrac=[]), and can have
 multiple conditions (eg. IT and projects to S2)

-- rules defined in params.py p.net['cellParams'], cellParams.py, o cell.py?

-- should be possible to import from hoc template or python class onto cellParams[0]['sectionParams']

*** cell property rules example

cellParams.append({'cellTags': ['cellType'], 'cellValues': ['IT']}, 'sectionParams': {})
  sectionParams={'soma':{}, 'dend1':{}, 'dend2':{});
  sectionParams['soma']['properties'] = {'nseg':4, 'cm': 1})
  sectionParams['soma']['mechs'] = {'HH': {}}
  sectionParams['soma']['mechs']['HH'] = {'gnbar': 1})

  sectionParams['soma']['izhi2007Type'] = 'RS'  # {'cellType: 'RS'}

  or

  sectionParams=loadFromHOCTemplate(h.PTCell)

  or

  sectionParams=loadFromMatlab(h.PTCell)

  or

  sectionParams=loadFromNeuroML(h.PTCell)


- other possible formats:

        # option 1: list of dicts
        net['cellParams'] = []
        net['cellParams'].append({'tags':['cellType'], 'values':['PYR'], 'sections': {} })
        net['cellParams'][0]['sections'] = {'soma': {}}
        net['cellParams'][0]['sections']['soma'] = {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mech':'hh'}

        # or
        net['cellParams'] = []
        net['cellParams'].append({'tags':['cellType'], 'values':['PYR'], 'sections':
            {'soma': {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mechs':
                {'hh': {'gnbar': 1}}
                }
            }
        })
        net['cellParams'][0]['sections'] = {'soma': {}}
        net['cellParams'][0]['sectionParams']['soma'] = {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mech':'hh'}


        # option 2: dict of dict with tuple indices
        net['cellParams'] = {}
        net['cellParams'][('cellType','PYR')] = {'sections': {}, 'Izhi2007Type': 'RS'}
        sec = {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mechs': {}}
        sec['mechs'] = {'hh': {'gnbar': 1}}
        net['cellParams'][('cellType','PYR')]['sections'] = {'soma': sec}

        net['cellParams'] = {}
        net['cellParams'][('cellType','PYR')] = {'soma': {}}
        net['cellParams'][('cellType','PYR')]['soma'] = {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mechs': {}}
        net['cellParams'][('cellType','PYR')]['soma']['mechs'] = {'hh': {}}

        # or
        net['cellParams'][('cellType','PYR')] = {
            'soma':
                {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mechs': {
                    {'hh': {'gnbar': 1}}
                    }
                },
            'dend':
                {'diam': 18.8, 'L': 18.8, 'Ra': 123.0, 'mechs': {
                    {'hh': {'gnbar': 1}},
                    {'pas': {'gnbar': 1}}
                    }
                }
            }

*** cell.py structure using cell property rules + classes for cell models (exploit polymorphism)
class Cell:


 commonFuncsToAllCells():
  ...


class Izhi2007a():

 make():
  ...

class Izhi2007b():

 make():
  ...


class HH():

 make():
  setMorphology
  setBiophysics
  ...

 setMorphology(self):
  for sect in self.morphParams['Sects']:
   self.__dict__[comp.name] = h.Section()
   for mech in comp.mechs:
    self.__dict__[comp.name].insert(mech)
  ...

  or
  for sect in self.sectParams:
   self.__dict__[comp['name']] = h.Section()
   compRef = self.__dict__[comp['name']]
   h.pt3dclear(sec=compRef)
   h.pt3dadd(self.x, self.y, self.z, 20, sec=compRef)
  ...

 setBioPhysics(self):
  for comp in self.morphParams['Comps']:
   compRef=self.__dict__[comp['name']]
   for mech in comp['mechs']:
    self.__dict__[comp['name']].insert(mech['name'])
    mechRef=getattr(compRef, mech['name'])
    for prop in mech['props']
     mechRef.prop['name'] = prop['value']
  ...

 setSynapses:
  self.syns=[]
  self.syns.append(Syn(..))

** Synapses
- synapses as list of objects inside each cell (postsynaptic)? cell.syns[0]
- equivalent to concept of class Conn? one Conn per synapse? multiple Syn objects within one Conn ? - each syn can have
  multiple Conns
- Probably replace Conn with Syn; and define conn functions as class methods

- NeuroML probably implements in same way? hieararchy? - check but confusing, doesn't have Synapse instances, just classes

- netcon in pre is stub; netcon in post is real synapse
- netcon (neuron object) as part of synapse object
- Exc/Inh should be part of synapse

*** Best way to organize Synapse python objects, synapse Neuron objects, and connections/Netcons ?
- Premises:
-- Each neuron has sections; each section has synapses
-- The same synpase can be involved in many connections/Netcons to different afferent cells
-- Synapses and netcons should be stored with the post-synaptic cell (makes sense in terms of parallel processing)

- Do we need a python object to wrap the Neuron synapse object?
-- if Neuron synapse object contained in dict inside cell, with key=(section, synType), no additional info to store
-- maybe useful to have all info accessible to python (eg. for plotting,saving): cellgid (54), sect (soma), synType (AMPA),
synModel (ExpSyn)
-- maybe can include that info in dict key tuple (wouldn't need cellgid, if inside cell object)

- Do we need a python object to wrap the Neuron netcon object?
-- if Neuron netcon object contained in dict inside cell info accessible via Netcon
-- maybe useful to have all info accessible to python (eg. for plotting,saving): pregid, postgid, postsection, synType,
 weight, delay

cells[0].syns[('soma','AMPA')] = h.ExpSyn
cells[0].conns


*** connectivity rules for synapses?
** Background inputs
- create Synapse objects
- define in params.py in some standardized+flexible format
- make source be some kind of population? (Ben)

** 2 sets of params: 1) abstract specifications (rules etc), 2) explicit params for each cell + synapse
- 1) requires the python simulation code; 2) should be independent
- 2) should be ready after simulation setup - no need to run sim
- can give 1) + code to padraig and he can test his code by trying to reproduce 2)

** Matlab format equivalence for Python data types
- Python type = Matlab type
- class object = struct
- dict = struct
- tuple (nums) = array of nums
- tuple (mixed nums+chars) = array of chars (nums converted to chars)
- list (nums) = array of nums
- list (mixed nums+chars) = array of chars (nums converted to chars)
- nested dict = nested struct
- list of dicts = array of cells, each cell with struct

- dicts with tuple keys = NOT ALLOWED IN MATLAB

conclusion: all works nicely except dicts with tuple keys

- pickle saves and loads all these data types and structures perfectly

* 15aug25 Discussion with Ben on model format; and adding of several new features
** Google doc
*** Ben’s mental model of the model, for discussion/comparison to Salv’s:

1) Define a Model instance: new Model(cortical_thickness_um, radius_um) new Model(cortical_thickness_um, numCells) Additional
Model fields can be customized, mainly to configure global defaults (such as excitatory synapse type, or conduction velocity,
or default cell implementation, or parallelization details)

2) Add multiple Population instances to the Model:
addPopulation(name, type, normalized_radial_density_function_of_yf, something_for_xdensity) Populations are instantiated with
default values for internal fields such as a default single-cell implementation type; these can be customized now, or later -
for example to specify a morphology and membrane model or custom point neuron model. Individual cells don’t exist yet.


3) Add Connection instances to the Model:
addConnection(prePopName, postPopName, [probability, strength]) This can get very fancy too, with various built-in
non-uniform connection types available, e.g.: addYfracBinConnection(pre, post, yf_bins_pre, yf_bins_post, matrix_prob,
matrix_strength) addYfracGaussianPostConnection(pre, post, yf_mu, yf_sigma) ← independent of yf_pre The most flexible way is
to create a Connection that expects a function name/reference, and this function can perform arbitrary computation to wire up
the individual neurins: addCustomConnection(prePopName, postPopName, hook_custom_connect) the function signature should be:
hook_custom_connect(prepop, postpop) Additional properties of each Connection can be optionally customized, for example if a
particular type of synapse implementation is desired (to override the Model default)

4) Call instantiate() on the Model instance:
This runs through all the configured populations and connections to create instances of cells wire up these instances For
example, positive weights result in excitatory connections, negative weights inhibitory.  These steps rely on a range of
Model fields that have default values but can be customized (see 1c above), and on Population and Connection fields that can
override the Model-level values.

5) Other potential Model.xxx() methods include:
rescale(numCells or radius) generateVRML() toXML(filename, paramsOnly), toJSON(filename, paramsOnly) fromXML(filename,
paramsOnly), fromJSON(filename, paramsOnly) run(), although I was more thinking that an instantiated Model would get passed
as an argument to some other object, that knows how to create the low-level implementations and execute those … toNEURON()
maybe, or NEURON.implement(Model) .... which brings me to the next main point:

Note 1. I’m not sure whether what I mean above (4a) about “instances of cells” and “wire up these instances” in my mind means
actual executable implementations (e.g. in NEURON), or some meta-level. I could see these being Python objects that have a
soma location in 3D, a type, a field indicating the implementation type, and and a detailed list of incoming synapses (with
subcellular information if the implementation type is 3-dimensional). Then this keeps the Model instantiation still somewhat
simulator-independent. Do you think this would be beneficial? I like it because ideally I want this entire exercise to be
seen as a useful way of formalizing and sharing connectivity data even in the absence of a simulation. So for example someone
might use this to document their reported findings, and our system can generate a web page complete with visualization (with
Adrian) and links back to the source data/publications: its primary use in that case is to document, share, visualize,
compare either (a) experimental data, or (b) theoretical models. Imagine “what if” scenarios. If we can provide a system for
doing that, which at the same time is just “one step” away from running as a simulation, I think this effort could have a
really big, lasting impact. Don’t you?

Note 2. In support of this, I think we should include a default tag on every Population, Connection and Model object for
linking to source data: just a URL field. It’s optional, since some things are guesses or theoretical what-if explorations.

*** Comments by Salvador on Ben’s mental model of model
1) This is not currently implemented but had thought about it as future extension. The currect code is written in a way that
   makes it relatively easy to encapsulate everything within a Model object. eg. all parameters are stored in 2 dicts: net
   and sim, with the initial specification for the network (pops, conns, cell types,..) and simulation (duration, dt,...).

2) Populations parameters, similar to the ones you mention, are defined in a structured standardized Python dict
   (simulator-independent). During the model setup, the Population objects are instantiated and contain Python-NEURON
   specific methods to instantiate cells based on these parameters.

3) Connection are specified based on an arbitrary set of cell tags/attributes and not on populations. This allows to define
   conn rules for subpopulations (eg. IT cells, with certain projection target and yfrac range X). Conn rules are defined as
   simulator-independent Python dicts; and during model setup instantiated as NEURON/Python synapse and netcon objects etc.

4) 5. and Note 1. - The Model.instantiate() method is basically what I’m calling network setup: creates a network instance
   based on abstract specifications. I see your point about making this stage also simulator-independent. The way its
   implemented right now I think might be somewhere in between: the actual NEURON objects are being created (which enables
   running the simulation), but also all the detailed network instantiation info is being stored in Python structures
   (simulator-independent), which can be potentially exported to other formats. So there’s basically 2 levels of data we
   could share (actually 3):
a) Model specifications: populations parameters, cell type properties, connectivity rules, external input rules, etc
b) Model instantiation: explicit list of all cells (including cell properties, synapses, etc), all connections, external inputs, etc
c) Simulation output: spikes and/or voltage traces for simulation of specific duration, maybe specific stimulation of certain areas etc.

Note 1. I agree keeping model instantiations simulator-independent could be useful to compare/share experimental/theoretical
models. I guess thats one of the aims of NeuroML. In this line, its interesting that a few people asked Adrian about using
the visualization functions to explore experimental data.

Note 2. This can definitely be done and is needed, but need to think about it cause we might want to add eg. several
references for a given population, or include some discussion; and it could make the code/model specifications difficult to
follow.

** Neurosim chat

ok, so I finished answering some of your comments
17:06 maybe you can go over them and we can discuss here?
neurosim-isb@im.partych.at
17:08 [ben.suter] I'm looking at them now
neurosim-isb@im.partych.at
17:14 [ben.suter] It sounds like the main difference is that you instantiate the cells first, and then define and execute the connectivity rules over a global list of all cells. Whereas I described defining the connectivity rules between populations, and only then instantiating the cells and later connections.
17:14 [ben.suter] I think?
17:14 [ben.suter] I like your approach more, I believe.
Salvador Dura
17:14 yes, thats one of the differences
17:15 my approach is based on your CNS comments … basically trying to remove populations as much as possible from the equation
neurosim-isb@im.partych.at
17:16 [ben.suter] Interestingly, when I was writing up my mental model, I initially included two ways of setting up connections (one based on populations, and one as Model-level rules), and then as I was writing it out they sounded so similar that I removed part.
17:16 [ben.suter] But your description makes it clearer to me
Salvador Dura
17:17 in that same spirit, I've removed the classical concept of cell types, and replaced it with the 'cell property rules' described above; namely, defined based on a number of arbitrarily defined cell tags
neurosim-isb@im.partych.at
17:17 [ben.suter] Yeah, I recall our CNS conversation.
17:17 [ben.suter] Thanks
17:18 [ben.suter] I think the population-less approach is flexible and will fit closely with a greater variety of experimental data sets
17:18 [ben.suter] On the other hand, I can see how the concept of populations is convenient when building up a theoretical model (as opposed to interpreting/adapting experimental data)
17:19 [ben.suter] But I guess we could add Population-based construction methods on top of the system at a later point, if useful?
Salvador Dura
17:21 populations are still a key aspect of the model, since they define the tags of cells
17:21 and since these tags are arbitrary and both the conn rules and cell property rules are flexible, you could define your model in a classical population-based way
17:22 eg. create populations with 'cellType'='L2_EXC' ; then provide cell property rule and conn rule for 'cellType'='L2_EXC'
neurosim-isb@im.partych.at
17:25 [ben.suter] Is there anything in the model that requires populations to be used? I mean, could you currently just run through a list of cells (say from a paper data set) and instantiate each one with its appropriate tags?
17:25 [ben.suter] Because that seems useful
Salvador Dura
17:27 currently the creation of cells is based on the initial population specifications; but after that point populations are not used any more; so, yes, could add a function to load cell data with appropriate tags from some data file
neurosim-isb@im.partych.at
17:28 [ben.suter] Use case: take a published data set and reproduce it as a Model, with each recorded neuron directly represented. For example the Weiler data set, for each patched (postsynaptic) neuron. Next, create a presynaptic population for each yfrac bin mapped, and wire these up to each postsynaptic neuron per the individual maps.
17:28 [ben.suter] I'm really liking where this is headed .... ;)
17:29 [ben.suter] A system where we can make the strong claim that it is flexible enough to allow experimental data sets to be "translated" into a model with minimal conversion costs.
Salvador Dura
17:32 @use case - yeah, theoretically that should be possible; we could have a special type of population that eg. includes the tag 'readFromFile', and during the model setup,  the cell data is read from a file containing a list of cells with tags/attributes
neurosim-isb@im.partych.at
17:32 [ben.suter] If you have a connectivity matrix, then use populations to set up the model. If you have measurements from individual neurons, use that. For example, ChR2 experiments typically  involve a pre-synaptic population (not individual neurons), and ditto for Glu-LSPS. While paired recordings have individual neurons pre and post. Some experiments may have post-synaptic populations (say fiber-based Ca imaging, or multi-unit activity), though this is more rare.
17:33 [ben.suter] Is there a global list of cells? Is that itself a Population?
Salvador Dura
17:35 @conn matrix vs individual measurements - sure, but all conn rules will have to conform to the same standardized 'conn rule' format that specifies, precell tags, postcell tags, and weight, etc
17:35 there is a global list of cells: a python list of Cell objects
17:36 it is not a Population … initially I thought about including Cell objects inside of Population objects, but didnt do since wanted to remove the concept of populations
17:39 I've been thinking today about synapses and connections (netcons) and my current conclusion is to include the list of synapses and connections of each cell within the Cell object (still deciding if need synapse or connection class, or can just store eg. as a dict)
17:41 (btw it might all be a bit confusing right now since talking about different pieces in abstract, but hopefully will come clearer when I make some slides with overall structure and some examples)
neurosim-isb@im.partych.at
17:41 [ben.suter] @have to conform
17:42 [ben.suter] How difficult would it be, at this point, to make that flexible?
17:43 [ben.suter] Meaning, to make it possible to populate the model (aka the list of all cells) directly or via Populations, as desired?
Salvador Dura
17:48 not sure exactly what you are asking, can you give an example? (the model is currently populated via Population specifications, but as I said, should be possible to load cell list from file; the 'conforming' was in reference to the conn rules, which are also very flexible, since based on arbitrary tags)
neurosim-isb@im.partych.at
17:48 [ben.suter] Ah yes, let me try:
17:49 [ben.suter] Say for example that you don't want a "connection rule" so much as a specific / arbitrary set of connections. Doable? This (and the specification of cells) might not be loaded from a file, but instantiated programmatically.
17:50 [ben.suter] Basically the idea of Populations as convenience concepts/tools that can be used when appropriate
Salvador Dura
17:55 Not currently doable, but could be added; 2 things: 1) when you say programmatically, do you mean by generating a similar standardized python dict structure (simulator-independent) with all the individual network cells and connections?, 2) in what cases would that be a preferred option (instead of reading the data from some file) ?
neurosim-isb@im.partych.at
17:57 [ben.suter] Let me see ...
Salvador Dura
17:58 this is related to the 2 data formats I mentioned in the gdoc (4a and 4b) — currently my code uses 4a to specify the network params, and generates 4b; it should def be possible to say skip the setup phase, and directly load data in the 4b format with all the cells/connections already instantiated
17:59 when I say load, it doesn't need to be from a file, you could specify it programmatically, but following the 4b format
neurosim-isb@im.partych.at
18:01 [ben.suter] I feel like the general architecture of cells and synapses is a given, and flexible. There are some cases where we might prefer to have some signal coming from a more abstract "population" object (e.g. thalamic input) but that could be implemented as a SuperCell or just a special cell type. The flexibility is key, as it makes this useful for (a) describing experimental results, (b) defining theoretical models, (c) synthesizing these in simulation.
18:03 [ben.suter] One sec, brb to continue
neurosim-isb@im.partych.at
18:08 [ben.suter] From the experimental side: some data will be in terms of individual cells, some for populations. Sometimes population data is given as the average/SD calculated from individual neurons, and sometimes there is no cellular resolution and the population is less concrete.
Salvador Dura
18:08 (the external input aspect is something we need to think about too, cause its been key to all our previous models; we typically include 'background driving inputs/noise' to all our cells (using netstims) and tune the netstim firing rates and the connection weights to achieve the desired network behaviors)
neurosim-isb@im.partych.at
18:10 [ben.suter] From the theoretical side: seems to me many ideas and proposed rules are in terms of populations, but some theory pertains to synaptic integration by individual neurons too (e.g. plasticity, coincidence detection).
18:11 [ben.suter] The simulation aspect is what joins experimental and theoretical perspectives: in both cases it forces you to be clear about what you mean or have measured.
18:14 [ben.suter] Experimentalists don't think so much about populations, but theorists do. It's a useful concept for both. But I think it should be optional.
Salvador Dura
18:22 ok, makese sense, so what do you think about allowing model data to be entered in either format 4a or 4b as described in my previous paragraph above?
neurosim-isb@im.partych.at
18:24 [ben.suter] You refer to 4.a and 4.b in your comments on my comments, right?
Salvador Dura
18:24 yes
neurosim-isb@im.partych.at
18:25 [ben.suter] I think being able to combine these is useful
18:25 [ben.suter] A concrete example, the Weiler data set:
18:25 [ben.suter] No sorry, I meant Anderson & Sheets L5B
Salvador Dura
18:26 oh i c, combine both concepts
18:28 You have connected
neurosim-isb@im.partych.at
18:29 [ben.suter] You could say put an individual presynaptic neuron at each "pixel" in the mapping grid (something like 200+ pre cells for each recording). And so you'd have a model that from 100 mapped cells gives you 100 neurons in L5B and 20
18:29 [ben.suter] 20000 neurons distributed across the remaining layers
18:31 [ben.suter] But the maps are a bit noisy, and there is the issue of "NaN" pixels where there was direct excitation of the postsynaptic neuron. So we often average the maps into a radial profile, which also emphasizes the laminar patterns (over horizontal ones, which are more symmetric). So in that case, it may make sense instead to represent each pixel in the radial profile as a small population of presynaptic neurons that are located within that specific yfrac bin (100 um thick).
18:34 [ben.suter] In the final model, you'd probably want to have some divergence - meaning the a single presynaptic neuron can target more than one postsynaptic L5B neuron - i.e. we don't want 100 separate models, but one large interconnected one. So this is another reason to have populations presynaptically, where each pop is shared by all postsynaptic neurons. The connections could be wired up randomly according to the connection probabilities, or there could be some convergence and divergence rules.
18:35 [ben.suter] So that's a hybrid "individual postsynaptic neurons with presynaptic populations" model.
18:36 [ben.suter] But the third version has populations pre and post-synaptic: this is what we've done in the past for Weiler and such. Basically you start with a connectivity matrix (which was constructed by averaging across the individually recorded neurons), and use this to wire up pre and post populations.
Salvador Dura
18:37 ok got it; so the first thing that came to my mind (which might not be the best solution), is that it is actually currently doable by defining populations of size 1 (individual postsynaptic cells), together with populations of size 100 or whatever (presynaptic pops), and defining conn rules for each of the cells (using specific tags)
neurosim-isb@im.partych.at
18:38 [ben.suter] The thing is, going from individual maps to the connectivity matrix was not a trivial step (I recommend reading Gordon's 2008 NatNeurosci paper, to see how getting to the matrix seems to have been considered a substantial contribution). And when you look at the literature, you'll find data that cover these three scenarios.
18:39 [ben.suter] Yes, I agree. Your SinglePop as counterpart to my SuperCell suggestion ;)
Salvador Dura
18:40 so in this way all the (hybrid) model specifications would still be in the 4a format; and then we would generate specific model instantiations (format 4b), where all the presyn pops have now been converted to individual cells
18:41 @supercell  - right :)
neurosim-isb@im.partych.at
18:43 [ben.suter] I don't want to go too far out on a limb without seeing your code
18:43 [ben.suter] ... but ...
Salvador Dura
18:43 @3 scenarios - so you think allowing the flexibility to implement these 3 scenarios in the model, might facilitate the task of converting data between them for experimentalists?
neurosim-isb@im.partych.at
18:44 [ben.suter] Yes exactly.
18:44 [ben.suter] More importantly, I think it would broaden the appeal. Meaning that it will be more likely to fit the mental models of more people.
Salvador Dura
18:44 @far out - please do… this is a preliminary design stage, so everything is still flexible and up for debate
neurosim-isb@im.partych.at
18:45 [ben.suter] In my experience, few people want to use tools/systems where they feel like there is an impedance mismatch, i.e. where they have to change their way of picturing the problem in order to use the tool.
18:46 [ben.suter] And in this case, I think we all stand to benefit from a tool/approach that is flexible.
18:46 [ben.suter] And I think it fits with the "multi-scale" mandate/goal.
18:47 [ben.suter] In many ways, what we're talking about here is a question of scale: do you think/implement/measure cells or populations? Both.
18:47 [ben.suter] What I'm picturing is a Model object that consists of all of the above, and can do so simultaneously.
Salvador Dura
18:48 @appeal - I agree, but also want to point out that added flexibility usually brings with it more complexity (both in the way the model is specified, and the instantiation code) which can reduce appeal — not to say we shouldn't do it, but that should keep in mind pragmatic issues, project duration, etc
neurosim-isb@im.partych.at
18:49 [ben.suter] So it can have a list of cells. But also a list of populations. Some of those populations may - at some point in time - be converted to a lost of cells: when that happens, the Population need not disappear, it simply becomes a reference to that group of new cells.
18:50 [ben.suter] If a connection is specific onto a Population, and the population gets instantiated / linked to specific cells at a later point, then the connection would have to be distributed onto the individual cells at that time.
18:51 [ben.suter] This is getting very abstract, I realize, but I think this may actually be on the critical path towards solving the "multi-scale" problem.
18:53 You have connected
Salvador Dura
18:54 ok got it, yeah I think thats doable; either defining single cells within the list of populations (which could be renamed to network objects or similar), or adding a list of cells in the params specifications; and then during model setup / instantiation just taking into account the different scenarios (cell->pop, pop->cell , etc) — could also use the tags/attribute concept to specify whether its a cell or population
neurosim-isb@im.partych.at
18:56 [ben.suter] In an abstract sense, these considerations are very similar to what I spent my M.S. years working on for geometric analysis software: we wanted to define automated analysis workflows built up from small atomic operations (like vector product, dot product, selection, arithmetic, comparison). To make that useful, you need to be able to define new higher-level operations in terms of the lower-level building blocks (for example, a higher-level operation might be "extrude a surface in z" and be implemented as a sequence of atomic operations). But this goes on and on: ultimately you want a building block that is called "identify structural conflicts", which requires many sequences within sequences.
18:57 [ben.suter] In the end, what you have is of course still a directed acyclic graph of atomic operations (that's what can be executed by the machine), but it would look like a rat's nest of nodes and edges if you don't have the ability to simplify the graph by replacing certain repeating motifs by a single node (or "block").
18:58 [ben.suter] This is like a "visual  programming language".
Salvador Dura
18:59 right, yeah when you think about it, everything in the world seems to follow these multiscale principles!
19:02 anyway, so going back to the specifics… say we are able to define hybrid models with both cells and populations, with a set of tags/attributes (pops would get converted to cells with those attributes) — I think defining the conn rules would still work using the current format, ie. specifying pre and post cell tags (note to reference specific populations you could do it by using some of the tags that define that population, or creating a specific tag to differentiate between pops)
neurosim-isb@im.partych.at
19:04 [ben.suter] Perspectors, if you're curious ;)
19:04 [ben.suter] http://www.sciencedirect.com/science/article/pii/S1474034604000291
19:04 [ben.suter] So the specifics ...
Salvador Dura
19:05 @perspectors - thanks, looks very cool
neurosim-isb@im.partych.at
19:05 [ben.suter] What I was trying to convey, but didn't quite, is that having the ability to "nest" stuff in containers is useful. So before we go on, I wanted to pull back even further a bit ... and point out that there is a bunch of work that looks at the connections between entire brain areas.
19:08 [ben.suter] And my work (which we'd like to incorporate) is a bit like that: for example, I have data on "thalamic" input to M1-CSP. But Naoki's data might (and if not, other studies likely will) find that the innervation pattern I found is a superposition of multiple different projections from smaller nuclei in the thalamus: and that for example thalamic input to L1 is rhythmic at 30 Hz, while input to CSP dendrites near the soma comes from an adjacent nucleus (or just a second cell type) and is rhythmic at 10 Hz.
19:10 [ben.suter] Or for input from S2, I know that cells in S2 that project to M1 were found in all layers - but my AAV injections labeled across all layers. So future studies may split this out. For example, we think that maybe L2 in S2 contacts L2 in M1, while L5 in S2 contacts L5 in M1. But it could be crossed instead. And so on.
19:11 [ben.suter] So an "S2" population now may likely become fractionated into multiple populations later ("S2-L2/3", "S2-L5"). Or "S1-S2p" and "S1-M1p" per Petersen.
19:12 [ben.suter] All that said, I understand and agree with your points about not letting flexibility get in the way of progress. And that big goals take longer to reach, and we should at least hit intermediate goals first!
19:13 [ben.suter] I'll think about this some more. I have a feeling that there's a way for us to handle this "Population" question now, such that we'll be solving two (or many) problems at once - or at least making a broader solution more attainable.
19:13 [ben.suter] @ specifics: that sounds good
Salvador Dura
19:17 I get your point about the hierarchical nesting and incorporating from different regions, which could later be split into smaller subregions etc — its definitely an important aspect, and although we are focusing on M1 now, would be nice to implement the framework such that it can cope with it in the future
neurosim-isb@im.partych.at
19:18 [ben.suter] Righto
Salvador Dura
19:21 for previous models we've sometimes grouped 'networks' into columns, and then define ways to connect different columns; I don't think columns make much sense any more; but maybe a similar concept like 'Network', 'Circuit', 'Region' or similar that subsumes 'Populations' might be useful — anyway we can develop the framework gradually and keep adding features
19:22 have to leave for ~30 mins, but will be back later if want to keep discussing
19:22 thanks for this, very useful
neurosim-isb@im.partych.at
19:29 [ben.suter] Thank you. I'm gonna be gone for a bit too. Let's let it sit and ponder a bit. Not to keep you from moving ahead, though. What you have seems good, and the more flexible approach you describe sounds even better.
20:29 You have connected

** Main points
- Allow to read/specify directly cell/connections, to allow to characterize/share experimental data.
-- can use special type of population params (single cell, tags); or a different dict for cell params

- Enable simulator-independent visualization/storage of instantiated network (to represent experimental data)
-- generate simulator-independent python structures when creating Neuron objects? (eg. synpase and conn classes) memory overhead

- Keep association between cell and populations -- can be done via tags: 'pop':'E2'
-- this can be used to specify connectivity rules

- Encapsulate all network within a class, so can then call network.instantiate()
-- have to think about this, in order to keep specifications separate from simulation (eg. want params within network class?)
-- network, sim and/or shared modules can become class?

** Encapsulation using network and simulation
- create class Network with:
-- all network methods
-- cells (list of Cell objects, with syns and conns inside)
-- pops (list of Pop objects)
-- connection methods to this class
-- p.net params
-- access via s.net; initialize as s.net = Network()); access cells as s.net.cells; s.net.cells.syns

- create class Simuation with:
-- all simulation methods
-- p.sim params
-- acces via s.sim; initialize as s.sim = Simulation()
-- maybe move shared stuff here?

- parallel implementation!? - all nodes contain a class network and class sim? same as now with modules?

- how do Cell methods access Network and Simulation objects?
1) from shared: s.net.params['cellProperties']
-- long
-- not encapsulated
-- what if parent not called net?)
-- cannot
2) passed as argument parent object net: net.params
-- recursive? eg. net.cells.method -- dont use;
-- also need sim object;
-- what happens if modify objects?

- how to initialize params in network and simulation object?
-- have separate params file with dict and make s.net.params = p1_sim ; s.sim.params = p2_sim
--- simulator independent
--- can have many of these params files and import; or declare many params dicts in one

- move shared to sim, and net to inside sim (s.net)
-- network methods need to access sim/shared attributes:
--- simdata/output spikes
--- parallelcontext
--- rank
--- nhosts
--- p.sim (sim params)
--- lastGid - ?
--- id32 random - ?
--- gidVec and gidDic - can move to net
--- fih (FInitializeHandler) - can move to net
--- Synapse - can move to net
--- Cell classes - can move to net

- use abstract superClasses network and simulation; multiple inheritance onto model class that can access attributes and
  methods of both
-- doesnt work

- have sim inside network
-- doesnt work


- Pass sim object (self) as argument to net; and net object to sim
-- right way to do in python (careful with circular references)
http://bytes.com/topic/python/answers/695963-passing-self-argumnet-other-methods-class
http://stackoverflow.com/questions/3945924/passing-self-into-a-constructor-in-python
-- both net and sim objects are independent but have pointers to the other one
-- long calls: self.sim.params['duration'] or self.sim.pc

-- Network as class; but Simulation as module
--- shorter calls: sim.params[''] or sim.pc ; or s.
--- sim params not encapsulated / not consistent with net
--- can have net inside sim (or just reference)
--- sim can import analysis, and pass net
--- if want to create variable need to use global (equivalent of self in classes)
--- have to be careful if don't use global in method and create local variable

- Network as abstract class; import from simulation as module and call class methods and attributes directly?
-- or alternatively import instantiated object Simulation
-- s= Simulation()
-- from sim import s
-- both options are possible (import as abstract class or as object) but:
--- can be confusing (have to use classmethod, or create instance inside same module)
--- have to use self. (can use s. or other, but not proper python)
--- only works for single instance/object, so not different from module


- common object holder for sim and net doesn't work because recursive:
eg.
model.py:
 net = Network()
 sim = Sim()

net.py:
 from model import sim
 class Network()

sim.py:
 from model import net
 class Sim()

- FINAL: Go back to shared!!
-- shared.py module containing shared variables, including net, but no funcs
-- sim.py module containing just functions
-- network.py contains Class net, and import shared as s
-- params.py independent, used as cfg file optionally; params copied over to s.params and s.net.params
--- eg. could use params from previous saved network (flexibility), or defined independently
-- init.py imports module shared as s; and optionally params
--- a network object can be passed as argument to sim.initialization; or new network object created

-- dont like s.params and s.net.params; maybe use s.cfg and s.net.params
-- maybe replace simparams with cfg?
-- use s.cfg['verbose'] and s.net.params['popParams']
-- avoids confusion with sim module, and net object

- could have a folder params with param files for different nets: params/M1yfrac.py params/mpiHHTut.py etc (need package)
-- within file can have different versions: eg. params.M1yfrac['default'] or params.M1yfrac['withL1']

** Specific changes made
- add popName to popParams tags and to Cell.tags (each cell can belong to a pop)
- add cellGids to Population
- enable special type of population with ['cellList': []] - instantiate individual cells
- change cellParams to cellProps; make a list; add ['name'] = 'ITyfrac' and ['conditions'] = {'cellType': 'IT', 'yfracRange':
  [0.3, 0.5]}
-- for each Cell object add automatically to ['tags']['cellProps']=['ITyfrac', 'lowerNAchannel']
-- This way avoid having to include cell properties in each instantiated Cell object (save memory, by referencing cellProps),
-- but still can define properties in flexible way, for arbitrary sets of cell tags
-- and have several property sets for the same cell (last one will overwrite previous ones)
** 'Pointers' to cell property sets in netParams to save space
- Do not store all the cell properties (sects, mechs, syns, geom, topol) for each cell; only include list with cell
  properties dict keys.
- To get all properties, merge dicts (NOTE: actually need to merge all sub-dicts independently!!):

eg. if dict of dicts:
def merge_dicts(*dict_args):
    '''
    Given any number of dicts, shallow copy and merge into a new dict,
    precedence goes to key value pairs in latter dicts.
    '''
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result

cellProps = merge_dicts(s.net.params['cellProps'][key] for key in self.propDictList)

if list of dicts:

def merge_dicts(dict_args):
    '''
    Given any number of dicts, shallow copy and merge into a new dict,
    precedence goes to key value pairs in latter dicts.
    '''
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result

cellProps = merge_dicts([prop for prop in s.net.params['cellProps'] if prop['label'] in self.propDictList])



- Remember that h.Objects are also python classes, so have similar structure, and thus don't need to save all params again
  for each cell. Topol and geom not stored using same structure, but can be obtained from s.net.param['cellProps']

- Structure:

** Network structure
**** Cell
***** gid
global id
***** tag
dict of tags
***** props
list of propDictKeys
***** sect
dict of sections
****** mech
dict of mechanisms, each = h.Object()
eg. s.cell.sect['soma']['mech']['hh'].gnbar
or s.cell.sect['soma']['mech']['hh'].__dict__['gnbar']
****** syn
dict of syns, each = h.Object()
eg. s.cell.sect['soma']['syn']['AMPA'].gnbar
***** conn
list of h.NetCons
****** NetCon
weight
delay
threshold
srcgid
syn (ref to target syn) - can use syn.label

** Allow option of creating 1) Neuron h object or 2) simulator-independent Python structue
- uses up twice the space, so for some sims may not need Neuron objs, or Python objs; or can choose to create Python objs at
  the end

- include within same dict:
eg.
self.sect['soma']['hSection'] = h.Section()

self.sect['soma']['hSection'].insert(hh)

self.sect['soma']['syn']['AMPA']['hSyn'] = h.ExpSyn()
self.sect['soma']['mech']
self.conn[0]['hNetCon'] = h.NetCon()

s.net.cell[0].sect['soma']['syn']['AMPA']['hSyn']
s.net.cell[0].sect['soma']['mech']['hh']['hObj']

- or in separate dicts?:
self.hsect['soma'] = h.Section()
self.hconn[0] = h.NetCon()
self.hsyn['soma_AMPA'] = h.ExpSyn()

- makes more sense within same dict cause if create both, can immediately access the other
** issues with importing package params
http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html
** How to set mechanism property dynamically
sec = h.Section()
sec.insert('hh')

trying to find how to set mechanism parameters of a section dynamically using values stored in strings, eg. if have:
mech='hh'
param='gna'
value=2

- sam just figured out can do via:
section(0.5).__getattribute__(mech).__setattr__(param,value)

- tried many options which didn't work, eg. via section(0.5).__dict__[mech]
- for some reason section(0.5).__dict__[mech] = None
** DONE Background inputs
- Create population with cellModel=NetStim, and tags to define the stim
- Use conn rules to add NetStim

- Currently:
    def addBackground (self):
        self.backgroundRand = h.Random()
        self.backgroundRand.MCellRan4(self.gid,self.gid*2)
        self.backgroundRand.negexp(1)
        self.backgroundSource = h.NetStim() # Create a NetStim
        self.backgroundSource.interval = s.net.params['backgroundRate']**-1*1e3 # Take inverse of the frequency and then convert from Hz^-1 to ms
        self.backgroundSource.noiseFromRandom(self.backgroundRand) # Set it to use this random number generator
        self.backgroundSource.noise = s.net.params['backgroundNoise'] # Fractional noise in timing
        self.backgroundSource.number = s.net.params['backgroundNumber'] # Number of spikes
        self.backgroundSyn = h.ExpSyn(0,sec=self.soma)
        self.backgroundConn = h.NetCon(self.backgroundSource, self.backgroundSyn) # Connect this noisy input to a cell
        for r in range(s.net.params['numReceptors']): self.backgroundConn.weight[r]=0 # Initialize weights to 0, otherwise get memory leaks
        self.backgroundConn.weight[0] = s.net.params['backgroundWeight'][0] # Specify the weight -- 1 is NMDA receptor for smoother, more summative activation
        self.backgroundConn.delay=2 # Specify the delay in ms -- shouldn't make a spot of difference

- Create popParam:

netParams['popParams'].append({'popLabel': 'background', 'cellModel': 'NetStim', 'rate':100, 'noise': 0.5, 'source':
'random'}) #  background

- create connParam:
netParams['connParams'].append({'preTags': {'popLabel': 'background'}, 'postTags': {'cellType': ['IT','PT','CT'] },
    'probability': (lambda prey,posty: 0.1*prey+0.01/posty), \
    'weight': (lambda prey,posty: 1),
    'syn': 'AMPA',
    'delay': 5 )  # IT->IT rule

- store randomizer h object and netstim list in the population object? or in the cell object? or maybe with the cell.conn object??

- if pop.cellModel = Netstim -> add netstims to cell/conn object?

- or maybe create cell objects that are really netstims?

- or maybe add dict stims to cells? cell[0].stims[0]={'popLabel': 'background', 'rate':50, 'noise': 0.4, 'hNetStim':
  h.Netstim(), 'hRandom': h.Random()} - YES!

- conns[0]={'preGid': 'background', postGid: self.gid, 'weight':, 'delay':, 'hNetcon': h.Netcon()}

- addstim() func creates netstim, netcon and random, and stores in stim dict inside cell

** DONE Recording
*** Format
- dict of dicts eg:
simConfig['recdict'] = {'V':{'sec':'soma','pos':0.5,'var':'v'}, 'u':{'sec':'soma','pos':0.5,'m._ref_u', 'I':'m._ref_i'}

- how to reference u and i variables in izhi object?

** DONE Gathering data from nodes
** TODO connectivity implementation details
*** segments and synapses
for point processes (including synapses):
- pnt.get_segment()
Syntax:
pyseg = pnt.get_segment()
Description:
A more pythonic version of get_loc() in that it returns a python segment object without pushing the section stack. From a
segment object one can get the section with pyseg.sec and the position with pyseg.x. If the point process is not located
anywhere, the return value is None.

- can access syn via segment:

sec(0.5).point_processes()[0].__dict__ == syn.__dict__

- contains a specific location (0-1), and the section segment that points to that pointprocess (syn) will be updated
  depending on nseg

*** when defining a connection between eg 2 populations, how are we gonna specify the target sections+synapse locations?
- some kind of distribution function? do we have experimental data for this?

*** Ben chat
[ben.suter] So my suggestion is to implement the delay in a way that is flexible, i.e. a function that pulls from pre and post syanaptic properties:
[ben.suter] generate_delay(pre_cell, post_cell) where the function has access to properties of the cell objects, including 3D
position of soma, cell type / transmitter type, and synapse location. To start, for point neurons and a soma-to-soma delay,
I'd go with 5 ms.

[ben.suter] The way I see it, the main point of having dendrites (i.e. complex cells) is to specify synapse
locations. Subcellular location of synapses depends on pre- and post-synaptic cell type, and soma depth of the postsynaptic
cell, possibly  also on sublaminar soma depth of the presynaptic cell (to what degree is less clear).
[ben.suter] For CSP complex model, I have mapped the synapse locations for the L2/3->CSP pathway.
[ben.suter] But we don't know the synapse locations for other local connections (e.g. CSP->CSP, CSTR->CSP, FS->CSP).
[ben.suter] For some of the input pathways, we know the size of a unitary EPSP (range of sizes actually).
[ben.suter] And from past studies, we know that local L5->L5 unitary connections consist of 4-6 synapses each.
[ben.suter] So my suggestion is to have a function that distributes synapses on the postsynaptic neuron, after all synapses have been specified.
[ben.suter] What I mean is this:
[ben.suter] 1. Populate the model with all the neurons, based on density measurements and desired simulation volume/size.
[ben.suter] 2. Generate all the logical synapses between these neurons, but for non-point neurons the synapses don't actually
get wired up yet  (or they all get placed on the soma as a placeholder).
[ben.suter] 3. For each non-point neuron, relocate all the synapses according to measured relative density patterns (i.e. sCRACM maps).
[ben.suter] For example, if in the instantiated model a CSP neuron receives excitatory input from 200 L2/3 neurons, resulting
in say 1000 synaptic contacts,  we would then spread out these 1000 contacts through the dendritic arbor, but constrained by
the relative density pattern  derived from my sCRACM maps.
[ben.suter] For an e.g. 5-compartment model, we would collapse the full geometric sCRACM-derived density pattern to a
simplified form, to where we express the  relative synaptic density for each compartment (e.g. axon=0, soma=0, basal=0.6, proximal apical 0.3, distal apical 0.1).
[ben.suter] I've implemented this in my synaptic NEURON model for a single post-synaptic neuron.
[ben.suter] At the level of the network model specification, one possibility is to represent synapses as the edges in the
graph, with pointers to the pre- and  post-synaptic neuron, and a number of additional properties, including: transmitter
type, # contacts, amplitude or scale factor,  and reference to a subcellular pattern.

[ben.suter] During model instantiation, the connectivity-generation step generates a bunch of such logical synapse
objects. Then a subsequent step processes  each synapse object and creates the requisite # of synaptic contacts, placing them in the appropriate dendritic segments.
[ben.suter] One main reason for splitting this into two steps is so that the total # of contacts is known at the time when
(during the 2nd step) the synaptic  contacts are positioned - I think this will be helpful because the synaptic location
patterns (sCRACM-derived maps)  are known in relative (not absolute) magnitude.
[ben.suter] Another reason is that I think this approach will degrade gracefully when point neurons take the place of full
models, and vice-versa.  Specifically, the model instantiation remains the same, the synapse objects are the same, but the
actual synaptic contacts can vary,  depending on the post-synaptic implementation type.
[ben.suter] I.e. if the postsynaptic neuron is a full model, then the synaptic contacts can be created according to the full
extent of data available  (resulting in say 1000 synaptic contacts with a particular subcellular distribution, and over a
range of amplitudes and delays).  When the postsynaptic neuron is a point-neuron, then the same logical synapse would result
in only 200 synaptic "contacts"  (assuming the case where there are 5 contacts per unitary synapse) each without any
subcellular information,  but with 5-fold amplitude.

- summary:
-- depends on pre- and post cell type; post (and maybe pre) soma depth
-- mapped synapse locations for some pathways via sCRACM (eg. L2/3->CSP)
-- Proposes adding synapses (and connections?) first as placeholders; and then relocating them based on relative density
-- synapse (or connection?) properties: pre+post neurons, transmitter type, num of contacts, scale factor, ref to subcellular pattern
[note: can have multiple connections to 1 synapse; so num of contacts requires different conns, since will be in diff loc]
-- 2-step process: 1) create logical conns (above properties); 2) create syns based on total conns and relative distribution
[do we need total or can apply relative distributions to each logicConn?]
-- Synapse objects independent of cell model; synapse contacts instantiated depending on point cell, or num compartments etc
-- Eg. 200 pre -> 1 post, 5 contacts/cell:
--- Full HH: 1000 syn contacts with subcellular distribution, range of amplitude and delays
--- PP: 200 syn contacts with 5x amplitude (single h.Syn object?)

*** ideas of how to implement and open questions
- in cellProperties? -- nope, because its specific to 2 pops; or maybe yes, specifying presyn pop
- can be stored in conn rule
- requires canonical format which can be adapted to different num of compartments etc
- relative density pattern can be stored as func and then adpated to the number of sections/segments
-- Possible implementation:
--- create cell-2-cell connections based on conn rules: pre, post, transmitter/syn type, num contacts
1) for each abstract connection, create synapses (+h objects) and conn contacts  ( + Netcons) based on cellModel and density
   pattern (stored in cell prop or conn rules)
2) create logicConn objects within post cell: pre, post, transmitter (receptor/syn type), num contacts (specified in conn rules); created based on conn rules
3) within logicConn object, have netcons (hNetcon, delay, weight, targetSyn, pregid?) and syns (hSyn, type, sec, loc, tau1,
   tau2); create based on preGid tags, net.params.cellProp

- if syn shared (many cells connect to single syn) then cannot be inside a logicConn
- number and position of syns will depend on logic conns made (eg. if conn from 200 cells, cell types)

- numSyns (per type, eg AMP) = numSegments or numSections or depends on how much want to discretize syn relative distribution

- eg. can make all conns to one section go to single synapse (0.5); but if nseg>1 can have multiple synapses; but do we
  necessarily always want one synpase per segment?

- in current implementation, syns are usually defined wihtin the cell properties/template - but will depend on conns right?

*** Email to Ben
Hi Ben,
I've been working on the implementation of subcellular connectivity patterns, so I re-read some of the suggestions you
made in the chat a few months ago. I've tried to summarised your main points and then added some questions/comments, to the
shared gdoc: https://docs.google.com/document/d/1xaEUdUhqtqtvd2bfCruGfjNcCvIxQPvCaIL-SYDZDLA/edit#heading=h.xqev18eqksg0 .

Please can you have a look when you get a chance? thanks
salva

*** Gdoc text with summary and questions
Subcellular connectivity patterns and implementation suggested by Ben
Summary
Subcellular location of synapses depends on pre- and post-synaptic cell type, and soma depth of the post-synaptic cell (unclear if also of presynaptic cell soma depth)

From experiments you have different levels of detail for different pathways, eg.
Mapped synapse locations for L2/3->CSP (sCRACM) but not for CSP->CSP, CSTR->CSP, FS->CSP
Range of sizes of unitary EPSP for some pathways
Unitary connections consist of 4-6 synapses for local L5->L5 pathways

Proposes a 2-step implementation:
Step 1: Create logical synapses/connections between cells, without subcellular location info.
Step 2: For non-point neurons relocate/create all the unitary synapses (synaptic contacts) according to measured relative
density  (collapsed to num of compartments in cell)

Rationale for the 2-step implementation:
Step 1 provides the total number of contacts, which is required by Step 2 in order to relocate/create synpases based on measured relative density.
Step 1 logical synapses are independent of cell model; ie. the same logical synapse can be used to generate the specific
synaptic contacts  for a point neuron or a 1000-compartment neuron.

Example of 2-step implementation for 200 Exc L2/3 cells -> 1 CSP cell, with 5 contacts per unitary synapse:
Step 1: Create 200 logical synapses
Step 2:
Point neuron: instantiate 200 synapses to soma with weight=weight*5 (contacts/synapse)
5-comp neuron: instantiate 200*5=1000 synapses distributed based on collapsed measured relative density (e.g. axon=0, soma=0,
basal=0.6,  proximal apical 0.3, distal apical 0.1)
500-comp neuron: instantiate 200*5=1000 synapses distributed based on measured relative density (e.g. …)


Questions/Comments (Salvador)

You mentioned you’ve implemented the 2-step method in your synaptic NEURON model - can you please send it, or point me to it (if Sam already has it) ?

In your description of the system (chat log) it is not clear if the number of logical synapses (step 1) should be a) one per
synaptic contact   (1000 in example), which then get positioned in step 2; or b) one per cell-to-cell unitary connection (200
in example),  each of which can then instantiate multiple synaptic contacts. Based on your later comments (logic synapses are
same for  different cell models) I assume b).

How would the initial specifications look like?
In existing models, we sometimes include synapse properties as part of the cell intrinsic properties; but here seems relative
density will  depend on presyn cell type? so for each postsyn cell type, maybe can provide relative densities for each type
of presyn cell  (eg. Exc L2/3)? and I assume also for each type of synapse (eg. AMPA)?
How is relative density represented? As a function of yfrac? discrete distribution?
What other types of info can be used for cases when density is not available, and how would they be represented (eg. range of sizes of unitary EPSP)?
What other parameters will be provided for each connection prior to step 1? presyn cell/pop, postsyn cell/pop,
transmitterType,  contactsPerSynapse, amplitude/scale factor/weight (range/distribution?), delay (range/distribution?) ? (see example in next subsection)

In NEURON several Netcons (h.Netcon) can target the same Synapse point process (h.Synapse) so, for the example of 200 L2/3 ->
1  CSP and contactsPerSynapse=5:
a point neuron (1 comp) only needs one h.Synapse (per receptor type), and 200 h.Netcons
a 5-comp neuron may have 1-5 h.Synapses (since a given compartment may not have connections); and 200-1000 h.Netcons
(depending on  how contactsPerSynapse is implemented)
a 500-comp may have 1-500 h.Synapses, and 200-1000 h.Netcons (depending on how contactsPerSynapse is implemented)
In general: 1 <= num of h.Synapses <= num compartments (segments)
In general: unitary conns <= num of h.Netcons <= unitary conns * contactsPerSynapse

Based on point 4 (above):
Is there any case where we want to assign multiple h.Synapses of the same type to the same segment? If not, num and location
of h.Synapses  can be calculated unambiguously.
What is the criteria to group multiple syn contacts (h.Netcons) into a single one with increased weight/amplitude? Are all
groups of  h.Netcons that project onto the same segment/h.Synapse (calculated based on relative density) combined into single h.Netcon?

Final number of h.Netcons and h.Synapses could be calculated based on relative density, for each of the 200 individual L2/3
projections  at a time. However, given the small number of contactsPerSynapse, for cells with many compartments, rounding the
resulting  fractional values (eg. 0.01 relative density x 5 contacts = 0.05 ~= 0 contacts/compartment) would result in loss of information.
Is this the reason why all logic connections need to be known before moving to Step 2 (subcellular instantiation)?
What happens when even the total number of contacts (from all incoming connections) is very low compared to the number of
compartments?  contacts are assigned to compartments with the highest relative density values?

Possible data structure
Initial specifications example
connParams (in params file):
preTags: {‘cellType’ = ‘IT’}
postTags: {‘cellType’ = ‘PT’}
synReceptor: ‘AMPA’
contactsPerSynapse: 5
probability: lambda func(preyfrac, postyfrac) = -5.6 * postyfrac
weight:  lambda func(preyfrac, postyfrac) = -5.6 * postyfrac
delay: range? distribution? [if presyn = population, need separate cellular/pop and subcellular delay ranges?]
subcellularRelativeDensity: {AMPA: ?}

and/or

cellProperties (in params file):
label: ‘PT’
condition: {‘cellType’ = ‘PT’}
sections: {soma, dend,...}
soma: {geom, topol, mechs, syns}
syns: {AMPA, NMDA,..}
AMPA: {relativeDensity: {‘presyn=IT’: ?}
Instantiated network logical synapses / unitary connection example
logicalConns (within Cell object):
presyn cell:
postsyn cell:
synReceptor:
contactsPerSyn:
weight: range?
delay: range?
contacts: list of Contacts object/dict (see below)

Instantiated network unitary synapses/contacts example

contacts (within logicalConn):
hNetcon: h.Netcon() object
weight:
delay:
synapse: type+section+loc? label? ref?

syns (within Cell object):
hSyn: eg. Exp2Syn() object
section:
loc:
type:
params: {tau1: , tau2:  ..}




*** Any way to avoid gathering data from all cells in all nodes during conn?
- Conn is calculated for each postsyn cell in each node
- Only need presyn cell gid to create Netcon
- However, many conn funcs (eg. yfrac) require info (tags!) to create the conns, eg. x,y,z, cellType
- If conn occurs for each postsyn cell, Conn funcs can be within Cell object, and can pass as argument presyn tags required

Option 1:
- For each rule:
-- Depending on connFunc, gather tags of presyn cells or not (if already gathered don't do again)
-- For each postsyn cell: call connFunc within Cell object (which calls Cell.addConn())

Option 2:
- For each rule:
-- Call connFunc in Network object
--- connFunc will gather presyn tags if necessary
--- For each postsyn cell: addConns

Option 3:
- For each rule:
-- Depending on connFunc, gather tags of presyn cells or not (if already gathered don't do again)
-- Call connFunc in Network object
--- For each postsyn cell: addConns

- Option 1 can help reduce the overhead of gathering same info many times - how can do also in option 2?

- Option 1 can limit the conn functions since forces to be based on iterating over postsyn cells (eg. might not be optimum
  for divergent connectivity pattern)

- Option 3! combines best of both

- Dont need preTags if fullCon AND preTags is popLabel or any tag common to all cells in pop - can get Gids from Pop object
- Otherwise need preTags to find Gids

** TODO How to store density distributions of mechanisms in params file?
for(x,0) {
        xd = x_dist(x)
        if(xd <= nexusdist) {
          gbar_h15(x) = h_gbar*exp(x_dist(x)/h_lambda)
        } else { // this else should not happen...
          print xd , " > " , nexusdist
          gbar_h15(x) = h_gbar_tuft // but if main trunk extends slightly beyond branchpoint, should be OK...
        }
        if ( gbar_h15(x) < 0 ) { gbar_h(x) = 0 } // conductance must not be negative
      }
    }

*** chat with sam
how does the simulator import these functions? suppose at py level not so difficult, but what about other values that belong
to the object?

the exp increase has a space constant eg h_lambda which depends on nexusdist (distance to the nexus) and the other h_gbar
params - but those can be part of function, if available

for(x,0) should iterate through segment positions within the section
it's within the forsec apical loop, which goes through apical sections

** TODO Saving to different formats: mat, xml, json etc
*** saving functions to file
- if want to see cpython bytecode instructions (disassemble) of any python function can do: import dis;
  dis.dis(func.__code__)

- to get source code (string) of a python function (eg. if want to write to file) can use: inspect.getsource(func)
** TODO For each network/cell method specify in comments/table what params and tags are required
- also add try: except to deal with missing params etc


** Comparison to PyNN
- deals with more detailed structures: ion channels, dendritic structure etc
- purely declarative vs PyNN's mixed declarative-procedural
- Currently only supports conversion to NEURON, whereas PyNN to many simulators
- Support for yfrac-dep density and conn rules
- Support for arbitrary tags, and arbitrary cell property and conn rules based on these tags

* 15sep15 Meeting discussing future plans/papers
** paper on morphology and physio
- variability in firing as function of variability of morphology
- no diff within corticostriatal (IT, thin tufted) pop
- but diffs between IT and corticospinal (PT, thick tufted) - classical
- but in layer 5A IT (corticostriatal) have bigger tufts (dependent on soma depth)
- 4 reconstructions - L5pyr, L4 stellate, L3 pyr, and other - very diff morphologies
- use model he has
- patch around L5A/B border with tuft - cannot say if IT and PT --> yfrac-dep not IT vs PT
- transition in border or continuum? - need to rescale um to yfrac
- probably smooth yfrac-dependence (anatomical story)
- sam do modeling
** paper on network
- 200 L2/3 neurons - make assumption they all have equal weights
- dont distinguish betwen conn prob and weight
- model can look at it - disentangle - vary such that product remains contact
- maps are repeated 2 or 3 times
- conn matrix involve averaging
- postsyn cells recorded from will be lumped in
- peak response and total area under charge for each pixel repeated 2 or 3 times per cell
- radial pattern - collapse 256 maps into laminar input - have a row corresponding through slice cortex and look trial-trial
  variability
- average across a line - at a given pixel they were all stimulated same time; but across a line
- difficult to relate variability to connectivity
- calibrated max num of presyn cells that fire - so have certain limits
- sense of unitary connection (L5 cells) - 4-7 contacts
- conn weights should be bounded by something realistic

- implement model without subcellular info
- population level value - adaptation index
- IT, PT, CT
- then break IT into subclasses
- CT Kumar and Ohana - no morphology
* 15sep22 M1 network params (for initial izhi-based model)
** Spreadsheet with params and discussion with Ben
https://docs.google.com/spreadsheets/d/1gcrF-enRS0K5EYdLNpEtnWD5vp5_uDfhS74PMGuLbE0/edit#gid=0

** Open questions
- Weiler data doesn't distinguish between IT, PT, CT right?
- Anderson complements data with postsyn IT vs PT in L5
- How to enter data? using bins/layers/yfrac funcs? combination?
- Missing conn params (specially for Inh) ?
- Conn weight vs prob conn?

** densities
[ben.suter] There's relative density and absolute density
18:36 [ben.suter] In L5B I'd go with 50/50 IT/PT
18:36 [ben.suter] In L2/3, L4, L5A 100% IT
18:36 [ben.suter] In L6, 50/50 IT/CT

As for interneurons, people often say 20% INT, 80% PYR. But I think there are better numbers out there.

Kumar and Ohana; that's a L6 paper looking at CT and CC (IT) I believe
Kumar, P. & Ohana, O. Inter- and intralaminar subcircuits of excitatory and inhibitory neurons in layer 6a of the rat barrel
cortex. Journal of neurophysiology 100, 1909-1922 (2008). [checked but has no density info]

Kleinfeld has a paper where they measured density of neurons in mouse cortex

[ben.suter] Marcel Oberlaender has a lot of great papers on rat barrel cortex
18:41 [ben.suter] But might be difficult to translate

Anyhow, it would be possible to do cell counting.  If done comprehensively, it would be useful for sure.  18:45 [ben.suter]
It'd be mainly to look at CSP, IT, CT, PV, LTS # and density as a function of yfrac, and as a percent of total neurons. In a
particular area of the mouse brain.  18:45 [ben.suter] I think it would be a great reference.  18:46 [ben.suter] It's a
matter of whether Gordon thinks worthwhile and others in lab available to help with this.

yes that sounds useful, and density as func of yfrac would be an interesting feature to add

@layer to layer ratios: My advice for that is to start with uniform density from L2 to L6, and just work with proportions. So
to start, 20 of neurons in every layer are interneurons (except in L4 where I'm not sure).  18:49 [ben.suter] And 80% are
pyramidal. And among those 80%, in L5B it's split 50/50 IT/PT, in L6 it's 50/50 IT/CT, and L2/3 and L4 it's all IT.

 If  you remind me, I can do some digging about density references (but please search your chat / notebook too, maybe
 Kleinfeld keyword will help). But I'd go ahead with uniform neuronal density for now.

** conn chat
so conn: 1) Weiler data doesn't distinguish between IT, PT, CT right?
neurosim-isb@im.partych.at
18:51 [ben.suter] Correct.
18:51 [ben.suter] In theory, should be unbiased sampling
18:51 [ben.suter] BTW this is the Kleinfeld paper:
18:51 [ben.suter] Tsai, P. S. et al. Correlations of neuronal and microvascular densities in murine cortex revealed by direct
counting and colocalization of nuclei and vessels. The Journal of Neuroscience 29, 14553-14570 (2009).

ok so just assume same values for eg. both CT and IT in layer 6?
neurosim-isb@im.partych.at
18:52 [ben.suter] Yes correct

[ben.suter] The only interlaminar cell-type specificity we know about is Anderson&Sheets for L2/3->L5
18:53 [ben.suter] Hmm, gotta check Taro's paper, he may have some stuff between L5A and L5B

[ben.suter] Kiritani et al, Figure 4: looks at relative strength of connections between L5A and L5B:
18:55 [ben.suter] L5B-PT to L5B-PT compared to L5B-PT to L5A-IT
18:56 [ben.suter] L5B-IT to L5B-PT compared to L5B-IT to L5A-IT

** email to Ben with conn q's
1) To combine weiler+anderson+kiritani conn data, how can we normalize values from these datasets so they make sense
   together? eg. in your spreadsheet each dataset has different min,max values. Maybe just renormalize each dataset to be
   between 0 and 1?

2) To specify the model conns based on experimental data I see 3 (not exclusive) ways of doing it:
a) using bin conn matrix (10x10 or 16x16) — the model allows to specify conns for different yfrac ranges,
b) based on layers (similar to how george did it), converting the bin conn matrix to layers,
c) using a function of yfrac (eg. might want to do this for specific conns, such as L2/3->L5B)

I'd say option a) would be the more 'accurate' way of doing it, perhaps with c) for some of those conns, what do you think?

3) For interneuron conn, I have Apicella et al 2012 as a ref for E->I conns; any refs you can think of for I->E and I->I
   conns? (prev model values based on a rat S1 model developed by cliff)

4) Do you have any data to help constrain the probability vs weight of conn? The approach of prev model was generally to use
   Weiler data to decide probabilty of conn, while keeping weights relatively constant.
** another email to Ben with conn q's
Been looking at how to combine the Weiler + Anderson conn data. Seems it would be useful to have both as conn matrix with
same granularity (eg. 16 x 16 or higher), so makes it easier to combine the data. I was re-reading some of the chats and
seems that is what we agreed on:

[ben.suter] So, where this leaves us: [ben.suter] Is that I think I need to reanalyze these data sets, so that we end up with
a connectivity matrix for each data set (there will be three to start: unlabeled, csp, cstr), where all matrices are in the
same coordinate system.  [ben.suter] And before I do that, I need to solve a sticky problem of how to set up the coordinate
system so that we can use it for the sCRACM data sets as well, and in general for connectivity.  [ben.suter] Probably: 28
bins, 50 um each, with the center of the 1st row at y=25 um, or yf=0.0357

[ben.suter] You could start with 16 bins, and interp the 10 up to 16 so they m atch
[ben.suter] But that seems silly when we have the underlying data for both, at higher resolution.

Since probably won't have time to do that for SFN poster, do you have any other suggestions as to how to combine the conn
data for this initial version of the model? I could just use the 9x9 Weiler data, and try to approx. rebin the Anderson data
to plug it in (although would lose some 'resolution'). See also related questions below.

** response from Ben
Been looking at how to combine the Weiler + Anderson conn data. Seems it
See below for an immediate solution.

Since probably won't have time to do that for SFN poster, do you have any
other suggestions as to how to combine the conn data for this initial
version of the model? I could just use the 9x9 Weiler data, and try to
approx. rebin the Anderson data to plug it in (although would lose some
'resolution'). See also related questions below.
Agree about time, see solutions below.

1) To combine weiler+anderson+kiritani conn data, how can we normalize
values from these datasets so they make sense together? eg. in your
spreadsheet each dataset has different min,max values. Maybe just
renormalize each dataset to be between 0 and 1?

In theory the Glu-LSPS data is all calibrated, so the absolute
magnitude should be the same when comparing same pre and post yfrac in
Weiler and A&S papers, and can be tied back to a calibrated # of
presynaptic neurons (~200 as I recall). However, it seems that the
Weiler connectivity matrix has been normalized (max = 1). I hadn't
realized this difference before, thanks for bringing it up.

In the interest of time, I'll make a quick suggestion for how to
proceed (but need to revisit this). The general idea is that L5
contained the strongest inputs in Weiler (=1 when normalized). Within
L5B, the A&S datasets show the CSP getting the max input - so we
should identify the max value in the A&S matrices with the max value
in the Weiler matrix. As follows:

1. Truncate the negative values at 0 for Weiler, so it ranges from 0 to 1.
2. For postsynaptic IT neurons in layers 2, 3, 4, use the Weiler rows
1-3 (yfrac centers 0.15, 0.25, 0.35 respectively).
3. For postsynaptic IT and CT neurons in layer 6, use the Weiler rows
8-9 (yfrac centers 0.85, 0.95 respectively).

4. For the A&S CSP and CSTR matrix, normalize by dividing by the max
across both CSP and CSTR datasets (18.26 in the CSP), then truncate
the negative values at 0. So the CSP should range from 0 to 1, and the
CSTR from 0 to <1.
5. For postsynaptic PT neurons in layer 5B, use the A&S CSP normalized
matrix (6 rows; yfrac centers from 0.47 to 0.78, see spreadsheet).
6. For postynaptic IT neurons in layers 5A and 5B, use the A&S CSTR
normalized matrix (7 rows; 2 rows in L5A, yfrac centers 0.34 and 0.41;
5 rows in L5B, yfrac centers 0.47 to 0.72). For ITs in the deepest
part of L5B (yfrac center 0.78), assume input is zero.

2) To specify the model conns based on experimental data I see 3 (not
exclusive) ways of doing it:
a) using bin conn matrix (10x10 or 16x16) — the model allows to specify
conns for different yfrac ranges,
b) based on layers (similar to how george did it), converting the bin conn
matrix to layers,
c) using a function of yfrac (eg. might want to do this for specific conns,
such as L2/3->L5B)

I'd say option a) would be the more 'accurate' way of doing it, perhaps with
c) for some of those conns, what do you think?

I agree that all of these three ways are useful, although (2b) perhaps
less than the others. While other sources may sometimes report
experimental results "by layer", we should be able to convert their
data to our yfrac values for layer boundaries, and so should be able
to specify the connectivity within our model in terms of yfrac (binned
or distribution or function).

There is a 4th way, similar to (2a), but slightly different: using 50
bins from 0 to 1350 um (27 rows), as indicated in my "Coordinate
systems" spreadsheet - and this system has a rough correspondance of
layer to bin. I think this is the preferred way whenever the data fits
into this system. Sometimes binning at this level will be too noisy,
so being able to use original source (e.g. Weiler 9x9 matrix) may
remain useful.

3) For interneuron conn, I have Apicella et al 2012 as a ref for E->I conns;
any refs you can think of for I->E and I->I conns? (prev model values based
on a rat S1 model developed by cliff)

I haven't had time to dig into this further. As I mentioned, for
starters we can assume 80% pyr, 20% interneuron in all layers.
Initially, let's assume that they get excitatory interlaminar input
same as their neighbouring pyramidal neurons. In L5, I'd use the
postsynaptic IT values for the postsynaptic interneurons.

Next phase is to use Apicella data to modify these initial E->I
values. Again as an approximation it should be roughly: inter-laminar
excitatory input to interneurons in L5 should go only to LTS
interneurons (use same connectivity values as if these were
postsynaptic L5 IT pyramidals) and not to FS. Intra-laminar excitatory
input to interneurons in L5 should go only to FS (use the same
connectivity values as if these were postsynaptic L5 IT pyramidals),
and not to LTS.

For I->E (and I->I) values, assume that they are strictly local (i.e.
~ intra-laminar; no interlaminar inteurneuron connections, to start).
Here I think we should assume that every interneuron contacts any
other nearby neuron (pyr or interneuron) without regard for
postsynaptic cell type, in a distance-dependent manner. This will
require some length constant, there must be some data on this
somewhere - if you can't find anything, let me know and I'll venture
an educated guess. Strength: I'm really not sure how strong these
inhibitory connections should be, relative to E->E/I connections. I
think in general when we see disynaptic inhibition (e.g. stim
longrange excitatory inputs, which directly excite M1 pyramidals, but
also directly excite M1 interneurons, which then inhibit the M1
pyramidals disynaptically), the inhibition is much stronger than the
excitation. Off the top of my head, I'm not sure how to properly
compare these - it depends on Vm at the time of the synaptic input,
because of driving force. I suppose therefore the particular
implementation of the synapse in the model matters too. Let's talk
about this some more soon?

For I->I values, I think can treat same as what I wrote here for I->E
values. But there likely are celltype-specific rules among interneuron
classes - I just don't know what we know (probably not much) - future
work.

4) Do you have any data to help constrain the probability vs weight of conn?
The approach of prev model was generally to use Weiler data to decide
probabilty of conn, while keeping weights relatively constant.

In Weiler, for each stimulus, ~100 neurons each fired ~1 AP.

The somatic response for unitary local connections between L5
pyramidal neurons has been measured (in Taro's paper, for example; and
in Markram/Sakmann papers for rat). Most paired papers do
current-clamp, not voltage-clamp. (like we used in LSPS). Taro's paper
doesn't report the distribution of unitary somatic EPSPs, but I'm
pretty sure Taro measured that - I can at some point try to find his
data, or I/you can look at his raw traces to measure the EPSP
amplitude (and time course). I think I may have done this already for
my synaptic NEURON model, not sure at the moment. I did a quick
measurement of an example trace (Fig. 6C), where the unitary EPSP
CSP->CSP had an amplitude of 0.52 mV. There are other example traces
given in Fig. 7, but the scalebar is not calibrated there. We have
these data, it's just a matter of finding/analyzing them.

The point is that we should be able to come up with a
range/mean/variance of unitary EPSP size for E->E connections within
L5. And we know that the max unitary connections possible is 100 (for
the LSPS mapping conditions). So the constraints would be min=0,
max=100 presynaptic neurons, and min/max unitary EPSP taken from
Taro's L5->L5 data (or better would be a different source for L2/3->L5
data, or at least another study showing that L2/3->L5 unitary
connections have a similar strength as L5->L5 connections, even if in
rat).


A different, strong approach, combining a lot of experimental data and modeling:
Recall that I have a dataset mapping out the subcellular location of
synapses on CSP neurons, originating from pyramidal neurons in L2/3
(aka L2/3->CSP sCRACM data set). These maps are obtained under similar
conditions as the Glutamate LSPS maps (room temperature, NMDA-blocked
with CPP, somatic voltage-clamp). So we could take my full CSP model,
add in the L2/3 synapses in the appropriate spatial distribution
obtained from sCRACM (I've already done this in NEURON), and then
simulate Glutamate LSPS in NEURON, while varying the probability and
strength of unitary L2/3->CSP connections, subject to the max of 100
presynaptic neurons. Then we compare the simulated somatic responses
to the ones obtained experimentally in Glu LSPS maps, which would tell
us which combinations of probability and strength are consistent with
the experimental results. If needed, we can constrain the range of
unitary strength based on what is generally known about cortical
unitary EPSPs (may require a conversion to 34C and current-clamp in
the model). The output of this effort would be an estimate of the
convergence and unitary strength of L2/3->CSP pathway. Note that this
uses the CSP model in two ways: first, to estimate the relative
spatial density of L2/3->CSP synapses by simulating sCRACM and
optimizing to experiment; second, to estimate the L2/3->CSP connection
probability and unitary strength by simulating Glu-LSPS and optimizing
to experiment.

I think it's clear (based on having tried to do 1/2 of this proposed
approach) that this is a very large effort, and not one that can be
accomplished anytime soon. But I'd urge you to keep this in mind for
later stages of the U01, for a few reasons: it demonstrates the
usefulness of subcellular models and experiments so fits U01 well; it
could generate estimates of connectivity that would be very difficult
/ time-consuming to obtain experimentally (if even currently
possible); it represents a real productive use of the CSP membrane
model; also, it does not require a full spiking CSP model, because the
CSP are voltage-clamped, NMDAR are blocked, and we're at room
temperature, and the inputs are subthreshold. Most importantly: I've
already done a big chunk of this - made a suitable model,
reconstructed multiple CSP for which I also have the sCRACM data, and
implemented a NEURON model that distributes synapses according to
experimental sCRACM grids and simulates the sCRACM mapping experiment
in silico. The Glu-LSPS simulation would be very similar to the sCRACM
simulation, basically identical. I'd actually be very excited to work
on this, since it would pull together a lot of work I've already sunk
a *ton* of time into. Perhaps we can revisit somewhere down the road
if/when I have some downtime experimentally, or as a short sabbatical
or such.

------

I redid the analysis from (Weiler et al 2008), starting from the
average map for each of the 102 neurons, and was able to reproduce the
connectivity matrix seen in the paper (and on ModelDB, and in my
spreadsheet). However now it is no longer normalized - the values are
in pA, as is the case for the A&S CSP/CSTR data sets.

I plotted all three Glu-LSPS connectivity matrices on a single figure
for comparison. They share the same yfrac scale and alignment, and
also the same intensity scale.

Note that the L2/3->L5 pathway is ~2x stronger in the Weiler matrix
than in the A&S CSP (and CSTR) matrix, even though the relative
structure remains consistent. I don't have a good explanation for
this, yet - I would have expected similar values in both cases. It's
possible that the A&S analysis was done differently than I understand,
but I can't think of any particular difference that would make sense.
It's possible that this ~2x difference reflects the experimenters.
I'll bring it up with Gordon and let you know if it's an issue. In any
case, all the more reason to go with the approach I suggested above
(use Weiler as standard, normalize strongest pixel in CSP and CSTR to
1).

** New questions
- only use length-dependence for I->E and I->I? not for E->E? (guess not because have precise data)
** Papers on cell and synapse densities
*** Kleinfield et al 2011 (J Neusci) {Klei11}:
density of 6 synapses subtypes (syns/um^3) as a function of cortical depth for mouse S1: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_130640.png][fig]] (fig 4d)

neuronal density (10^3/mm^3) as a function of cortical depth for mouse S1: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_131102.png][fig]] (fig 6c)

*** Tsai et al 2009 (J Neusci) {Tsai09}:
neuron density (10^5/mm^3) as a func of cortical depth for mouse agranular cortex (frontal cx): [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_131917.png][fig]] (fig 10a)
[Bregma +1mm ~= M2/M1 border
[higher for ~L2/3 and L6?]

neuron density (10^5/mm^3) along pia (from midline) for mouse cortex: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_132721.png][fig]] (fig 11b)

compendium of literature results on neuron densities (10^5/mm^3) for mouse cortex (avg=1.2): [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_133755.png][fig]]

*** Herculano-Houzel et al 2013 (Front Neuroanat) {Herc13}:
Distribution of neurons across cortical areas in the mouse brain: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_134555.png][fig]] (Table 1)

*** Schuz et al 89 (J Comp Neur) {Schu89}:
neuron density for area 6 (M2) of 3 mice: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_140038.png][fig]] (fig 2,3)
[higher in layer 2, 4 and 6]
synapse densities also available

*** Meng et al 2014
Automatic detection and quantitative analysis of cells in the mouse primary motor cortex

cell (neuron?) density as function of yfrac for mouse M1: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_144017.png][fig]] (fig 5)
[higher in L5?]

*** Potjans & Diesmann 2014 (Cereb Cortex):
Cortical model populations sizes: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_141748.png][fig]] (table)
[higher in L2/3 and 6]

*** DeFelipe et al 2002 (J Comp Neurocyt); DeFelipe 2011 (Front Neuroanat)
Neuron density per layer in mouse S1 (barrel cortex): [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20150928_142950.png][fig]] (fig 5)

*** Markram et al 2015
neuron density per layer rat S1 (10^3 neurons / mm^3)
L1: 14.2
L2: 164.6
L3: 83.8
L4: 177.3
L5: 83.9
L6: 131.5

avg: 108.7

** Papers on connectivity
*** Petrof et al 2015 (J Neusci) {Petr15}:
mouse S1 -> M1 (L2/3, L5, L6)

*** Lefort et al Petersen 2009 (Neuron {Lefo09}
Excitatory Synaptic Connectivity and uEPSP Amplitudes in the Mouse C2 Barrel Column
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151005_231914.png][fig]]
*** Thomson & Lamy 2007 {Thom07}
*** Pfeffer et al 2014 {Pfef13}
- Parvalbumin expressing interneurons strongly inhibit one another but, surprisingly, provide little inhibition to other
  populations.
- In contrast, somatostatin expressing interneurons avoid inhibiting one another, yet strongly inhibit all other populations.

*** Apicella 2011
E->I, I->E (L2/3 + L5A/B) ; FS vs LTS
*** Katzel 2011
I->E all layers M1 mouse
relative densities of FS vs LTS !
*** Markram 2015
pcon and icon for mouse s1 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151207_141140.png][fig]]
** Combining Weiler + Anderson conn matrices

1. Truncate the negative values at 0 for Weiler, so it ranges from 0 to 1.
2. For postsynaptic IT neurons in layers 2, 3, 4, use the Weiler rows
1-3 (yfrac centers 0.15, 0.25, 0.35 respectively).
3. For postsynaptic IT and CT neurons in layer 6, use the Weiler rows
8-9 (yfrac centers 0.85, 0.95 respectively).
4. For the A&S CSP and CSTR matrix, normalize by dividing by the max
across both CSP and CSTR datasets (18.26 in the CSP), then truncate
the negative values at 0. So the CSP should range from 0 to 1, and the
CSTR from 0 to <1.
5. For postsynaptic PT neurons in layer 5B, use the A&S CSP normalized
matrix (6 rows; yfrac centers from 0.47 to 0.78, see spreadsheet).
6. For postynaptic IT neurons in layers 5A and 5B, use the A&S CSTR
normalized matrix (7 rows; 2 rows in L5A, yfrac centers 0.34 and 0.41;
5 rows in L5B, yfrac centers 0.47 to 0.72). For ITs in the deepest
part of L5B (yfrac center 0.78), assume input is zero.

** Email from Ben with more details on conn
Good, I'm glad my answer was helpful. I spoke with Gordon some more
today about the Glu-LSPS connectivity data sets. Two things to
discuss: normalization, and diagonals. The normalization approach I
described last night is reasonable. But here's a variant on that,
which may be better.

The question is whether or not it makes sense to normalize to the peak
input pixel, across the data sets? I explained above why it makes
sense, but there are limitations, and I think I found a better
approach. The idea is to do everything as above, but instead of taking
the A&S CSP max value to be same as Weiler max value, normalize
differently. If you look at the non-peak values of the matrix (for
example between deep layers), there seems to be a pretty good
correspondence already without rescaling. So I see two approaches:

(A) Don't normalize. The data are from calibrated experiments and
shouldn't require normalization, in theory.

(B) Normalize, but not to peak pixel. I'm concerned that normalizing
to the peak (a single pixel) could be problematic because noisy. I'm
not yet suggesting a specific normalization approach - I think this is
more up your alley, and I'm hoping you can make some suggestions?
Maybe normalize to the total input across the yfrac ranges that are
common to both (Weiler and A&S datasets)? So average theA&S  CSP and
CSTR overlapping roles, and then find overlap between that A&S combo
and the Weiler L5 data, and scale the A&S to achieve same total /
average input. The A&S CSP and CSTR data sets should remain on the
same scale as each other in any case, since they were acquired in
parallel.

I currently prefer approach (A), but if you can recommend a solid
approach for (B), let's discuss?

Diagonals:
The Glu-LSPS technique leaves "blind spots" for within-layer
connections. This is because when you flash the laser too close to the
postsynaptic neuron, the glutamate directly activates the postsynaptic
neuron's GluRs, in addition to causing spikes in presynaptic neurons:
we call these "direct inputs" as opposed to "synaptic inputs". Direct
inputs are distinguishable because their onset is faster (within ~7
ms) than synaptic inputs (but this detection criterion is not
foolproof). The first step in analyzing mapping data is to identify
pixels where direct inputs occurred, and these pixels are excluded
from further analysis (they are set to NaN): essentially, we can't
estimate the strength of synaptic input for those pixels, due to
contamination by direct inputs. Picture a bunch of black pixels
punched out of the map, corresponding to the extent of the
postsynaptic dendritic arbor. So why aren't there any black spots /
NaNs in the connectivity matrix? Because each matrix pixel corresponds
to an average over ~10 postsynaptic neurons, spread out over a yfrac
range of ~0.1, so when one map has a NaN pixel at a certain location,
there's a chance that >=1 of the other 9 maps does not. But even so,
this all means that (a) along the diagonal of the matrix each pixel is
perhaps noisier, and (b) we're almost certainly underestimating the
strength of input along the diagonal (between nearby neurons).

For nearby neurons (diagonal of the connectivity matrix), a better
technique is paired recordings: and for L5, we have those, courtesy of
Taro. So ideally we would use paired recording data for connections
along the diagonal (aka intra-laminar), at least where it's available.
Taro's data has connection probability, and I think we can determine
unitary strength even though it's not reported in his paper. For other
layers, we'll need to turn to the literature, which unfortunately is
often from rat. In that regard, I'd suggest we compare Taro's L5 data
to rat L5 data from other labs, and if the results (Pcon, Wuni) are
similar, then good - if not, it may suggest a rat->mouse scaling
factor. In any case, Alex Thompson has a review with useful data for
L6 pairs (including putative IT and CT classification). And within
L2/3 there should be lots (Feldmeyer, Sakmann, Petersen probably).
Some may be mouse, most in rat. Most will not be in M1.

What about interlaminar pairs? There are studies looking at L2/3->L5
with paired recordings (incl. I think Alex Thompson; but also our
collaborator Thanos in auditory cortex). Perhaps useful to look at
what they found (Pcon, Wuni), which we could use to compare or even
calibrate our Glu-LSPS maps further. At a minimum, I think we should
be aware of what those other data sets predict (approximate Pcon,
approximate Wuni), so that if our connectivity doesn't match, we know
to reexamine or at least mention in discussion, to head off reviewer
concerns. But best case, these data sets would help us tease apart
(Pcon, Wuni) from Wlsps.

Finally, as Gordon said, if we need to know (Pcon, Wuni) for L2/3->L5,
then we can do those experiments. They are time-consuming.

I asked Naoki about L6, and he confirms that Thompson review (2007) is
useful. It has a massive table. The problem is that I had a quick look
and it seems that the data there come from very small # of recorded
pairs - and some of the numbers just don't work out for me. It's a
review, so it may still point us towards a relevant paper for IT/CT
paired data in L6. A better resource is a Petersen group Neuron paper
by Lefort et al: they recorded pairs (using 8 electrodes, I think) in
mouse barrel cortex. They give PCon and Wuni (mean, std, median,
range) as a matrix between all layers. Because it's barrel, we have to
be careful what we use. I think it's most useful for the diagonals
(intra-laminar), because my gut tells me that intralaminar
connectivity may be more conserved across areas than interlaminar
connectivity is. One thing worth doing here: compare the Lefort paired
recording results to those obtained by Glu-LSPS in barrel cortex
(Shepherd & Svoboda, 2005). Those studies were both done in mouse
barrel cortex, so it would give us a way to compare/calibrate the two
methods (pairs, LSPS). Gordon's barrel cortex paper didn't do the full
connectivity matrix analysis, but maybe he did it later / could do it
now. I have a feeling this is something he would not prioritize
highly, but I can ask gently later in the week.

Important point: when you look at e.g. the Petersen data, you see that
the highest PCon is always along the diagonal, i.e. for intra-laminar
connectivity. This makes sense, considering the axons necessarily must
pass through a lot of dendrites as they leave the home layer, i.e.
nearby neurons connect more. In contrast, in the Weiler and A&S
matrices, the diagonal is pretty weak. More evidence that the Glu-LSPS
matrix probably underestimates pixels on the diagonal.

In summary:

1. Use A&S for L5 postsynaptic neurons, and Weiler for other layers;
do not normalize.

2. Plan to replace connectivity data along the diagonal, from other
sources, in the near future.
2.a For L5->L5, replace the A&S connectivity (diagonals) with Taro's
data (pairs), once I/you have time to extract the unitary strength
(Pcon is already available in paper).
2.b. For L6->L6, replace the Weiler connectivity (diagonals) using
Naoki's JNeurosci findings (IT/CT) and other sources (Thompson;
Lefort).
2.c. For L2/3, L4, consider replacing A&S connectivity (diagonals)
with non-M1 data (pairs) from Lefort (or others).

3. Constrain (Pcon, Wuni) inter-laminar (off-diagonal) connectivity
using other sources (pairs; from Lefort, Thompson, Sakmann, Feldmeyer,
etc.).

4. Modify inter-laminar connectivity for cell-type specificity. Taro
and Naoki's papers provide some information for doing this, there may
be other papers too. This is stuff like L6-CT <-> L5-PT connectivity,
and such.

** Meeting with Ben - notes
- need to do Do L5->L5 diagonal:
2.a For L5->L5, replace the A&S connectivity (diagonals) with Taro's
data (pairs), once I/you have time to extract the unitary strength
(Pcon is already available in paper).

- kawaguchi paper has useful data for step 2
- taro has dynamics (facilitation, depression, etc for future)

*** separating weight+pconn

- pick unitary syn strength uniform everywhere; and modify pconn based on data (0.5mv measure at soma for unitary conn);
  treat LSPS glu map as pconn; modify data where we have additional data
- interesting to see - glu data calibrated 100 presyn spikes (with V-clamp), recording at soma and see this current -
  estimate how many presyn cells are required to generate that; eg syn at 150um from soma with given strength, how many units
  need to be active to give 25pA at the soma;
- strongest input pathway = very strong convergence (30% of presyn neurons are active)
- in barrel cortex there is no strong pathway - so can't do direct connection
- conn prob in cx seem to be 5-10% at most (3 or 7); within a layer 10-20% higher (in general); never interlaminar of 50%;
  has to end up with reasonable values for all layers;
- can try diff approaches: keep constant weight, or reasonable probabilities, vary both systematically to explore within
  reasonable constraints
- if pick unitary strength 1mV (current clamp in soma), to cover spread of strengths in weiler matrix would require 100% conn
  prob - doesn't work, so need to adapt weight; combine with range of reasonable weights (tight contraint)
- Take into account cell density and horizontal spread in model - pcon is in reference to 100um wdith
- use Lefort in future

** Gordon suggests first experiment: reproduct Fig 10,11 Sheets paper
- IT and PT with without Ih
- Ih high pass filter

** Combining Weiler + Anderson with Kiritani (for diagonals)
- Weiler,2008 + Anderson,2010 in raw pA (V-clamp) values obtained from Glu-LSPS (100 presyn cells/spikes)
- Kiritani have prob of conn (p_con) and unitary conn strength (i_con in mV) matrices based on paired recordings
- Weiler+Anderson diagonals wrong (underestimates) due to Glu-LSPS blind spots

- Ben: when he's comparing IT and PT, both are in L5B specifically.
Except when he then looks at L5A vs L5B ITs later.

Assume that the neurons in pairs were all within ~200 um of each other horizontally, and at roughly same cortical depth.
And hence roughly same layer. Definitely in same "bin" (50 or 100 um) radially.

So he patched CSP in L5B, CSTR in L5B, and CSTR in L5A (Fig. 4). And stimulated either CSP(L5B) or CSTR(L5A+B).

"In the preceding experiments, we recorded from corticospinal and corticostriatal neurons located side by side in layer 5B."

- Need to find comparable connection between Kiritani and Weiler/Anderson (so can scale values), candidates are:
-- IT (L5A+L5B) -> IT (L5A) == IT (L5A+L5B) -> IT (L5A) (pcon=0.111)
-- IT (L5A+L5B) -> PT (L5B) (pcon=0.209)
-- PT (L5B) -> PT (L5B) (pcon=0.039)
-- PT (L5B) -> IT (L5A+L5B) (pcon=0)

- Given layer boundaries:
Layer Boundaries (yfrac)	Feature
0	pia
0.12	L1/2 border
0.31	L3/4 border
0.42	L4/5A border
0.52	L5A/L5B border
0.77	L5B/L6 border
1	white matter

- The equivalent to this 3 pathways in the Weiler/Anderson matrix would be:
-- Kiritani IT (L5A+L5B) -> IT (L5A+L5B) (0.111):
--- Anderson 5x5 matrix (bin centers 0.46875-0.71875) mean = 2.33  std = 0.86 ==  IT+PT (L5A+L5B) -> IT (L5A+L5B)
--- Not the same: Kiritani presyn is just IT; Anderson presyn is IT+PT; but because PT->IT = 0, then approx same
--- Conclusion: comparable

-- Kiritani IT (L5A+L5B) -> PT (L5B) (0.209):
A)
--- Anderson 5x4 matrix (bins 0.468-0.718; 0.53-0.718) mean = 3.3 std = 0.98 == IT+PT (L5A+L5B) -> PT (L5B)
--- Not the same: Kiritani presyn is just IT; Anderson presyn is IT+PT; PT->PT (L5B) != 0, so not same
--- Conclusion: NOT comparable
B)
--- Anderson 1x5 matrix (bins 0.468; 0.53-0.718) mean = 2.19 std = 0.57 == IT (L5A) -> PT (L5B)
--- Not the same: Kiritani presyn is IT L5A+L5B; Anderson presyn is only L5A
--- But based on Kiritani: IT L5A->PT == IT L5B->PT
--- Conclusion: comparable

-- Kiritani PT (L5B) -> PT (L5B) (0.039)
--- Anderson 4x4 matrix (bins 0.53-0.718; 0.53-0.718) mean = 2.19 std = 0.57 == IT (L5A) -> PT (L5B)
--- Not the same: Kiritani presyn is only PT L5B; Anderson presyn is IT+PT L5B
--- Conclusion: NOT comparable

- IT L5 -> IT L5 (diagonal):
-- Kiritani: 0.111
-- Anderson: 2.33 (understimated)

- IT L5A -> PT L5B:
-- Kiritani: 0.209
-- Anderson: 2.19 (correct estimate)

- Data actually suggests overestimated!

** Lefort layer boundaries
- Measure from fig in paper
- Varies depending on fig
- Supplementary fig shows 2 quite different distributions of layers
** Combining Weiler + Anderson with Lefort (to constrain p_con vs i_con)
- Use IT L3->IT L5A as reference (no L3->PT L5A - Anderson,2010)
- Use IT L3->PT L5B as reference (no L3->IT L5B - Anderson,2010)

- Lefort IT L3->IT L5A: pcon (0.057) * icon (930) = Icon (53.5)
- Anderson IT L3->IT L5A: (bins 2x1 0.21825-0.2812; 0.468) = (4.5533+2.9227)/2 = 3.73

- Lefort IT L3->PT L5B: pcon (0.122) * icon (1010) = Icon (123.2)
- Anderson IT L3->PT L5B:  (bins 2x1 0.21825-0.2812; 0.53125-0.59375) = (18.3+10.4+10.3+5.8)/4 = 11.17

- Lefort ratio = 123.2/53.5 = 2.3
- Anderson ratio = 11.17/3.73 = 2.99

- Ratios match which suggests can use pcon vs icon data from Lefort

** Updating diagonals based on Lefort
- Update diagonal values based on Lefort I_con, after normalizing all to max non-diag I_con (L3->L5B)
- For bins between 2 layers (eg. L4/L5A) use average value (eg.(L4+L5A)/2)
- Need to update also matrix values around diagonal? eg 3x3 bins of L5B? or just pure diagonal?

** Generating 1st iteration of exc conn values
- Set all weights (unitary conn strength, i_con) to 0.5 (or 1)
- Set all probs of conn (p_con) to normalized Weiler+Anderson raw matrix (normalized based on max=18.26)
- Maybe normalize so that max = 0.3 or some p_con value obtained from Lefort! (max non-diag value = 0.122)
-- Assume: Weiler+Anderson 18.26 == Lefort 0.122 (p_con)

- Alternatively normalize based on I_con:
- Lefort max non-diag ICon is L3->L5B = 0.123
- Weiler+Anderson max non-diag ICon (equivalent) is L2/3->L5A/B = 18.26
-- Assume: Weiler+Anderson 18.26 == Lefort 0.123 (Icon)

- norm factor = 0.123/18.26

- To constrain p_con vs i_con used 2 approaches after scaling Weiler+Anderson to Lefort max non-diag I_con:
-- fix the i_con based on Lefort data, and calculate p_con = I_con/i_con (this yielded better results)
-- fix the p_con based on Lefort data, and calculate i_con = I_con/i_con
** Inh connectivity

- (E->I) As I mentioned, for starters we can assume 80% pyr, 20% interneuron in all layers. Initially, let's assume that they get
  excitatory interlaminar input same as their neighbouring pyramidal neurons. In L5, I'd use the postsynaptic IT values for
  the postsynaptic interneurons.

- (E->I) Next phase is to use Apicella data to modify these initial E->I values. Again as an approximation it should be roughly:
  inter-laminar excitatory input to interneurons in L5 should go only to LTS interneurons (use same connectivity values as if
  these were postsynaptic L5 IT pyramidals) and not to FS. Intra-laminar excitatory input to interneurons in L5 should go
  only to FS (use the same connectivity values as if these were postsynaptic L5 IT pyramidals), and not to LTS.

- (E->I) From Apicella: aggregate output from the activated neurons, reflecting both probabilities and amplitudes of the underlying
  unitary connections (I_con).

- (I->E and I->I) values, assume that they are strictly local (i.e.~ intra-laminar; no interlaminar inteurneuron
  connections, to start).  Here I think we should assume that every interneuron contacts any other nearby neuron (pyr or
  interneuron) without regard for postsynaptic cell type, in a distance-dependent manner. This will require some length
  constant, there must be some data on this somewhere - if you can't find anything, let me know and I'll venture an educated
  guess.

- (Strength of I->E and I->I) I'm really not sure how strong these inhibitory connections should be, relative to E->E/I
  connections. I think in general when we see disynaptic inhibition(e.g. stim longrange excitatory inputs, which directly
  excite M1 pyramidals, but also directly excite M1 interneurons, which then inhibit the M1 pyramidals disynaptically), the
  inhibition is much stronger than the excitation. Off the top of my head, I'm not sure how to properly compare these - it
  depends on Vm at the time of the synaptic input, because of driving force. I suppose therefore the particular
  implementation of the synapse in the model matters too. Let's talk about this some more soon?

- (Strength of I->I), I think can treat same as what I wrote here for I->E values. But there likely are celltype-specific rules
  among interneuron classes - I just don't know what we know (probably not much) - future work.

- (I->E) Katzel 11 Nat neu has source conn densities/distribution across layers for I->E (+ relative densities of cell types)
-- Katzel: L2/3 post = 76.5% (L2/3), 16.5% (L5), 0% (L6)
           L5 post = 1.5% (L2/3), 87% (L5), 10% (L6)
	   L6 post = 0.3% (L2/3), 2.2% (L5), 97.5% (L6)
-- not strictly local, but can assume local (only intralaminar) initially


- E->I steps:
1) Simplified into L2/3, L5 and L6, and LTS vs FS (since Apicella's findings are grouped this way)
2) Initial p_con and i_con matrices taken from final E->E matrix (Weiler+Anderson raw, scaled+diagonals from Lefort); by
   averaging over corresponding bins
3a) For LTS: i_con and p_con L2/3 E -> L5A/B I used MAX instead of AVERAGE; i_con L5A/B E -> L5A/B I used MIN instead of
   AVERAGE
3b) For FS: i_con and p_con L5A/B E -> L5A/B I used MAX instead of AVERAGE; i_con L2/3 E -> L5A/B I used MIN instead of
   AVERAGE
rationale: increase the strength of pathways suggested by Apicella using p_con and i_con values consistent with E->E matrix

** Latencies/delay chat with Ben
[ben.suter] My initial assumption is that the delay between t_presynaptic_spike_at_axon_initial_segment and t_postsynaptic_EPSP_rise_at_soma is dominated by transmission at synapse and postsynaptic dendritic integration, and that the transmission time from presynaptic AIS to presynaptic axon terminal is short in comparison
[ben.suter] It's been a while since I knew/read about the actual numbers here.
[ben.suter] I should at least check Taro's pair data to figure out what the total delay is between neighbors in L5B
[ben.suter] If my assumption is correct, then the delay for local connections would have a fixed component (at synapse) and a variable component (depending on dendritic synapse location), but the physical distance between pre- and post-synaptic somata would not necessarily be a major factor.
Salvador Dura
hmm very interesting
we should definitely include all this stuff, don't think I've seen that distinction made in other models (maybe I missed)
neurosim-isb@im.partych.at
[ben.suter] I think unmyelinated AP speed is on the order of 1-10 m/s (I'll have to look for a more precise estimate in cortex), which corresponds to a soma->terminal delay of ~0.01 to 1 ms, if we roughly assume an axon length of 100um to 1mm.
[ben.suter] If you take two neighboring CSP in L5B, their soma will be at a depth of ~850 um on average.
Salvador Dura
right, so whats the approx. time for transmission at synapse and postsynaptic dendritic integration?
neurosim-isb@im.partych.at
[ben.suter] If they are connected, the axon will first dive down towards white matter a few hundred micrometers, then branch off from the main axon and take a turn up towards pia again. If it makes a synapse onto the neighbour's basal dendrites, the axonal distance would be maybe ~400 um to ~600 um. But if the synapse is in the apical tuft, I'm guessing the distance could be ~1300 um.
[ben.suter] But if you have for example a L5A neuron synapsing onto basals or apical obliques of a L5B neuron, the axon may not need to turn up again, so the distance might be just 100 um.
[ben.suter] I think the delay "at the synapse" is ~1 ms.
[ben.suter] It all depends a bit on how you measure time, i.e. the AP itself has a width of 0.5-1.5 ms depending on how you measure that.
[ben.suter] But let's say we're measuring from the inflection point of the AP onset.
[ben.suter] At the synapse first you get depolarization as the AP rises, Ca starts coming in, and so on until release of vesicles and postsynaptic binding, and influx of excitatory ions there. So for a single synaptic contact, I guess it makes sense to measure from e.g. AP inflection point to 10% rise time on the postsynaptic side (if you could measure at the dendritic location).
[ben.suter] I think that's ~1 ms, but will need to check that. In any case, it's reasonably fixed for excitatory synapses.
[ben.suter] As it is determined by (a) ion channels at the axon terminal, (b) how much Ca is needed to release vesicles, (c) diffusion and clearing of Glu in the cleft, (d) binding and sensitization at receptors.
[ben.suter] In my mind, I think that the transmission speed from dendrite to soma is lower than along an unmyelinated cortical axon. But as I write this, I realize that I may be quite wrong ... so I need to check this. Actually I should also check my previous simulations to see this.
[ben.suter] For now, my guess is that the soma-to-soma separation (at least for neurons in the same "column") likely makes up no more than 1/3rd of the total delay.
Salvador Dura
ok great, thanks for the explanation — guess we'll have to come up with better delay estimates for point neurons
neurosim-isb@im.partych.at
[ben.suter] Also, since a unitary L5->L5 connection makes 4-6 synaptic contacts, and these can be distributed across the entire dendritic arbor, a single presynaptic spike results in a spread of delays postsynaptically.
[ben.suter] I'm not saying we need to get into that much detail, though.
[ben.suter] Just that changing the soma-to-soma separation by, say, 100-200 um laterally shouldn't have a major effect on the delay.
Salvador Dura
@spread - hmm yeah thats interesting, not sure if we are planning to model multiple synaptic contacts
@soma-2-soma sep - got it, makese sense
neurosim-isb@im.partych.at
[ben.suter] And the axonal distance in the radial dimension does probably vary depending on the class of projection (i.e. from L2->L5B versus L5B->L5B), but wouldn't change much if we adjust the "sparseness"
[ben.suter] I think it'll be cool to implement this and back it up with our own data.
[ben.suter] I'll add that to my list of things to analyse ...
[ben.suter] I guess the question that remains, then is:
[ben.suter] Do we want/need to represent various aspects of the synaptic delays in a pre/post cell-type specific manner?
[ben.suter] I believe that the delay is known to be different when interneurons are involved ...
[ben.suter] So my suggestion is to implement the delay in a way that is flexible, i.e. a function that pulls from pre and post syanaptic properties:
[ben.suter] generate_delay(pre_cell, post_cell) where the function has access to properties of the cell objects, including 3D
position of soma, cell type / transmitter type, and synapse location. To start, for point neurons and a soma-to-soma delay,
I'd go with 5 ms.

** Latencies/delays for initial version of model
- Ben summary: transmission delay only accounts for 1/3; vel= 1-10m/s; axon not straight line; use 5ms for point-point neurons
- For E->I latencies from Apicella:
"For layer 2/3 stimulation sites, the onset of IPSCs lagged that of EPSCs with a short delay for both corticostriatal and corticospinal neurons (corticostriatal, 3.1 􏲸 0.6 ms, n 􏲺 15; corticospinal, 4.2 􏲸 1 ms, n 􏲺 10; p 􏲺 0.3, t test)"
- delay = minDelay + dist/vel
-- minDelay = 3ms
-- vel = 0.5 m/s = 500 um/ms -- lower than 1-10m/s to account for non-straight axon trajectory
** added func in params/utils.py to read conn params from excel file
def importConnFromExcel(fileName, sheetName)

** synapses
- cliff m1:
  tauAMPA = 5 (ms) : Receptor time constant, AMPA
  tauNMDA = 150 (ms) : Receptor time constant, NMDA
  tauGABAA = 6 (ms) : Receptor time constant, GABAA
  tauGABAB = 150 (ms) : Receptor time constant, GABAB

- sam mtlPFC:
-- PYR cells
def set_synapses(self):
	*	self.somaGABAf 	 = Synapse(    sect=self.soma,   loc=0.5, tau1=0.07, tau2=9.1, 	  e=-80)
	*	self.somaAMPAf 	 = Synapse(    sect=self.soma,   loc=0.5, tau1=0.05, tau2=5.3, 	   e=0)
		self.BdendAMPA   = Synapse(    sect=self.Bdend,  loc=1.0, tau1=0.05, tau2=5.3,     e=0)
	*	self.BdendNMDA   = SynapseNMDA(sect=self.Bdend,  loc=1.0, tau1=0.05, tau2=5.3, tau1NMDA=15, tau2NMDA=150, r=1, e=0)
	*	self.Adend2GABAs = Synapse(	   sect=self.Adend2, loc=0.5, tau1=0.2,  tau2=20,   e=-80)
		self.Adend3GABAs = Synapse(	   sect=self.Adend2, loc=0.5, tau1=0.2,  tau2=20,   e=-80)
		self.Adend3GABAf = Synapse(	   sect=self.Adend3, loc=0.5, tau1=0.07, tau2=9.1,   e=-80)
		self.Adend3AMPAf = Synapse(	   sect=self.Adend3, loc=0.5, tau1=0.05, tau2=5.3,    e=0)
		self.Adend3NMDA  = SynapseNMDA(sect=self.Adend3, loc=0.5, tau1=0.05, tau2=5.3, tau1NMDA=15, tau2NMDA=150, r=1, e=0)
		self.Adend3AMPASTDP = SynapseSTDP(sect=self.Adend3,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)

New model (parametrized!):
self.somaGABAf = Synapse(sect=self.soma,loc=0.5,tau1=0.07,tau2=9.1,e=erevgaba)
self.somaAMPA = Synapse(sect=self.soma,loc=0.5,tau1=0.05,tau2=5.3,e=0)
self.BdendAMPA = Synapse(sect=self.Bdend,loc=bdsyloc,tau1=0.05, tau2=5.3,e=0)
self.BdendNMDA = SynapseNMDA(sect=self.Bdend,loc=bdsyloc,tau1NMDA=tau1NMDAEE,tau2NMDA=tau2NMDAEE,r=1,e=0)
self.Adend1GABAs = Synapse(sect=self.Adend1,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
self.Adend2GABAs = Synapse(sect=self.Adend2,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
self.Adend3GABAs = Synapse(sect=self.Adend3,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
self.Adend3GABAf = Synapse(sect=self.Adend3,loc=0.5,tau1=0.07,tau2=9.1,e=erevgaba)

--- LTS
 def set_synapses(self):
  *  self.somaGABAf 	= Synapse(sect=self.soma, loc=0.5, tau1=0.07, tau2=9.1, e=-80)
  *  self.somaGABAss	= Synapse(    sect=self.soma, loc=0.5, tau1=20,	  tau2=40, e=-80)#originally for septal input
    if STDP:
      self.somaAMPA = SynapseSTDP(sect=self.soma,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)
      self.somaNMDA = SynapseNMDA(sect=self.soma, loc=0.5, tau1NMDA=tau1NMDAEI, tau2NMDA=tau2NMDAEI, r=1, e=0)
    elif AMNMCA:
      self.somaAMPA=SynapseAMPACA(sect=self.soma,loc=0.5,e=0)
      self.somaNMDA=SynapseNMDACA(sect=self.soma,loc=0.5,e=0)
    else:
  *    self.somaAMPA 	= Synapse(    sect=self.soma, loc=0.5, tau1=0.05, tau2=5.3, e=0)
  *    self.somaNMDA 	= SynapseNMDA(sect=self.soma, loc=0.5, tau1NMDA=tau1NMDAEI, tau2NMDA=tau2NMDAEI, r=1, e=0)

-- FS/Basket cells
def set_synapses(self):
	*	self.somaAMPAf 	= Synapse(sect=self.soma, loc=0.5, tau1=0.05, tau2=5.3, e=0)
	*	self.somaGABAf 	= Synapse(sect=self.soma, loc=0.5, tau1=0.07, tau2=9.1, e=-80)
	*	self.somaGABAss	= Synapse(sect=self.soma, loc=0.5, tau1=20,   tau2=40, e=-80)#only for septal input
	*	self.somaNMDA 	= SynapseNMDA(sect=self.soma, loc=0.5, tau1=0.05, tau2=5.3, tau1NMDA=15, tau2NMDA=150, r=1, e=0)
		self.somaAMPASTDP = SynapseSTDP(sect=self.soma,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)

def set_synapses(self):
    self.somaGABAf=Synapse(sect=self.soma,loc=0.5,tau1=0.07,tau2=9.1,e=-80);#self.dSy['somaGABAf']=self.somaGABAf;
    self.somaGABAss=Synapse(sect=self.soma,loc=0.5,tau1=20,tau2=40,e=-80);#self.dSy['somaGABAss']=self.somaGABAss;
    if STDP:
      self.somaAMPA=SynapseSTDP(sect=self.soma,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)
      self.somaNMDA=SynapseNMDA(sect=self.soma,loc=0.5, tau1NMDA=tau1NMDAEI,tau2NMDA=tau2NMDAEI,r=1,e=0);
    elif AMNMCA:
      self.somaAMPA=SynapseAMPACA(sect=self.soma,loc=0.5,e=0)
      self.somaNMDA=SynapseNMDACA(sect=self.soma,loc=0.5,e=0)
    else:
      self.somaAMPA=Synapse(sect=self.soma,loc=0.5,tau1=0.05,tau2=5.3,e=0);#self.dSy['somaAMPAf']=self.somaAMPAf;
      self.somaNMDA=SynapseNMDA(sect=self.soma,loc=0.5, tau1NMDA=tau1NMDAEI,tau2NMDA=tau2NMDAEI,r=1,e=0);


class Synapse:
	def __init__(self, sect, loc, tau1, tau2, e):
		self.syn		= h.MyExp2SynBB(loc, sec=sect)
		self.syn.tau1	= tau1
		self.syn.tau2	= tau2
		self.syn.e		= e

class SynapseNMDA:
  def __init__(self, sect, loc, tau1NMDA, tau2NMDA, r, e):
    self.syn			= h.MyExp2SynNMDABB(loc, sec=sect)
    self.syn.tau1NMDA	= tau1NMDA
    self.syn.tau2NMDA	= tau2NMDA
    self.syn.r			= r
    self.syn.e			= e


class SynapseGABAB:
  def __init__(self, sect, loc):
    self.syn = h.GABAB(loc, sec=sect)

- sam comments
check SynapseNMDA and SynapseGABAB in /u/samn/mtlPFC/geom.py
the mod files should be in mod subdir
or pointers to central repo
gabab - have to be careful with it
can cause nan if one of the variables gets too large
there was a fix put in for that
but the weights should be carefully set - it's a slow synapse so takes time to build up its activation
or MyExp2SynNMDABB.mod - should set fracca to 0.0 (it's a GLOBAL in the mod file), assuming you're not using any calcium

k, prob won't make a diff anyway since not reading/writing the calcium
* 15oct14 running sim for first time for SFN15 poster
** 1st run after adding params from excel and debugging
Minimum delay (time-step for queue exchange) is  3.32858313314
  Done; run time = 139.9 s; real-time ratio: 0.01.

Gathering spikes...
  Done; gather time = 18.1 s.

Analyzing...
>>>
>>> >>> >>>
>>>


  Run time: 18.1 s (1-s sim; 10734 cells; 16 workers)
  Spikes: 0 (0.00 Hz)
  Connections: 1161717 (108.23 per cell)

- no spikes - check weights etc
- num of conns per cell too high? - looks reasonable compared to m1ms; avg of 1% of tot cells
- to test spikes reduce scale to 0.1 ?

- fixed background input labels in conn rules (before no background input) + added missing weights

- replaced GABAB syns with GABAB.mod

- Netstims connected but still no spikes -- even after increasing weight=5 -- maybe need to turn on Netstim?? - no

- h.Netstim objects not created! - yes, just removed during gather

- Increased netstim rate and weight but only managed to get I cells firing - only LTS

- Tried using different NMDA synapse but nothing

- had to set cell geom - diam and L !!!!

- math error when using GABAB synapse

- NMDA and GABAB give mathematical issues - using simpler versions

- For NMDA used simple synapse (longer time constants leads to no spikes using Netstims):
soma['syns']['NMDA'] = {'type': 'ExpSyn', 'loc': 0.5, 'tau': 15, 'e': 0}  # NMDA

- For GABAB used (from old sam's model mtlhpc):
soma['syns']['GABAB'] = {'type': 'MyExp2SynBB', 'loc': 0.5, 'tau1': 0.2, 'tau2': 20, 'e': -80}  # GABAB (slow)

** adjusting background rate and weight for E/I
- E_rate = 100, E_weight= 0.5, I_rate=100, I_weight=1 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151014_192025.png][fig]]

- test 1st only with background stim (no conns) (only 1k cells):
- E_rate = 50, E_weight= 0.01, I_rate=200, I_weight=10 - rate=19.2Hz (I high)
- E_rate = 20, E_weight= 0.01, I_rate=100, I_weight=0.1 - rate=19.2Hz (I high)[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_215008.png][fig]]

- E_rate = 20, E_weight= 0.01 (PT=0.03), I_rate=20, I_weight=0.05 - rate=7.6Hz (I higher)
- E_rate = 20, E_weight= 0.01 (PT=0.03), I_rate=20, I_weight=0.03 - rate=5.7Hz - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151014_194348.png][fig]]

- Now only background but with all 10k cells: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151014_195445.png][fig]]
  Done; run time = 301.5 s; real-time ratio: 0.01.
  Run time: 2.0 s (2-s sim; 10734 cells; 16 workers)
  Spikes: 122869 (5.72 Hz)

- weird! if decrease weight get more spikes!!

- MyExp2SynNMDABB works ok if reduce weight! maybe gets overloaded preventing further spikes

- E_rate = 20, E_weight= 0.001 (PT=0.01), I_rate=20, I_weight=0.0001 - rate=5.0Hz  [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151014_203037.png][fig]]

- saving data for Adri+Padraig:
Minimum delay (time-step for queue exchange) is  3.27757112048
  Done; run time = 181.9 s; real-time ratio: 0.01.

Gathering spikes...
  Done; gather time = 64.8 s.

Analyzing...
  Run time: 64.8 s (1-s sim; 10734 cells; 16 workers)
  Spikes: 13149 (1.22 Hz)
  Connections: 3963006 (369.20 per cell)
Saving output as ../data/M1_yfrac_izhi...

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_003252.png][fig]]

** Trying to increase I spikes with full conn
WITH 50x50um
- starting point - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_214157.png][fig]]
- removing I->E/I - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_214834.png][fig]]
- increasing bck->I weight: 'weight': 0.0005
- removing E->E: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_215116.png][fig]]

- no conns, only bck ->[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_215330.png][fig]]
(I->all was affecting mostly I rate)

- only E->I - decrease firing!! why?! BUG!! E->I was using GABA instead of AMPA!!! -ok now increased firing [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_215840.png][fig]]
- added E->E - increased firing ! [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_220025.png][fig]]
- added I->all - slightly reduced firing! - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_220129.png][fig]]

WITH 300x300um
- get oscillations and on-off inh spiking - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151015_221813.png][fig]]

WITH 50x50um (pcon_fix)
- similar to other - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151016_011558.png][fig]] (more connections/cell; higher rate)

* 15oct18 OSB with Adrian
- izhi -> HH
- GABAB -> GABA
- NMDA not present - neuroml has similar option - they have pulseGenerator = IClamp
- can get synapse info from our data -- same params different names
- downsampled x 15
- https://github.com/openworm/org.geppetto/issues/458
* 15oct22 Meeting with Ben after SFN15 at Northwestern
** Cell properties can't be all described in python dict format
- some of the hoc cell template specifications for eg. ion channel or synaptic distribution, are too complex to implement in
  dict format
- should have option to use the dict format for simple things, but also just reference a hoc cell template, or python cell
  class/object
- could optionally pass info from network/framework to the cell type template/class (eg. yfrac), so certain properties are
  instantiated as a function of that.
- advantage of framework was to enable arbitrary cell property rules based eg. on yfrac and cell type? how to do that now?

TODO:
- Izhi2007Type - conceptually wrong inside the soma section
- Use default value for 'loc' etc - should new property default values overwrite prev values depending on whether they were
  default or not
** Subcellular connectivity patterns
- see gdoc: https://docs.google.com/document/d/1xaEUdUhqtqtvd2bfCruGfjNcCvIxQPvCaIL-SYDZDLA/edit#heading=h.xqev18eqksg0
- define nomenclature:
-- functional/unitary/cellular conn: between 2 cells, can include multiple contacts along dendritic tree
-- synaptic contacts/synapse: each functional/unitary connection can have multiple; individual sysnape (h.Netcon object)

- how to convert from synapses in MC cell to single synapse in point neuron? weights might need to vary for each contact, so
  not linear - complex problem! timing also issue, can use multiple netcons with all the timing and different weights
- no evidence that in vivo circuit should be firing - just low - most inputs come from long range, not local - shouldn't have
  sustained activity just with local inputs, might need lots of external inputs
- markram also 250um haxagon, based on cortical column, ~10k cells - try to keep num of cells realistic
- connection = presyn source to target (could be multiple presyn cells, and target could be 1 cell or a specific
  contact/dendrite/compartment)

- logical connection/synapse can be of several pre and post types:
-- pre: population, cell or terminal axon (focus on population, cell)
-- post: population, cell or dendrite location (focus on cell,dendrite)

- In future could imagine modeling pops as input/output functions, and having conns from/to pops (eg. S2, thalamus, spinal
  cord) outside of main detailed network. Could also have interactions between pops. (future Grant material!)

- GET HOC CODE from Ben
- synapse-epsprate.hoc
- distributeSynapses()
- radialSynapseLocation()

- apical vs basal overlap in yfrac
- spiny = sum of apical and basal that are spiny
- value of 0 = midway thgough apicals
- tuft = ~L1 dendrites

- For CSP: In mouse nexus os not beginning of tuft; whereas in rat it seems to be
- Interesting that mouse CSTR the nexus does seem the beginning of the tuft; but rat cells can't be CSTR because they have
  high Ih, bug tufted, and are larger

- HCN dendritic distribution.pptx - interesting!

- somas, apical trunk (from soma; may continue after branching of obliques; thicker and straight)
- obliques (below main branch point/nexus; branch at an angle; are thinner)
- main trunk -- goes beyond initial branching of obliques
- upper apicals, branches from the main trunk, after nexus, but before tuft
- main branch point / nexus = -- bifuraction/split with similar diameter smaller than main trunk

- dendrogram - nexus based on whether all children branches will reach tuft (but beware of slice end so cuttings)

- SectionLists useful both for cell property definition and connectivity

- single axon can target many cells multiple times; each contact should have its own delay/weight
- if no compartments - Netcon associated to unitary connection

- conceptual 3 levels:
-- synaptic? (or just) conn: Exc or Inh or neuromodulatory; presyn could be area/pop, postsyn single cell or pop -- similar
 to conn rules?
-- unitary conn:
-- synaptic contacts

- conn rules (based on conds of cells in network eg. pop or single cell, include neurotransmitter) -> unitary conns ->
  contacts (if multicompartment)
- when to create synapses? applying the connectivity rules
- simulator-independent network?

- some cells may release multiple neurotransmitters - but not described - omit
- postsyn receptors are different from presyn release
- weight has no meaning

- logical conns as part of postsyn cell

- how is subcellular syn dsitribution defined:
-- stereotypical: eg. basket near soma, prob can't provide specific numbers, path distance from soma, defined for
sectionList
-- layers: sysn go to certain layers
-- yfrac range:
*-- radial distribution: distribution/density as func of yfrac
-- branch order: branch/sub-branching levels
*-- categorical: target tuft,soma etc (named sectionLists)
-- distance from soma: not y-frac but distance based (possibly used)
-- NOTE: our data will be radial dsitributions; his maps are 2D so the density depthwise at middle is higher than far from center; radial specifies dsitribution as func of center (xdist) in a
3d way;
-- NOTE: line of how much we enter into the model; how much pre-processing we do to convert onto model format
-- NOTE: for each postsyn type

- maybe synpase type in cell properties: eg. AMPA, g, tau etc; but synapse distribution in conn rules?

- synapse dynamics??

BACK AFTER 1 MONTH:
- define subcellular location of synapses:
1) named sectionlists of sublists - apicatuft, obliques
2) radial distribution, fraction yfrac, normalized, cortical depth, where dendrites fall in layers (cx centered, not cell
 centered)
3) path distance from soma
-- plus combination of above
-- 1st, 2nd order branches differences cannot be specified directly, but can create sectionlists
eg. 1st 50um apical trunk no spines - subsets that are spiny vs non-spiny

2 METHODS:
A) 2-step implementation: 1) unitary conns, 2) contacts (subcellular conn)
B) axo-dendritic density overlap - you don't know unitary without calculating subcellular
-- HBP approach - axonal density is function of proj from L2->L5 + dendritic density, even if cells not realistic, calculate
weight+prob

- Diagram of netpyne very cool and represents very well what we designed - separate network simulation + huge contribution,
  BUT: abstraction (kim blackwell)
- maybe have default internal values, and allow user to define more abstractly
- define conn

- conns independent from cell

-so if we imagine a hierarch struc where a 'unitaryConn' object contains a list of 'contacts' (~= Neuron Netcons) and 'synapses' (Neuron Synapses)
this unitaryConn would have a specific pre and post-cell id
but it may be the case, that the synapse is used as the target of many presyn cells
(at least in Neuron terms and how we usually build models now)
which means the 'synapse' would have to be outside of the 'unitaryConn' and just be referenced by name or whatever
I'll just point out that this doesn't make all that much sense to me (despite being the way you do it)

- 2 levels of instantiation - abstract (no specific models, not simulatable, cellular); and specific (subcellular)
- from 1st - every neuron has to be assigned and implementation; and every connection has to be implemented
- thats what happens right now but abstract instantiation is not saved
- 2nd step consists of instantiating subcellular info - cell morphology + subcellular conn (could be separate)
- 1st pass) cellular instatiation step (includes cell+conns); 2nd pass) subcellular step; 3rd pass) choose simulator pick
  Neuron object for each cell
- In 3rd level decide where to place h.Netcons and h.Synapses

- potentially have rules for how to apply cell models

- conns = unitary conns - presyn, type (AMPA), weight (somatic response for 1 AP presyn cell ~0.2 mV EPSP), delay?
- in connParams have subcellular conn info - but not added to cell objects, only once create simulatable individual cells,
  wire it up

- just 3 levels : specifications -> cellular -> simulator instantiation
- Neurons instantiation separate from python structure - linked by cell id
- for each unitary connection, check cell model of presyn and postsyn and decide if use NetCons, Synapses etc

** How to tune network params
- Reproduce conn maps - Weiler Anderson etc - eg. Japan people -- for validation
- firing rates for different cells?
- LFPs?
- Gordon recommended reproduce fig 11 from some paper - Ih (Sheets, 2011)

- Gordon slides? local and long-rang conn summary



** Fitness function combination for single cell fitting
- Spike shape: width_25%, width_50%, threshold, slope_min+slope_max, amplitude, peak (not used)
- f-I curve
- spike timing
- time to 1st spike
- subthreshold
- sag
- ISI Vm shape + ISI interval between spikes
- 13 parameters in total - need to weight all and maybe remove some
- spike shape features: error = (fit_model - fit_exp) / fit_exp
- Ben obtained weight for each of the AP shape features (in paper, take pic?!)
- Drop SFA and just use spike timing
- Subthreshold and sag (-25 to 75 ms around injection - heavy weight zone; offset 25-75ms) - 40, 20, 40% weighing
- leave out ISI duration and depth
- Could use relative weighting to choose from archive
- Equally weighted: Ap shape, f-I, spike timing, subthres (ISI Vm?)
- pessimistic using THESE channels can reproduce everything - unles make all kinetics free params (<25%)
- parameters - now ~14, randomly/experience-based chosen; future approach is to fix as many as we can, and select free params
  based on literature/modeldb

* 15nov23 Next steps
- Analysis functions - plot LFP (LFPy?), weight matrix
- Cell properties loaded from cell template (eg. PT cell)
- Subcellular connectivity
- Check synapses errors
- Param optimization via evol algos using NSG
- Upload to github for Padraig

1) PT CELL
-- hoc template converted into python framework
-- connected randomly
-- tuned params so can run
2) Analysis LFP, weight matrices
-- LFPy
3) Setup param optim
-- evol alg, flexible
-- NSG
4) Padraig

* 15nov30 Adding detailed PT cell to network
** chat with sam
repo of project i'm working on for tuning the SPI cell is /u/samn/PTfit
ctune.py there loads the PTcell template, which is located in /usr/site/nrniv/local/hoc/PTcell.hoc
there's also a small py wrapper in /usr/site/nrniv/local/python/PTcell.py
Ash/we started putting an old version of the PTcell into a network of INTF cells in /u/samn/hybsim

** pt object
pt = makecell()
for sec in pt.allsec(): print sec.name(), sec.nseg
pt.apic[100].parentseg().sec.name()
** sectionList
- need during runtim? for connectivity purposes?
- option 1: can include section attribute named 'sectionList' and add name, but could take longer to set properties if have to search all
- option 2: can include as dict in sectionLists in cellProp, and then add all sections inside of each sectionList dict; but would
  change the consistency of the generic implementation (cell.py etc)
- option 3: can add additional dict sectionLitst in cellProp, simply including list of sections (need to return additional
  dic from util.py function)
- best options seem 1 or 3
- Need to create sectionList at runtime? useful?

-- iterating over sectionList
from neuron import h
​
s = h.Section(name='s')
a = h.Section(name='a')
d = h.Section(name='d')
​
sl1 = h.SectionList()
sl1.append(sec=s)
​
sl2 = h.SectionList()
sl2.append(sec=a)
sl2.append(sec=d)
​
section_lists = h.List('SectionList')
print 'There are %d SectionLists' % section_lists.count()
​
for i in xrange(int(section_lists.count())):
    print 'SectionList %d has the following sections: %r' % (i + 1, [str(sec.hname()) for sec in section_lists.o(i)])

--- Note that this iterates over all SectionList objects, not just those associated with a particular cell.
--- Alternatively, itertools.chain.from_iterable https://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable
** topology
how to extract topology of section?
children()
parent()
parent_connection() (x of parent)
section_orientation() (x of child)

secRef = h.SectionRef(sec=sec)
        if secRef.has_parent():
        	secDic[secName]['topol']['parentSec'] = getSecName(secRef.parent().sec)
        	secDic[secName]['topol']['parentX'] = h.parent_connection()
        	secDic[secName]['topol']['childX'] = h.section_orientation()
** density mechanisms
- ismembrane()
- mechanisms only exist in segments; can get list iterating dir and checkign with ismembrane

>>> for sec in cell.allsec():
...  for item in dir(sec(0.5)):
...   if h.ismembrane(item):
...    print sec.name(), item
...

- BUT! if want to store params of each mechanism have to check if these vary in different segments, and if so have to store
  value per segment
-- check if all params of the mech are equivalent in all sections -- if so, save just 1 set of param values per section; if
   different, store param values for each segments

- Note 'for seg in sec.allseg():' (includes 0 and 1) != 'from for seg in sec:' (>0 <1)
  http://www.neuron.yale.edu/phpbb/viewtopic.php?f=2&t=2150

- only 2 sections:
('apic', 18) ih gbar
[0.0006749175471739788, 0.0008670350196297068, 0.0012624538709514303]
('apic', 22) ih gbar
[0.002444472114623489, 0.0034176724028474412, 0.00565]
PTcell[0].apic[23]


- salvadord [2:59 PM]: ok cool... so its fine that all mechs of all sections with multiple segments, have the same mech param values for all segments? (except for apic[18] and apic[22] )
-samn [3:00 PM]: y

- and many dist mechs -- artificial mech to enable multisplit

- getting synapses info:
for sec in h.allsec():
...  for seg in sec:
...   print sec.name(), seg.x
...   seg.point_processes()
cell.esyn.hname()
'Exp2Syn[0]'

- Alternative method: https://www.neuron.yale.edu/neuron/static/docs/help/neuron/neuron/classes/mechtype.html
mt = new MechanismType(0) mt = new MechanismType(1)
Description: Provides a way of iterating over all membrane mechanisms or
       point processes and allows selection via a menu or under hoc control.

** importing 6-compartment python-based cell
/usr/site/nrniv/local/python/mtl.py


elif fileName.endswith('.py'):
 		filePath,fileNameOnly = os.path.split(fileName)  # split path from filename
  		if filePath not in sys.path:  # add to path if not there (need to import module)
 			sys.path.insert(0, filePath)
		moduleName = fileNameOnly.split('.py')[0]  # remove .py to obtain module name
		exec('import '+ moduleName)  # import module dynamically
		exec('modulePointer = '+ moduleName)  # assign pointer to module dynamically
		cell = getattr(modulePointer, cellName)()  # create cell
		secList = cell.all_sec
** soma overwritten when adding synapses
- after loading detailed cell model, if add synpases at soma it gets overwritten
- python structure not overwritten, but Neuron hSection object yes
- fixed - now check if h.Section exists
** recording synapses variables
added: eg. 'Syn_g': {'sec':'soma', 'pos':'0.5', 'syn':'NMDA', 'var':'g'}
** weights for different types of synapses
- synapse modifies synaptic current (i) of membrane at that location, ie. provides input current
-  works by increasing conductance (g) when spike is received, simulating voltage-dependent ionic channel / current
- the weight affects how much g is modified, and thus the input i

*** Expsyn
weight = 100

*** Exp2Syn
- Exp2Syn tau1 is rise time constant (speed of increase of g), tau2 decay time constant (speed of decay of g)

* 15dec23 Modularize izhi cells
** importCellParams
importCellParams('../cell/izhi2007Wrapper.py', 'labels', 'type2007', 'P')

- doesn't read the section L and diam, which affects the cell -- but only when synapse involved (via g)
- but if try to read from cell object (cell=IzhiCell() ), no way of knowing which are izhi cell params (unless specify)

- tried to separately read section info using: cellProp['sections'] = importCellFromTemplate('../cell/izhi2007Wrapper.py',
  'IzhiCell')

- have to fill in this way:
cellProp['sections'] = importCellFromTemplate('../cell/izhi2007Wrapper.py', 'IzhiCell')
cellProp['sections']['soma']['syns']['AMPA'] = {'type': 'Exp2Syn', 'loc': 0.5, 'tau1': 0.05, 'tau2':5.3, 'e': 0}  # AMPA
cellProp['sections']['soma']['syns']['GABAA'] = {'type': 'Exp2Syn', 'loc': 0.5, 'tau1': 0.07, 'tau2': 9.1, 'e': -80}  # GABAA

- error because reading Izhi point process as synapse! - check if has 'cellid' field so omit - make more robust check!

- now works:
ellProp['pointNeurons']['clausIzhi2007b'] = importCellParams('../cell/izhi2007Wrapper.py', 'labels', 'type2007', 'P') # point cell properties
cellProp['sections'] = importCellFromTemplate('../cell/izhi2007Wrapper.py', 'IzhiCell')
cellProp['sections']['soma']['syns']['AMPA'] = {'type': 'Exp2Syn', 'loc': 0.5, 'tau1': 0.05, 'tau2':5.3, 'e': 0}  # AMPA
cellProp['sections']['soma']['syns']['GABAA'] = {'type': 'Exp2Syn', 'loc': 0.5, 'tau1': 0.07, 'tau2': 9.1, 'e': -80}  # GABAA
netParams['cellProps'].append(cellProp)  # add dict to list of cell properties

- COULD ALSO COMBINE AS:
cellProp.update(importCellFromTemplate('../cell/izhi2007Wrapper.py', 'IzhiCell', pointNeuronParams = 'labels'))
or store in sep variables and then assign to dicts
find pointProcess and check if has list of labels to confirm its pointNeuron
func sets all izhi params indicated in labels
func returns 'sections' and 'pointNeurons' dicts

** option 1
cellProp = {'label': 'P', 'conditions': {'cellType': 'P'}, 'sections': {}, 'pointNeuron': {}}
cellProp['pointNeuron'] =
{'model': 'clausIzhi2007b', 'params': importCellParams('../cell/izhi2007Wrapper.py', 'labels', 'type2007', 'P')} # point cell
properties

netParams['popParams'].append({'popLabel': 'SA2', 'cellModel': 'PointNeuron', 'cellType': 'SA2', 'numCells': 10}) # add dict
with params for this pop n

** option 2

cellProp = {'label': 'P', 'conditions': {'cellType': 'P'}, 'sections': {}, 'pointNeuron': {}}
cellProp['pointNeuron'] = {'clausIzhi2007b': importCellParams('../cell/izhi2007Wrapper.py', 'labels', 'type2007', 'P')} # point cell
properties

netParams['popParams'].append({'popLabel': 'SA2', 'cellModel': 'ClausIzhi2007b', 'cellType': 'SA2', 'numCells': 10}) # add dict
with params for this pop n

OR
netParams['popParams'].append({'popLabel': 'SA2', 'cellModel': ('PointNeuron','clausIzhi2007b'), 'cellType': 'SA2', 'numCells': 10}) # add dict
with params for this pop n

OR

in cell.py

class ClausIZhi2007b(PointNeuron):

** option 3
cellProp = {'label': 'P', 'conditions': {'cellType': 'P'},  'sections': {}, 'pointNeurons': {}}
cellProp['pointNeurons']['clausIzhi2007b'] = importCellParams('../cell/izhi2007Wrapper.py', 'labels', 'type2007', 'P') # point cell properties
cellProp['pointNeurons']['Izhi2007b'] = {'C':100, 'k':0.7, 'vr':-60, 'vt':-40, 'vpeak':35, 'a':0.03, 'b':-2, 'c': -50, 'd':100, 'celltype':1} # point cell properties

in cell.py:
class PointNeuron:
        pointProc = self.__class__.__name__ # prop['pointNeuron']['model']
        if pointProc == 'PointNeuron':
            pointProc = 'Izhi2007b'  # default to Izhi2007b

class ClausIZhi2007b(PointNeuron):
   pass


- This option is best to conceptualize cell properties as independent from cell model, ie. you can provide the parameters of
this cell type for different cell models, including HH multicompartment, Izhi2003b or Izhi2007b
- Useful to swap HH with Izhi2007 or Izhi2003 - conceptually makes sense since can keep constant cellType and just modify
  cellModel
- Also conceptually separating the cell model (HH, Izhi2003, Izhi2007 -- specified when creating pops) from the cell model
  parameters/properties (sections, izhi param values)
- Its discussable whether this has practical utility cause:
1) can use separate cell property rules for different cell models (not elegant?)
2) different cell models will require deifferent properties - eg. not same params if use 5 compartment or 100 compartment; or
   if use Friesen vs HH
3) can be confusing to people to have params for multiple point neurons

- Explaining it to Jing:
I made some changes so that for each cell type (cell property rule) you can define multiple point neuron model params (eg. params for Izhi2007b, for clausIzhi2007b, and for Izhi2003b)

you can then select which cell model to use when you create the populations ('cellModel' property)

the rational for this is that cell types can be implemented by different cell models (Hodgkin Huxley, Izhi2007, Izhi2003) -- so when you define the network populations you can keep the cell type constant (eg. SA2), and just change the cell model you wanna use for that population

* 15dec28 Convert into python package
- PyNet ? NeuPyNE, NeuPyNet, netpyne !! PYthon-based NETwork development framework for the NEuron simulator
- NeuPyNe = NEUron simulator PYthon-based Network developing framework
- NetPyNe = NETwork PYthon-based developing framework for the NEuron simulator; or NETwork developing framework from Python-NEURON

- make shared -> framework  - OK
- from pynet import framework as f
- just need init.py and param.py file
- to add cells or conn functions use:
-- class newCellClass(PointNeuron): ... ;  f.newCellClass = newCellClass
-- class newConnFunc(): ... ; f.newConnFunc = newConnFunc
- default simConfig
- from pynet import init ; init.createAndRun(netParams, simConfig)
* 15jan26 Possibly making more simulator-indep using NeuroML-based format
** NeuroML format
- could represent all nml format using python dicts (instantiated net)
- additional abstract layer (connParams, netParams etc) - using more general format and then converted to nml
- eg. https://github.com/OpenSourceBrain/Thalamocortical/tree/master/neuroConstruct/generatedNeuroML2
- https://www.neuroml.org/getneuroml
- https://www.neuroml.org/tool_support
- https://github.com/NeuralEnsemble/libNeuroML
- https://github.com/NeuroML/pyNeuroML
- http://bioportal.bioontology.org/ontologies/CNO
- http://www.neuroconstruct.org/
- http://neuronvisio.org/


*** Issues
- Would like to keep simple declarative (python dicts based) specifications
- Want to make netpyne more NEURON-independent, both at specifications, and py instantiated network
- netpyne makes use of mod files, but neuroml requires detailed specification
- netpyne provides conversion from abstract specifications -> instantiated network, and support for multicompartment, and
  subcellular connectivity
- netpyne provides instantiation of NEURON objects, and parallel simulation of network
- netpyne can use NeuroML structure but using dictionaries instead of xml text - so easy to manipulate
- libneuroml and pynn - procedural, not so intuitive, and require internal definition of cell types etc (eg. IAF); whereas
  netpyne is 'declarative', more intuitive?, can define arbitrary cell props based on mechs and syns
- dictionary of equivalences NEURON<->NeuroML (eg. tau1, rise)

*** cells
NOTE: segment = sections/segment; segmentGroup = sectionList/section
- can have segmentGroups that consist of segmentGroups
- Neuron sections->segmentGroups
- Neuron 3d points -> segmnets
- Neuron nseg -> property tag numberInternalDivisions
- if have pointProcess in segment -> mapping of position along section and where pointprocess is placed

    <include href="nap.channel.nml"/>

    <include href="pas.channel.nml"/>

<cell id="SupAxAx">

        <notes>Cell: supaxax_0 exported from NEURON ModelView</notes>

        <morphology id="morphology_SupAxAx">

            <segment id="0" name="Seg0_comp_1">
                <proximal x="0.0" y="0.0" z="0.0" diameter="15.0"/>
                <distal x="0.0" y="10.0" z="0.0" diameter="15.0"/>
            </segment>

            <segment id="1" name="Seg1_comp_1">
                <parent segment="0"/>
                <distal x="-4.371139E-7" y="20.0" z="0.0" diameter="15.0"/>
            </segment>

 <segmentGroup id="prox_dend_soma">
                <include segmentGroup="comp_1"/>
                <include segmentGroup="comp_41"/>
                <include segmentGroup="comp_28"/>
                <include segmentGroup="comp_15"/>
                <include segmentGroup="comp_2"/>
            </segmentGroup>


	<biophysicalProperties id="biophys">

            <membraneProperties>

                <channelDensity condDensity="0.0 mS_per_cm2" id="ar_ModelViewParmSubset_1" ionChannel="ar__m00_25" segmentGroup="ModelViewParmSubset_1" erev="-40.0 mV" ion="ar"/>

                <channelDensity condDensity="0.1 mS_per_cm2" id="cal_ModelViewParmSubset_4" ionChannel="cal" segmentGroup="ModelViewParmSubset_4" ion="ca" erev="125.0 mV"/>

                <channelDensity condDensity="0.2 mS_per_cm2" id="cal_ModelViewParmSubset_5" ionChannel="cal" segmentGroup="ModelViewParmSubset_5" ion="ca" erev="125.0 mV"/>

                <channelDensity condDensity="0.0 mS_per_cm2" id="cat_ModelViewParmSubset_1" ionChannel="cat" segmentGroup="ModelViewParmSubset_1" ion="cat" erev="125.0 mV"/>

                <channelDensity condDensity="0.0 mS_per_cm2" id="k2_all" ionChannel="k2" ion="k" erev="-100.0 mV"/>

                <spikeThresh value="0.0 mV"/>

                <specificCapacitance value="1.0 uF_per_cm2"/>

                <initMembPotential value="-65.0 mV"/>


*** connections
<projection id="LTS_AxAx_sm" presynapticPopulation="CG_C04_LTS_sm" postsynapticPopulation="CG_C04_AxAx_sm" synapse="Inh_LTS_FS">
            <connection id="0" preCellId="../CG_C04_LTS_sm/5/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="112" preFractionAlong="0.26785243" postSegmentId="82" postFractionAlong="0.36041966"/>
            <connection id="1" preCellId="../CG_C04_LTS_sm/3/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="116" preFractionAlong="0.6782849" postSegmentId="91" postFractionAlong="0.99472666"/>
            <connection id="2" preCellId="../CG_C04_LTS_sm/6/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="112" preFractionAlong="0.42696908" postSegmentId="84" postFractionAlong="0.46009916"/>
            <connection id="3" preCellId="../CG_C04_LTS_sm/0/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="113" preFractionAlong="0.92599744" postSegmentId="83" postFractionAlong="0.60695267"/>
            <connection id="4" preCellId="../CG_C04_LTS_sm/9/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="113" preFractionAlong="0.5823235" postSegmentId="39" postFractionAlong="0.646692"/>
            <connection id="5" preCellId="../CG_C04_LTS_sm/6/SupLTSInter" postCellId="../CG_C04_AxAx_sm/0/SupAxAx" preSegmentId="113" preFractionAlong="0.16917303" postSegmentId="57" postFractionAlong="0.6089958"/>

*** synapses
<?xml version="1.0" encoding="ISO-8859-1"?>
<neuroml xmlns="http://www.neuroml.org/schema/neuroml2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.neuroml.org/schema/neuroml2 https://raw.github.com/NeuroML/NeuroML2/development/Schemas/NeuroML2/NeuroML_v2beta4.xsd" id="Syn_AMPA_L4SS_IN">

    <notes>ChannelML file describing a single synaptic mechanism</notes>

    <alphaSynapse id="Syn_AMPA_L4SS_IN" tau="0.8ms" gbase="2.94303552937e-07mS" erev="0.0mV">

        <notes>Synapse with syn scaling constant c = 1 nS (translating to max cond of 2.94304e-07 mS), time course: 0.8 ms and reversal potential: 0 mV.
        Automatically generated by command:  genSyn.py Syn_AMPA_L4SS_IN 0.8 1 0 </notes>
</alphaSynapse>

</neuroml>
*** population

        <population id="CG_C04_FRB_sm" component="L23PyrFRB_varInit" type="populationList" size="6">
           <annotation>
                <property tag="color" value="0.0 0.0 0.0"/>
            </annotation>
            <instance id="0">
                <location x="-739.27563" y="-798.43396" z="-440.9723"/>
            </instance>
            <instance id="1">
                <location x="975.8342" y="-870.85077" z="1090.1094"/>
            </instance>
            <instance id="2">
                <location x="-1012.162" y="-785.71173" z="1053.8684"/>
            </instance>
            <instance id="3">
                <location x="-1391.423" y="-776.4188" z="-32.483643"/>
            </instance>
            <instance id="4">
                <location x="149.5564" y="-790.7691" z="433.74915"/>
            </instance>
            <instance id="5">
                <location x="585.53955" y="-765.37933" z="819.1377"/>
            </instance>
        </population>


*** pulse generator (netstim?)
   <pulseGenerator id="DepCurr_L23FRB" delay="0.0s" duration="20.0s" amplitude="3.0E-10A"/>

    <pulseGenerator id="DepCurr_L23FRB__0" delay="0.0s" duration="20.0s" amplitude="3.37936E-10A"/>
** chat with Bill
summary of 3-hr meeting with Ben: 1) he really likes netpyne, 2) discussed how to add subcellular syn info (3 main methods: sectionlists, yfrac-based, path distance-based), 3) provided his unpublished code to convert sCRACM data to synapse density maps and said we can use in netpyne, 4) suggested making netpyne more NEURON/simulator-independent (similar to Kim Blackwell)

on this last point (simu-indep), I looked at NeuroML2 format, and some of the tools Padraig has built 2 interface it with Python and Neuron (eg. neuroconstruct, pyNeuroML, libNeuroML), and read Robert's reproducibility paper

I think it might be possible to make netpyne simulator-independent at the specs and instantiated network, using a NeuroML-like internal format (but using python dicts instead of xml so can manipulate data) -- and then keep final stage where its converted to Neuron simulatable objects

sent padraig an email to discuss the technical details of what they've already implemented and how netpyne could fit, and be useful to fill in missing tools in this whole story

an alternative is to keep it as a tool specific for Neuron, with its internal Neuron-based format for specs and network, and the possibility of exporting/importing from NeuroML and others (ie. its current status)

** chat with Padraig
- good to separate M1 model from netpyne
- similarities with pnn and libneuroml
- important of neuroml is conceptual structure
- libneuroml has cell types
- mapping from pyneuroml to mod files, but not the other way around

- standardization of abstract conn rules is above pynn and nueroml/pyneuroml
- eg 10 conn algorithms -> pynn -> neuroml
- morphology - segments, segment groups

- mod files would need to be translated into nueroml (not fully translated); alternative would be point to nueroml
  definition, convert via pyneuroml to Neuron mod
- setup.py to netpyne
- dot.travis jml continuous integration server - run tests every time there is a commit to repository - make sure its consistent
  with latest version

- convert from Neuron model to NeuroML:
-- export specifications
-- OSB converting to NeuroML2 cell morphology (pyneuroml.convert_to_neuroml2) - in future if already in neuroml dont need to
 define in Nueron/netpyne format
-- Izhikevich (params) - abstract definiton
-- export to Nueroml2 positions and connectivity - no current tool to convert
-- https://github.com/OpenSourceBrain/Cerebellum3DDemo
-- http://www.opensourcebrain.org/docs#Converting_To_NeuroML2


- convert from NeuromML to Neuron:
-- java script to convert neuroml to mod and Neuron/py files - wait for better iteration
-- adapt java code to convert directly to netpyne
-- https://github.com/NeuroML/org.neuroml.export/blob/development/src/main/java/org/neuroml/export/neuron/NeuronWriter.java
-- https://github.com/NeuroML/org.neuroml.export/blob/development/src/main/java/org/neuroml/export/pynn/PyNNWriter.java
-- check param files hhtut izhitut updated so can padraig can modify
-- add load cell function in netpyne in neuroml format


- differences:
1) declarative
2) netpyne makes use of mod files, but neuroml requires detailed specification
3) netpyne provides conversion from abstract specifications -> instantiated network, and support for multicompartment, and
  subcellular connectivity
4) netpyne provides instantiation of NEURON objects, and parallel simulation of network

- options:
-- long-term: use Neuroml internally for instantiated network
-- short-term:  Neuron-based and conversion to NeuroML;
* 15mar02 Randy Bruno talk
** bill notes: 16mar02 12:00 Randy Bruno The many input layers of the neocortex
*** sensing, perceiving, applying previous knowledge, planning sequences of actions
*** sensory systems are close to the front end -- see Fox and Wong 2005
*** follow the wires -- axon from thal to layer 4 -> L2/3 -> L5
*** hubel&wiesel suggested higher combinations of features
*** whisker system -- experience mediated changes -- fill TC with biotin in vivo; stain and slice; VPM to barrel
see lot of axon outside L4 -- deeper layers -- shortcut to L5?
a dense set of projection in L5/6 border
both L4 and L5B cells will spike with whisker movement
*** anesthetized animals ; Constantinople & Bruno 2013 Science
PSP onset latencies gneerally <= in L5 vs L4 while longer in L23 -- 5ms fastest then out from 5 to 18 in L5; 8-12 in L23;
even the later L5 ones are not following L2/3 but about same as L2/3
spike latencies 9 ms L5, 11 ms L4
*** in L5 thick tufted; give weak whisker stim and see a correlation of EPSP with TC firing -- 2-3 ms latency
0.5 mV lasting out to 40 ms -- monosynaptic connection
all weak connections -- 0.5 mV -- connection probability maybe 30% for L5 and 45% for L4 (10% for L6)
L5 onto both thick and thin tufted
*** 200 thal cells in a somatotopic region of whisker thal so maybe 18 TCs onto L6, 52 onto L5, 86 onto L4
50 is already enough to make something happen -- 50*0.5mV
oversampled 5A but found most in 5B at around 1500 mu depth -- right where the anatomy shows it to be
*** put pipette into L4 and anesthetize L4 or L2/3 with lidocaine -- patch a cell locally (200 mu away) and show that can eliminate activity
see recovery after 20 m
L56 activation are largely unaffected by shutting off L4 -- little bit longer if anything -- maybe some feedforward
*** now switch to mouse to do optogen cre line with halorho in L4 neurons so can turn them off
*** counted all the cells (Oberlaender etal 2012 CCx)
L4 cells are more than 2x denser than L5;  2x spines in L4 than L5 and L6
not as many targets in L5
10% of spines in L4 are from L5 cells; spines/neuron; spines/unit volume same
*** L4 and L2/3 are less depolarized ;  L5 cells are much closer to threshold
L5 need only half as much drive to reach thresh
L4 -25 mV, L5 -17 mV L6 -24 mV
*** not a series of sensory transformations -- eerie  similarieites to hippocampus
thal compies info to L4 and L5
extensive connections between 2/3 and 5 are not talking about sensory representation -- bayes?  goals, contexts, states
Oberlaender Ramirez and Bruno 2012;  Ferster & Levay 1978
*** sparse pop of L2/3 cells that are IT STR
*** matrix thal into L1 and other cortical areas to L1  -- gating; does L5a get from similar assoc fibers
*** discrim different shapes -- convex vs concave with whiskers -- lick L or lick R
*** animals detect a pole with whisking -- release lever (Lacefield, Rodgers and Bruno; Lacefield & Bruno)
hold down lever to start; if pole perceived then release lever and get rewarded
can't do recordings in L1 but can image ca in apical dends
when trial starts -- apicals are activated within 1 sec
get a second peak -- delaying reward delays second peak
introduced a delay to water reward -- this 2nd peak is based on when the reward comes
unexpected reward the apicals fire again
longer the animal is trained the bigger the reward associations in barrel cx L1 becomes
see something similar in L2/3 apicals
no reward related activity in L4 cells -- L4 cells don't reach up to L1
difference between expectation and reward delivery -- don't give the reward -- still see some signal but not quite as much
*** summary: all thal axons bifurcate into 2 strata -- matrix to L1 and L5A
L4 is not the 1st stage of cx processing
'sparse' connections may drive activity in any systems -- 10% of axons go to one place and 90% to elsewhere, the 10% can be very important
neocortex is 2 sep circuits with diff functions -- like 2 diff regions (upper vs lower)
many basic behaviors may only require one of these systems
during behavior bottom up active contacts tirgger dend spikes in apical tufts
sensory cx neurons may learn thru reinforcement
​
*** upper layers have been animals have 2 tasks may fall apart without the upper layers
*** apial is not a source of sensory input; a source of higher stuff
** questions
- similarity of mouse S1 and M1? L4?
- yfrac dep of density+conns (eg. L23 -> L5B CSP)
- inhib connectivity
* 15mar10 Hybrid network with izhi and detailed PT cells
** Sam chat

samn [2:52 PM]
salvadord: i put simplified model with good params into /usr/site/nrniv/local/python/SPI6.py
note that some params such as na,k reversal potential, celsius were based on ben's in vitro conditions
celsius of 34
most have temp dependence, some may need adjust
BK has no temp dependence
same with h_kole.mod which was derived from in vitro @ 34
34 close enough to 37
k, so that's good...so we can adjust ena, ek for in viv
and can add an inviv invit function to toggle ena,ek

updated params for /usr/site/nrniv/local/hoc/PTcell.hoc /usr/site/nrniv/local/python/PTcell.py
will see about ena,ek,celsius - what effect they have
as expected ena,ek,celsius,epas have a big effect on firing rates
bill: so maybe don't move them?
don't have to if we're ok with in vitro - style param values
& if we call network sim in vitro rather than in vivo

billl: well no one knows what the differences are really -- main diff invivo would presumably be the greater syn background activity but we often put that into all our sims

samn [5:18 PM]
true, though ben knew na,k concentrations which he used for calcs; i'm ok with leaving the ena,ek,epas as they are

billl [5:24 PM]
yes he knew his in vit but we don't know the in vivo ones

samn [5:32 PM]
makes sense
** testing implementation with MC SPI cells
- Initial implementation of conns:
-- use existing conn inside Cell
-- sec: can contain multiple sections or sectionLists
-- synMech: AMPA
-- synsPerConn: fixed initially but could be dist (eg. gauss, uniform)

- for now can just provide single synList

- if synsPerConn > 1, distribute across 1st N sections in sectList, at loc 0.5 (simple adhoc implementation)

- creates synapses if required

- testing on m1/sim/params/M1_yfrac_hybrid.py

- sam: I put simplified model with good params into /usr/site/nrniv/local/python/SPI6.py
- sam: updated params for /usr/site/nrniv/local/hoc/PTcell.hoc /usr/site/nrniv/local/python/PTcell.py

*** Izhi
- create single syn with proportional weight

- 30x30 um:
  Run time: 1.16 s
  Simulated time: 1-s; 101 cells; 1 workers
  Spikes: 2918 (28.89 Hz)
  Connections: 542 (5.37 per cell)


*** HH_6comp
- no background inputs; net conns target 5 use synsPerConn, with sec='alldend' = ['Adend1', 'Adend2', 'Adend3', 'Bdend']
- calibrate scale conn weight using single background input - compared with izhi:
-- izhi IB weight for single spike with single netcon spike input: 0.0005
-- 6-comp weight (soma) for single spike with single netcon spike input: 0.6
-- 6-comp weight (Adend1) for single spike with single netcon spike input: 0.4
-- Approx scaling weight diffrence = 100

- 30x30 um:
Analyzing...
  Run time: 2.14 s
  Simulated time: 1-s; 101 cells; 1 workers
  Spikes: 2951 (29.22 Hz)
  Connections: 574 (5.68 per cell)

*** HH_full
  Run time: 43.95 s
  Simulated time: 1-s; 101 cells; 8 workers
  Spikes: 2996 (29.66 Hz)
  Connections: 574 (5.68 per cell)


*** adapting syn weights
- params same as used in m1 dyst except:
-- make exc -> AMPA and NMDA with wNMDA=0.1*wAMPA
-- exc -> apical (DONT CHANGE THIS! - PETREANU AND SUTER SHOW ON BOTH)
-- inh -> apical+basal


** Testing 200x200 um network for different cell types
*** netpyne version
0.3.7

commit a2baba413d8a540d27a8327b8f8fc36c2ffa06eb
Author: salvadord <salvadordura@gmail.com>
Date:   Tue Mar 15 22:28:02 2016 -0400

    added temporary features to get sims working for report
*** Izhi
**** Starting params
 changeset:   360:40df9ecfba9c
netParams['scaleConnWeightModels'] = {'Izhi2007b': 0.0001
netParams['defaultDelay'] = 2.0 # default conn delay (ms)
netParams['propVelocity'] = 100.0 # propagation velocity (um/ms)
netParams['probLambda'] = 100.0  # length constant (lambda) for connection probability decay (um)

netParams['popParams'].append({'popLabel': 'background_E', 'cellModel': 'NetStim', 'rate': 20, 'noise': 0.5, 'source': 'random'})  # background inputs to Exc
netParams['popParams'].append({'popLabel': 'background_I', 'cellModel': 'NetStim', 'rate': 20, 'noise': 0.5, 'source': 'random'})  # background inputs to Inh

netParams['ItoIweight'] = 0.1

synWeightFraction = [0.9, 0.1]

netParams['connParams'].append({'preTags': {'popLabel': 'background_E'}, # background -> E IT,CT
'postTags': {'cellType': ['IT','CT']},
'synMech': 'NMDA',
'weight': 0.0001,
'delay': 'max(defaultDelay, gauss(5,3))'})

netParams['connParams'].append({'preTags': {'popLabel': 'background_E'}, # background -> E PT
'postTags': {'cellType': ['PT']},
'synMech': 'NMDA',
'weight': 0.0001,
'delay': 'max(defaultDelay, gauss(5,3))'})

netParams['connParams'].append({'preTags': {'popLabel': 'background_I'}, # background -> I PV
'postTags': {'cellType': ['PV']},
'synMech': 'NMDA',
'weight': 0.0001,
'delay': 'max(defaultDelay, gauss(5,3))'})

netParams['connParams'].append({'preTags': {'popLabel': 'background_I'}, # background -> I SOM
'postTags': {'cellType': ['SOM']},
'synMech': 'NMDA',
'weight': 0.00003,
'delay': 'max(defaultDelay, gauss(5,3))'})

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_210730.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_210753.png][fig]]

  Run time: 4.77 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11644 (9.78 Hz)
  Connections: 121143 (101.80 per cell)


**** synWeightFraction = [1.0, 0.0]
changeset:   361:6c5cb8720e15

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_211417.png][fig]]

  Run time: 5.13 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 12400 (10.42 Hz)
  Connections: 121143 (101.80 per cell)

**** EtoPTweightFactor = 0.2 (keep)
changeset:   362:f854d0aafed4
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_212054.png][fig]]

  Run time: 5.74 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11095 (9.32 Hz)
  Connections: 121143 (101.80 per cell)
Plotting raster...

**** synWeightFraction = [1.0, 0.1]
changeset:   363:dcfde1f927c1

  Run time: 4.83 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11353 (9.54 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_212559.png][fig]]

**** 'Izhi2007b': 0.0002 (dec rate)
changeset:   364:b930b9c74d29

  Run time: 4.82 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 7379 (6.20 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_213053.png][fig]]

**** 'Izhi2007b': 0.00005 (inc rate)
changeset:   365:a413cc642a13
  Run time: 6.61 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 19436 (16.33 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_214857.png][fig]]

**** minDelay = 5 (inc sync) (keep)
changeset:   366:cf98f03ab779
  Run time: 4.83 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11394 (9.57 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_215811.png][fig]]


**** propVelocity = 200 (keep)
changeset:   367:88c41668f05a

  Run time: 4.82 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11605 (9.75 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_220608.png][fig]]

**** propVelocity = 400
changeset:   368:6ee9d7dba884
  Run time: 4.65 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 11403 (9.58 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_220909.png][fig]]

**** propLambda = 200 (more inh, dec rate, inc sync)
changeset:   369:651976b17786
  Run time: 4.81 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 7049 (5.92 Hz)
  Connections: 143089 (120.24 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_221543.png][fig]]

**** propLambda = 50 (less inh, inc rate, dec sync)
changeset:   370:50e62d515794
  Run time: 4.85 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23562 (19.80 Hz)
  Connections: 104400 (87.73 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_222107.png][fig]]

**** bkg noise = 0.1
changeset:   371:30fc206f9001
  Run time: 5.13 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 12219 (10.27 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_222425.png][fig]]

**** bkg E rate = 40 (keep)
changeset:   372:99569205ec05
  Run time: 6.30 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 16883 (14.19 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_223625.png][fig]]

**** bkg I rate = 10 (keep)
changeset:   373:4933b91fa664
  Run time: 4.91 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 17524 (14.73 Hz)
  Connections: 121143 (101.80 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_224708.png][fig]]

**** netParams['ItoIweight'] = 0.2 (dec rate)
changeset:   374:bbf6f3ef85ce
  Run time: 4.78 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 12919 (10.86 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_225630.png][fig]]

**** bkg IT,CT w=0.0002 (keep)
changeset:   375:20974e02e07b
  Run time: 5.04 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 18184 (15.28 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_225949.png][fig]]


**** bkg PT w=0.0002
changeset:   376:b2db213326e2
  Run time: 4.63 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 18465 (15.52 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_230243.png][fig]]


**** bkg PV w = 0.00005 (slight less sync)
changeset:   377:2951ace96764
  Run time: 4.72 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 17776 (14.94 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_231234.png][fig]]


**** bkg SOM w = 0.00001 (less sync)
changeset:   378:cdb6ef7aa9ac
  Run time: 5.50 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 18418 (15.48 Hz)
  Connections: 121143 (101.80 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_231604.png][fig]]

**** Izhi07b= 0.00005 + propLambda = 50
changeset:   379:a85e1247728d
  Run time: 4.95 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 35530 (29.86 Hz)
  Connections: 104400 (87.73 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_231826.png][fig]]

**** 200x200 um (keep)
changeset:   380:b3ffb1ebfd6d
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 38163 (8.00 Hz)
  Connections: 1806254 (378.83 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_232558.png][fig]]

**** defaultDelay = 3 (increased freq of osc)
changeset:   381:421ca864ee6a
Run time: 24.18 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 36525 (7.66 Hz)
  Connections: 1806254 (378.83 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_233513.png][fig]]


**** propVelocity = 500
changeset:   382:e86658a314c0
  Run time: 24.84 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 38188 (8.01 Hz)
  Connections: 1806254 (378.83 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160315_234736.png][fig]]


**** Izhi07b= 0.00005 (keep)
changeset:   383:623b0575da37
  Run time: 22.95 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 55166 (11.57 Hz)
  Connections: 1806254 (378.83 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_000151.png][fig]]

**** Izhi07b= 0.00001
changeset:   384:c2eb05c521f0
  Run time: 30.11 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 133711 (28.04 Hz)
  Connections: 1806254 (378.83 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_001626.png][fig]]

*** 6-comp
**** starting
changeset:   385:ca440f3f396c (bug)
changeset:   387:423fc7e2f19e (bug)

same as:
 Izhi07b= 0.00005 (keep)
changeset:   383:623b0575da37

100x100 um

'HH_6comp': 0.005

netParams['connParams'].append({'preTags': {'popLabel': 'background_E'}, # background -> E PT (Adend1)
'postTags': {'cellType': ['PT']},
'connFunc': 'fullConn',
'synReceptor': 'NMDA',
'weight': 0.01,
'delay': 'max(defaultDelay, gauss(5,3))',
'sec': 'soma'})

  Run time: 7.25 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 22970 (19.30 Hz)
  Connections: 146775 (123.34 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_011926.png][fig]]


**** 'HH_6comp': 0.001
changeset:   386:dd7ef3e01dca (bug)
390:09fe497c0125
 Run time: 7.25 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 22953 (19.29 Hz)
  Connections: 146775 (123.34 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_011618.png][fig]]

**** 'HH_6comp': 0.0002

changeset:   392:431a1ede0d3a
  Run time: 7.30 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 22779 (19.14 Hz)
  Connections: 146775 (123.34 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_012559.png][fig]]

**** bkg PT w = 0.1

  Run time: 8.52 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 22866 (19.22 Hz)
  Connections: 146775 (123.34 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_013116.png][fig]]

**** EtoPTweightFactor = 1.0
changeset:   394:9e904b543450
  Run time: 10.12 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23212 (19.51 Hz)
  Connections: 146775 (123.34 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_014317.png][fig]]


**** HH_6comp: 0.01
changeset:   396:056950c003aa

  Run time: 7.67 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23526 (19.77 Hz)
  Connections: 146775 (123.34 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_014629.png][fig]]

**** HH_6comp: 0.01
changeset:   397:5846eb3349b2
Analyzing...
  Run time: 7.29 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 22416 (18.84 Hz)
  Connections: 146775 (123.34 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_014814.png][fig]]

**** HH_6comp: 0.0
changeset:   398:9f56f2dee8c8
  Run time: 8.78 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23012 (19.34 Hz)
  Connections: 146775 (123.34 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_015222.png][fig]]

**** HH_6comp: 0.0 + bkg PT w = 0.1
changeset:   398:9f56f2dee8c8

  Run time: 8.55 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23183 (19.48 Hz)
  Connections: 146775 (123.34 per cell)
Plotting raster...

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_015545.png][fig]]

**** HH_6comp: 100x100, wfactor=0.0015, bkg PT w=0.006, Adend1 (keep)
changeset:   400:47c0fd02b2a4

  Run time: 7.05 s
  Simulated time: 1-s; 1190 cells; 8 workers
  Spikes: 23517 (19.76 Hz)
  Connections: 146775 (123.34 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_020832.png][fig]]


**** 200x200 um (keep)
changeset:   388:9fde2019c74b bug
changeset:   401:717b76f9ffc8

  Run time: 40.09 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 55220 (11.58 Hz)
  Connections: 2134738 (447.72 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_021524.png][fig]]


**** bk PT w= 0.005 (keep)
changeset:   402:d54dc3fbde7d
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 57506 (12.06 Hz)
  Connections: 2134738 (447.72 per cell)

  Run time: 39.96 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 57506 (12.06 Hz)
  Connections: 2134738 (447.72 per cell)

  Run time: 46.09 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 57506 (12.06 Hz)
  Connections: 2134738 (447.72 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_131409.png][fig]]


*** full
**** starting - 50x50
changeset:   405:148ce723294c

same params as for last 6comp: changeset:   402:d54dc3fbde7d
netParams['scaleConnWeightModels'] = {'Izhi2007b': 0.00005, 'HH_6comp': 0.0015, 'HH_full': 0.0015}
netParams['defaultDelay'] = 5.0 # default conn delay (ms)
netParams['propVelocity'] = 500.0 # propagation velocity (um/ms)
netParams['probLambda'] = 100.0  # length constant (lambda) for connection probability decay (um)
synWeightFraction = [0.9, 0.1]
EtoPTweightFactor = 0.2
netParams['ItoIweight'] = 0.1

netParams['connParams'].append({'preTags': {'popLabel': 'background_E'}, # background -> E PT (Adend1)
'postTags': {'cellType': ['PT']},
'connFunc': 'fullConn',
'synReceptor': 'NMDA',
'weight': 0.005,
'delay': 'max(defaultDelay, gauss(5,3))',
'sec': 'soma'})

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_202217.png][fig]]

  Run time: 112.56 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10571 (36.20 Hz)
  Connections: 9198 (31.50 per cell)
Plotting raster...

**** 200x200
changeset:   407:a63fe9d8207c

  Run time: 3660.64 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 51127 (10.72 Hz)
  Connections: 2134738 (447.72 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_214103.png][fig]]

**** bk weight PT 0.01, 50x50
changeset:   408:ceefccf59cdc
  Run time: 118.42 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10052 (34.42 Hz)
  Connections: 9198 (31.50 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_215959.png][fig]]


**** bk weight 0.001
changeset:   409:ddc2a218f503
  Run time: 101.87 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10147 (34.75 Hz)
  Connections: 9198 (31.50 per cell)
Plotting raster...

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_220459.png][fig]]

**** bk weight 0.0025
changeset:   410:9a04f3d78c26
  Run time: 106.02 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10323 (35.35 Hz)
  Connections: 9198 (31.50 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_221448.png][fig]]

**** w scale factor HH_full: 0.0010
changeset:   411:2ef8878a1126
  Run time: 100.55 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10620 (36.37 Hz)
  Connections: 9198 (31.50 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_222412.png][fig]]

**** w scale fac = 0.0001
changeset:   412:781ac7303439
  Run time: 102.17 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10070 (34.49 Hz)
  Connections: 9198 (31.50 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_223029.png][fig]]

**** w scale fac = 0.0075
changeset:   413:c7b4ad2037bf
  Run time: 101.24 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 9928 (34.00 Hz)
  Connections: 9198 (31.50 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_223918.png][fig]]


**** bkg PT dend_1 instead of soma
changeset:   414:f623f9cd81bb
  Run time: 106.78 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10083 (34.53 Hz)
  Connections: 9198 (31.50 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_225317.png][fig]]

**** test only bkg
soma: 'weight': 0.005
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_225757.png][fig]]

'weight': 0.0075
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_230042.png][fig]]

'weight': 0.01
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_230939.png][fig]]

**** bkg w 0.0075; scale fac = 0.0015
changeset:   416:d7579c4cad81
  Run time: 103.69 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10130 (34.69 Hz)
  Connections: 9198 (31.50 per cell)

PT few spikes at the beginning then die off

**** bkg w 0.0075; scale fac = 0.0005 (keep)
changeset:   417:6a6696fbe6eb
  Run time: 103.85 s
  Simulated time: 1-s; 292 cells; 8 workers
  Spikes: 10616 (36.36 Hz)
  Connections: 9198 (31.50 per cell)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160316_232025.png][fig]]


**** 200x200  (keep)
changeset:   417:6a6696fbe6eb
  Run time: 3017.59 s
  Simulated time: 1-s; 4768 cells; 8 workers
  Spikes: 51709 (10.85 Hz)
  Connections: 2134738 (447.72 per cell)

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160317_002142.png][fig]]

** compare with m1 dyst model
*** syns
tau1NMDAEE=15; tau2NMDAEE=150;
tau1NMDAEI=15; tau2NMDAEI=150;
erevgaba = -80

- FS
def set_synapses(self):
    self.somaGABAf=Synapse(sect=self.soma,loc=0.5,tau1=0.07,tau2=9.1,e=-80);#self.dSy['somaGABAf']=self.somaGABAf;
    self.somaGABAss=Synapse(sect=self.soma,loc=0.5,tau1=20,tau2=40,e=-80);#self.dSy['somaGABAss']=self.somaGABAss;
    if STDP:
      self.somaAMPA=SynapseSTDP(sect=self.soma,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)
      self.somaNMDA=SynapseNMDA(sect=self.soma,loc=0.5, tau1NMDA=tau1NMDAEI,tau2NMDA=tau2NMDAEI,r=1,e=0);
    elif AMNMCA:
      self.somaAMPA=SynapseAMPACA(sect=self.soma,loc=0.5,e=0)
      self.somaNMDA=SynapseNMDACA(sect=self.soma,loc=0.5,e=0)
    else:
      self.somaAMPA=Synapse(sect=self.soma,loc=0.5,tau1=0.05,tau2=5.3,e=0);#self.dSy['somaAMPAf']=self.somaAMPAf;
      self.somaNMDA=SynapseNMDA(sect=self.soma,loc=0.5, tau1NMDA=tau1NMDAEI,tau2NMDA=tau2NMDAEI,r=1,e=0);

- LTS
def set_synapses(self):
    self.somaGABAf 	= Synapse(sect=self.soma, loc=0.5, tau1=0.07, tau2=9.1, e=-80)
    self.somaGABAss	= Synapse(    sect=self.soma, loc=0.5, tau1=20,	  tau2=40, e=-80)#originally for septal input
    if STDP:
      self.somaAMPA = SynapseSTDP(sect=self.soma,loc=0.5,tau=5.35,e=0,dtau=34,ptau=17,d=0.5,p=0.5)
      self.somaNMDA = SynapseNMDA(sect=self.soma, loc=0.5, tau1NMDA=tau1NMDAEI, tau2NMDA=tau2NMDAEI, r=1, e=0)
    elif AMNMCA:
      self.somaAMPA=SynapseAMPACA(sect=self.soma,loc=0.5,e=0)
      self.somaNMDA=SynapseNMDACA(sect=self.soma,loc=0.5,e=0)
    else:
      self.somaAMPA 	= Synapse(    sect=self.soma, loc=0.5, tau1=0.05, tau2=5.3, e=0)
      self.somaNMDA 	= SynapseNMDA(sect=self.soma, loc=0.5, tau1NMDA=tau1NMDAEI, tau2NMDA=tau2NMDAEI, r=1, e=0)

- PYR
    self.somaGABAf = Synapse(sect=self.soma,loc=0.5,tau1=0.07,tau2=9.1,e=erevgaba)
    self.somaAMPA = Synapse(sect=self.soma,loc=0.5,tau1=0.05,tau2=5.3,e=0)

    bdsyloc = 0.5
    self.BdendAMPA = Synapse(sect=self.Bdend,loc=bdsyloc,tau1=0.05, tau2=5.3,e=0)
    self.BdendNMDA = SynapseNMDA(sect=self.Bdend,loc=bdsyloc,tau1NMDA=tau1NMDAEE,tau2NMDA=tau2NMDAEE,r=1,e=0)

    self.Adend1GABAs = Synapse(sect=self.Adend1,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
    self.Adend2GABAs = Synapse(sect=self.Adend2,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
    self.Adend3GABAs = Synapse(sect=self.Adend3,loc=0.5,tau1=0.2,tau2=20,e=erevgaba)
    self.Adend3GABAf = Synapse(sect=self.Adend3,loc=0.5,tau1=0.07,tau2=9.1,e=erevgaba)

    self.Adend3AMPA = Synapse(sect=self.Adend3,loc=0.5,tau1=0.05,tau2=5.3,e=0)
    self.Adend3NMDA = SynapseNMDA(sect=self.Adend3,loc=0.5,tau1NMDA=tau1NMDAEE,tau2NMDA=tau2NMDAEE,r=1,e=0)

    self.Adend2AMPA = Synapse(sect=self.Adend2,loc=0.5,tau1=0.05,tau2=5.3,e=0)
    self.Adend2NMDA = SynapseNMDA(sect=self.Adend2,loc=0.5,tau1NMDA=tau1NMDAEE,tau2NMDA=tau2NMDAEE,r=1,e=0)

    self.Adend1AMPA = Synapse(sect=self.Adend1,loc=0.5,tau1=0.05,tau2=5.3,e=0)
    self.Adend1NMDA = SynapseNMDA(sect=self.Adend1,loc=0.5,tau1NMDA=tau1NMDAEE,tau2NMDA=tau2NMDAEE,r=1,e=0)

    self.Adend3mGLUR = SynapsemGLUR(sect=self.Adend3,loc=0.5)
    self.Adend3GABAB = SynapseGABAB(sect=self.Adend3,loc=0.5)

    self.Adend2mGLUR = SynapsemGLUR(sect=self.Adend2,loc=0.5)
    self.Adend2GABAB = SynapseGABAB(sect=self.Adend2,loc=0.5)

    self.Adend1mGLUR = SynapsemGLUR(sect=self.Adend1,loc=0.5)
    self.Adend1GABAB = SynapseGABAB(sect=self.Adend1,loc=0.5)

*** syn.py code
from neuron import h

# metabotropic glutamate receptor
class SynapsemGLUR:
  def __init__(self,sect,loc):
    self.syn = h.mGLUR(loc, sec=sect)

# AMPA synapse with calcium influx -- mechanism defined in mod/ampa_forti.mod
class SynapseAMPACA:
  def __init__(self, sect, loc, e):
    self.syn		= h.AmpaSyn(loc, sec=sect)
    self.syn.e		= e

# NMDA synapse with calcium influx -- mechanism defined in mod/nmda_andr.mod
class SynapseNMDACA:
  def __init__(self, sect, loc, e):
    self.syn		= h.NmdaSyn(loc, sec=sect)
    self.syn.e		= e

class Synapse:
  def __init__(self, sect, loc, tau1, tau2, e):
    self.syn		= h.MyExp2SynBB(loc, sec=sect)
    self.syn.tau1	= tau1
    self.syn.tau2	= tau2
    self.syn.e		= e

class SynapseNMDA:
  def __init__(self, sect, loc, tau1NMDA, tau2NMDA, r, e):
    self.syn			= h.MyExp2SynNMDABB(loc, sec=sect)
    self.syn.tau1NMDA	= tau1NMDA
    self.syn.tau2NMDA	= tau2NMDA
    self.syn.r			= r
    self.syn.e			= e

# gabab based on 1995 PNAS paper by Destexhe
class SynapseGABAB:
  def __init__(self, sect, loc):
    self.syn = h.GABAB(loc, sec=sect)

class SynapseSTDP:
  def __init__(self, sect, loc, tau, e, dtau, ptau, d, p):
    self.syn	= h.ExpSynSTDP(loc, sec=sect)
    self.syn.tau    = tau
    self.syn.e     	= e
    self.syn.dtau	= dtau
    self.syn.ptau	= ptau
    self.syn.d      = d
    self.syn.p      = p

* 15may16 Integrating CSTR (L5 IT cells) in network model
** files from sam
STR cell in /usr/site/nrniv/local/hoc/ITcell.hoc /usr/site/nrniv/local/python/ITcell.py
relies on a bunch of ion channel mod files in /usr/site/nrniv/local/mod
see /u/samn/evoizhi mod subdir for the ones included
** list of mod files in /u/samn/evoizhi
A.mod	      clampex.mod@  h_BS.mod@	     IC.mod@	  kdmc_BS.mod@	MyExp2SynBB.mod@      NMDAr.mod		parameters.multi~
AMPA.mod      cp2.mod@	    h_harnett.mod@   IL3.mod@	  kdr2.mod	MyExp2SynNMDABB.mod@  nstim.mod@	pregencv.mod@
AMPAr.mod     cp.mod@	    h_kole.mod@      IL.mod@	  kdr_BS.mod@	naf2.mod	      nthh.mod@		samnutils.mod@
cadad.mod@    GABAa.mod     h.mod@	     izhi.mod	  kmbg.mod	nap.mod		      ntIh.mod@		savedist.mod
cagk.mod      GABAar.mod    H.mod@	     izhi.mod~	  km.mod@	nax_BS.mod@	      ntt.mod@		stats.mod@
cal_mig.mod@  gabab.mod@    h_winograd.mod@  kap_BS.mod@  kv.mod@	naz.mod@	      OFThpo.mod@	vecst.mod@
can_mig.mod@  GABAb.mod     Iahp.mod@	     kBK.mod@	  mglur.mod@	Nca.mod@	      OFThresh.mod@	x86_64/
cat_mig.mod@  GABAbr.mod    Ican.mod@	     kca.mod@	  misc.mod@	NMDA.mod	      parameters.multi
** table of channels (by ben)
Oh I was just checking the channels and such for the SPI model, made this:

[1:36]
soma    axon    apical  basal
======================================
pas    x    x    x       x
dist    x    x    x    x

na_ion    x    x    x    x
nax    x    x    x    x

k_ion    x    x    x    x
kdr    x    x    x    x
kap    x    x    x    x
kdmc    x    x    No    No

ca_ion    x    No    x    x
cadad    x    No    x    x
cal    x    No    x    x
can    x    No    x    x
kBK    x    No    x    x

h    x    x    x    x
(h, or ih, or h15; non-uniform)


savedist.mod
nax_BS.mod
kdr_BS.mod
kap_BS.mod
kdmc_BS.mod
cadad.mod
cal_mig.mod
can_mig.mod
(cat_mig.mod)
kBK.mod
h_BS.mod / h_kole.mod / h_harnett.mod
** suggestion to tune IT cell (by ben)
My suggestion was to start by using the exact same PTcell.hoc model and re-run the optimization to see if it can reproduce
the firing with the same complement of channels, just changing the densities
** advice to test IT in net (by ben)
testing IT in network: my advice if you want a quick fix is to simply use the PTcell models but set their Ih density to zero
(or very low) and decrease g_pas (this should do two things: first it would counter-act the hyperpolarized resting Vm caused
by removing Ih, and second it will increase the input resistance, which is one key difference between IT and PT)
** error when load more than 1 full morph (eg. IT + PT)
- need to remove from memory prev one

* 16may18 Chicago meeting
** morning meeting
- not much ih - sheets
- str tufts idea?
- exciting areas that cnat do experimentally:

1) short-term plasticity (25-50 100max ms) of synapses
- markram has reviews
- conn is single shot - abs or relative strength of conns
- 2 rapid stimuli, 2nd one can be different
- in cx monosyn exc->exc conns are depressing (connors), + thalamocortical
- anteriro motor region (ALM) - L2/3 outputs facilitating instead of depressing
- different from layer 2/3
- L2/3 is expanded in primates - make big deal
- short term facilitation as working memory

- output of L2/3 - contra collosally L2/3+L5 facilitation
- L2->L3 paired recordings difficult to measure plasticity
- indepednent of IT subtype/location
- anterior frontal cortex L2/3->5 depress a little bit -  Qiu
- auditory paper
- L2/3 -> PT non-depressing; L2/3-> IT depressing
- just L2 might be only facilitating
- ca depdendent pre-synaptic mediated
- high or low release prob, and goes opposite on 2nd hit
- synaptotegmin 6 7 is the crucial protein involved in short-term facilitation
- in the calcium sensitive
- can be pre or post synaptic - ca1 or ca3 synapse
- peter jonas has huge hippocampus model

- schizophrenia could be related to short term plasticity; L2/3

- plasticity of E->I , E->E, I->I in dynamic circuits; as function of of ...
- L2/3 mostly quiescent (1 or 2 spks)
- exciting direction

2) Incorporating in-vivo stuff
- 50um channel 32 channel, linear array, 4 simultaneous
- across collosum; M1, thalamus; M1 contralateral
- plus 4 optical fibers to stimulate
- retrosplineal cortex (behind splinium; huge area; ouflow from dorsal hippocampus; head direction; spatial
  memory+navigation; lesions leasds to disorientation) to motor cx
- in vivo version of circuit mapping
- in vivo should be predictable from in vitro circuit
- confounded by spikes in the axons
- need long range connections from thalamus; and interhemispheric
- what happens when you activate inputs from different regions (S2, thalamus)
- shalum brown - claustrum
- incorporate long-range connectivity from Ben's paper - main inputs:
-- Thalamus
-- M2 -> L1
-- S2 contralateral
-- M1 contralateral
-- Retrospinal only to small segment (vibrisal)
-- VM -> only layer 1

- Naoki corticothalamic paper - CT is least connected
- CTs dont get much input from thalamus, compared ot PT and IT
- CT output to thalamus doenst go strongly to main nucleus -> VL
- CT -> PO, RTN
- implications  TC loops in motor sysmte (mayeb sensory); no dysinaptic, obligatorily polysynaptic, involves multiple
  thalamic nuclei
- classic matrix ->L1
- classic core -> L4?
- VL -> L1 of frontal areas
- VM -> frontomedial
- how to model long range inputs? firing rates? need feedback?

- data from Ben - S2, CT, scracm maps - L1
- increase the drive from these regions - with and without ih

- look at 2 inputs to M1, varying the time lag;
- weak stimulus to retrosplineal and S2 - but go 2 different regions;
- thalamus and S2 maybe? or do all 3?
- look at interaction
- dual input experiment - vary timing and look at summation with/without ih (IT vs PT) !! - main priority

- purely M1 ? ih effect sheets paper fig 11?
- IT inputs - local, but similar paradigm
- effect biggest on PTs
- during ongoing activity - spiking output depends on ih current (for same input) - if blocked higher firing
- apical tuft is basically disconnected
- why? narrows temporal integration window (high pass filter) - more temporal summation
- chirp just ot characterize resonanace; but not physiological
- no effect in resting potential
- can do in single cell - with inputs
- 2nd order question: hwo does synaptic distribution affect this results? use sCRACM maps
- striatal show higher EPSPs but fire very little
- view from soma is distorted (best but still not very good)
- more dendritic effects than somatic

- tuning M1 circuit? firing rates?
- no in vivo firing rates for M1; only S1
- sachman's has barrel cortex - best system to get numbers
- L2/3 and L6 quasi silent (CT), IT not looked at in detail

- optogenetic - Weiler + Anderson?
- good to validate

- Sheets + kiritani  IT->PT - incorporate
- Naoki's thalamocortical - disconnected CT cells
- I->I SOM different to PV

- jarjan in vivo
- lory - patchign
- other fuy? -facilitation

** afternoon meeting
- backpropagation - important, check
- rate of propagation - how fast wave spreads
- compare to waht has been measureed - mostly rat - ben johnson

- hcl is not 0 in basal (sheets paper)
- channel effect maps of glutamate uncaging- biggest relative change in apicals; absolute in basals (large % of dendritic
  length)
- not to have gradient in basals ok
- floor around 0.002 (fig 8c)
- wouldnt reproduce zd in sheets paper

- ih models exist - sobermayer?

- L2/3 + L6 - low firing rate
- L2/3 and L4 lower RMPs - fire less
- less local; but plenty of long range
- if thalamus modeled need feedback to thalamus
- 2 regimes of utility:
- try to emulate real invivo
- auxiliary tool bridge from invitro -> in vivo - how connections translate

- cre lines for IT,PT,CT

- scracm of M2, thalamus, S2 and M! contralateral, L2/3
- laminar profiles - S2
- thalamus and m1 go to layer 1; others don't

- Thalamus -> L5 PT (randy bruno) - not necessarily through L2/3; only engaging PT without influencing the IT dominated
- Böhm, Schmidt jneuroscience 2016 - subiculum (IT-RS and PT-Burst equivalent)
- IT dominated if ih is high (noradrenaline control) - PTs only listening
- opposite long range driving the PTs; but doesn't involve IT
- dissociation of activity in IT and PT
- quadruple recordings showed 0 or 1/100s (PT->IT)

- focus on the relevant details
** notes by sam
SPI vs STR cells - in/out transforms

short-term plasticity (100 ms?) -- Markram, connectivity -- single-shot 1 spike relative strengths of connections; multiple
outputs amplitude changes;

classical view: E connections and thalamocortical inputs -- depressing in neocortex (connors).  ALM - anteriolateral motor
cortex (studied by svoboda) - L2/3 outputs look like they are facilitating (not depressing) - a lot of interest in human L2/3
(since expanded in human; primate researchers interested in this expansion) - GMGS has done optogenetically - showing the
facilitating responses of L2/3 neurons. so, a lot of interest in facilitating responses for working memory.

STDP/RL - already implemented - so easy to use if needed

direction suggested by GMGS: short term plasticity in motor cortex. L2/3 are IT (project across callosum - also have
ipsilateral projections) GMGS did paired-pulse ratios (50 ms interval; 2nd pulse produces larger amplitude response -- used
channelrhodopsin; real glutamate release via optogenetic activation). L2/3 innervates multiple cells across
layers. facilitation is independent of IT sub-type (and hence location) on postsynaptitc side. think it holds for ipsilateral
side. interested if it's a frontal area feature. have transgenic lines that label L2/3 cells (doesn't label very well; other
complications and whether the facilitation is an artifact of the genetic line). in utero electroporation allows targeting to
L2/3. very different from what was described before for corticocortical connections.

question of whether it's just the uppermost L2/3 cells. they've done reasonably old mice so not a developmental issue. then a
question of what the effect is on the whole circuit, ie some connections depress but L2/3 facilitates giving a unique role
for that layer in info processing.

L2/3 -> PT were not depressing; L2/3 -> IT were depressing. But within L2/3 were facilitating. presumably calcium dependent
on presynaptic side (calcium accumulation). changing release probability.

molecular cascades - synaptotagmin - crucial protein involved in short term facilitation. in calcium sensitive process. had
knockout mice where facilitation was abolished. can be pre- or post-synaptic. property of CA3 -> CA1 synapse (schaffer
collateral, facilitating synapse with same mechanism). peter jonas has done a lot of work on this (where ben went to
work). jonas has a computer model of hippocampus based on this connectivity data.

STP - for E->E schizophrenia - failure of paired pulse inhibition (PPI) maybe relates to the facilitation in L2/3; PPI mostly
done in auditory areas. 10s of milliseconds (STP timescale); would be nice to know STP properties for all synaptic
connections in the circuit (E->I, I->E, IT/PT, PV/SOM/VIP on inhibitory side). L2/3 cells inactive in rodents (not known in
primates). in rodents L2/3 fire 1-2 spikes in sensory cortex.

GMGS also doing some linear probe work. einevoll modeled the LFP.

now gmgs has in vivo work too - 32 channel 50 micron spacing linear silicon probes. can get cortex as well as
thalamus. across hemispheres (callosum; can do motor thalamus, and/or sensory cortex too). up to 4 optical fibers to
stimulate. usually just need 2 (retrosplenial cortex to motor cortex). retrosplenial cortex (behind splenium) in rodents
extends more anteriorally (more elaborate in primates), gets outflow from dorsal hippocampus (has some head direction cells;
involved in aspects of spatial memory; humans with lesions there have disorientation - recognize landmarks but cannot use the
information to navigate). very inaccessible but easier to get to in rodents. has connections with thalamus and motor cortex
too.  that's an in vivo version of circuit mapping experiment. put channelrhodopsin + virus in one area and projections get
labeled; then stimulate retrosplenial followed by postsynaptic activation and in vitro circuit mapping should predict the in
vivo response (if in vitro is good 'model' / consistent with in vivo).

if had good motor cortex circuit model (all right local and long range connections [ie thalamocortical and interhemispheric])
-- can use model to compare activation of thalamus or M2 ... long-range input connections...

Interesting combination of themes for modeling:
 1. STP (ie in L2/3 for facilitation).
 2. long-range inputs (thalamus -- goes to most medial part of motor cortex)

what goes to L1? some thalamic -> M1 L1; known in detail (ben's data); M2 (premotor) goes to L1, so does thalamus in slightly
different sublayer; contralateral and S2 goes lower -- avoids apical tuft. higher order inputs (M2, thalamus) go to
L1. haven't mapped it for IT (but they have only slight apical tufts). so incorporating long-range connectivity into network
model where include the L2/3 facilitating STP. VM goes only to L1.

corticothalamic paper - L6 CT is least connected on both ends of corticothalamic loop (CT input is very weak compared to PT
and multiple types of IT). L6 CTs in motor cortex make weak connections to VL thalamic neurons. CTs in thalamus axons go to
PO,VM,reticular nucleus very strongly. inhibit VL through feedforward inhibition.

thalamocortical loops in motor system - no disynaptic - must be polysynaptic filtered through IT and PT (and many thalamic nuclei involved).

classic thalamic core/matrix (ted jones dichotomy (modulating,driving): matrix -> L1, core -> L4,L5
now saying core and matrix both getting involved in the thalamocortical loop.

MGB - >= 3 nuclei (some more core vs matrix than others)

VL goes to L1 of frontal motor areas. M1 caudal in rodent. ALM gets dense input from VM (could be important for PT).

feedforward and feedback inputs important - for modeling - not just spike inputs

is data for the long-range connectivity available?

corticothalamic also in the ben paper. also in hooks paper.

sCRACM mapping location of synaptic inputs onto dendrites.

modulate drive to different layers with/without Ih.

do they use Ih blockers in vivo? look at 2 inputs to M1 (varying time lags). weak stimulus to thalamus and M2 and/or
retrosplenial and look at interaction between timing of inputs and look at ZD7288 and see how Ih contributes to he
integration of temporal inputs.

replicate sheets paper: discrepancy between effects of ih -- blocking ih and barrage of inputs -- should get more spiking
output -- so why is that occurring? is it a network effect rather than a cellular effect? measure spikes rather than EPSP
(larkum, arnsten, -- amputation of apical dendrite when ih is active -- in SPI cells -- modeling studies that have explored
this -- Larkum, Magee, ... ). so does Ih narrow the window for temporal integration of inputs. so need to reproduce sheets
phenomenology -- not a huge effect on RMP when block Ih -- impression is that it's not a large effect -- should check Ben's
papers to see what the shift in RMP is. driving force could also be involved. since even if RMP moves up then driving force
decreases so EPSPs could be lower. harnett paper showing Kv channel density increasing with distance from soma, so could
interact with HCN channel density.

in vivo firing rates for tuning network model? not available from gmgs. MUAs? only anesthetized in vivo (but still better
than slice?)  barrel cortex may be best model for that kind of information.

gmgs suggests should focus on modeling the main findings:
 1. sheets dependence on ih -- more ih, less spiking output;
 2. kiritani (IT->PT))
 3. naoki - thalamocortical - the disconnected CT neurons

thalamic model currently using izhi cells (two populations)

timing of dual inputs (with different lags) -- and map the
different stimulus locations too -- look at summation with
and without blockade of Ih current; should see the difference
on IT (ih effect not there) vs PT cells (ih effect there)
* 16may25 Talk by Olveczy - M1 involved in learning not skill task
otchy et al nature 2015
homeostatic adaption after removing cortex
skilled reaching task
not required.to engage in task to restore performance
cortex for supination pronation and fingwr movs
but not for reach and grasp
subcortical circuits can perfotm simple and store sequence
motor cx role in learning?
yes! cant learn task if lesiones
motor cortex reprograms subcortical circuits and spnual cord
analogy of iphone
bg to brinstem and thalamus
brainstem to thalamus
motor cx to bg
to dorsolateral
lesion to dls striatum makes animal forget task
lesion to dorsomedial striatum.had no effect
optogenetic to supress input from cx to dls
also leads to inability to learn
m1 is tutoring
but might not be needes after learning
pi and students analogy
dls neurons synced with diff phases of the task
how does motor cx tutor striatum?
how does tlstriatum.change with learning?
role of TC?
RL task so dopamine essential but not clear where
multiple motor xontrollers - M1 BG brainstem
but m1 also teacher
BG lookup table for next mov in seq
send to brainstem which stores motor primitves and sends to spinal.cord
brqinstem tells thalamus action 1 is completed, which gives this info to BG to check lookup table
relearning 700 to 500ms didnt require cortex, and cx lesion didnt affect how fast relearned
bg coordinates diff controllers
corticospinal tract cannot initiate reaching
if remove brainstem or aubcortical.regions have major effects , more than cx
cortex evolut later, adds to fine detail.movements, coordination, and reprogramming of subcortical


salvadord [3:50 PM]
reeeally interesting talk at dmc today by Olveczky on motor cirtcuits and learning - http://olveczkylab.oeb.harvard.edu/publications
summary: "Motor Cortex Is Required for Learning but Not for Executing a Motor Skill" - http://www.cell.com/neuron/abstract/S0896-6273(15)00220-2
rat learned task where had to push lever and 700 ms push again to get reward
if removed completely motor cortex, after recovery could still do task exactly the same, with identical stereotypic movements
without any relearning after removal of cortex
however, if motor cortex was removed initially, rats couldn't learn task
hypothesis is that motor cx is involved in tutorin/teaching subcortical regions, but after that not necessary
task performed by basal ganglia - brainstem - thalamus loop
brainstem stores motor primitives; thalamus provides feedback to BG; BG decides what motor primitive comes next and sends command to brainstem
pointed out that there's and too much emphasis on role of motor cortex in voluntary movements; whereas corticospinal projections only account for ~30% of inputs to spinal cord
cortex only essential for very fine movements such as individual finger movements or supination/pronation
and also seems very involved in learning motor task via corticostriatal path
* 16jun06 Description for web
** template
Project Acronym:  __________
Project Full Title:  __________
Summary:  __________
Start Date:  __________
End Date:  __________
Funding Source:  __________
Principal Investigator(s):  __________
Co-Investigator(s):  __________
Contact(s):  __________
** M1
Project Acronym:  __________

Project Full Title: Microconnectomics of primary motor cortex: a multiscale computer model

Summary:  We will develop a multi-scale model of primary motor cortex (area M1) based on a rich experimental dataset obtained
in ongoing studies. The model will range from the level of ion channels in dendrites, up to the level of the inputs from and
outputs to other areas of cortex, a range of microns to centimeters, with a temporal range of milliseconds to 10 sec. We will
evaluate dynamical interactions across scale, made more complicated by a structure that features long apical dendrites of
Layer 5 pyramidal cells that reach across layers of cortex and thereby across scales. This feature produces complex
structure-function relations: apical dendrites directly process inputs from different cortical layers for export from the
local microcircuit (direct input/output). They also act within the scale hierarchy, forming a component of the local network
which provides a parallel processing of inputs to produce outputs via the entire Layer 5 pyramidal cell ensemble.
The model will help us better understand a variety of diseases, including autism and Parkinson’s disease. In addition, the
model will assist us in understanding the codes of the brain, which will allow us to later develop more sophisticated
prosthetic limbs for the wounded: prosthetics that not only move, but also feel.

Start Date:  09/15/2014

End Date:  05/31/2018

Funding Source:  NIH NIBIB (U01 award)

Principal Investigator(s):  William W. Lytton (SUNY Downstate)

Co-Investigator(s): Gordon M.G. Shepeherd (Northwestern University)

Contact(s):  William W. Lytton (billl@neurosim.downstate.edu)

Hiring: No

Publications: [copy from papers.html]

* 16jun29 Meeting with bill/sam on M1 network
** meeting with bill/sam on networks
- A1 - beta/alpha
- M1 - use to study input/output
- clone m1
- separate conn into other file, and compare yfrac with layer wise
** preparing model
- removed old param versions
- fixed for netpyne version 0.4.9
- fix raster by pop

- update izhi
- test izhi
- test 6-comp
- test full
- distribute syns

* 16aug09 Meeting with Gordon
- L2/3 IT long-range outputs facilitatory responses  - corticortical across calllosum, contralateral
- L5 ITs are depressing
- independent of the target
- short term facilitation involved in short-term memory- interest in motor cortices
- major input from long-range
- presynaptic cell is the specificity

- callosal M1 to contraletaral — L2/3 vs L5 chr2
- pair pulse facilitation and depressing with optogenetics
- any postsyn in motor cortex if comes from L2/3 is facilitating; vs L5 its depressing
- implication is L2/3 drives facilitation and L5 drive depression
- because inputs come from L2/3 and go to L2/3 = reverberating network = activity promoted ; L2/3 also output to other layers
- paper inactivate ALM, lead to reverberant
- short term plasticity
- 2/3 and 5 projects to multiple layers — similar target cells, difference is pattern of plasticity depending on presyn
- paired stimuli to contralateral M1 while recording to test
- interneurons involved too - going to record too
- delay across callosum

- long range inputs - From Ben’s paper - corticospinal, dendritic, use distilled data from paper

* 16sep19 Experimental data to fit/validate network
** firing rates
https://docs.google.com/spreadsheets/d/16ccN583y7D5-aI2_yc92WMTV-33PNWR2EmC3n3WmYg0/edit?usp=sharing
*** gordon comments
- no in vivo firing rates for M1; only S1
- sackman's has barrel cortex - best system to get numbers
- L2/3 and L6 quasi silent (CT), IT not looked at in detail

in general, here's what I think the activity profile is, but there isn't much data to actually back this up ... we've done
some in vivo recordings across layers with a silicon probe (linear array) in anesthetized mice, that are consistent, though

L2/3 -- relatively low activity
L4 -- activity not characterized in motor cortex
L5A, L5B -- relatively high levels of activity
L6 -- intermediate-ish

you can also see if there's anything in the Isomura/Fukai et al paper (2009, Nature Neurosci) and other papers from Fukai's
group
- in vivo firing rates for tuning network model? not available from gmgs. MUAs? only anesthetized in vivo (but still better
than slice?)  barrel cortex may be best model for that kind of information.

*** possible online database sources for single cell
- https://www.maxplanckflorida.org/our-science/our-scientists/bert-sakmann/ ?
- http://physionet.org/physiobank/?
- http://www.neuroelectro.org/ephys_prop/18/data/
- http://www.neuroelectro.org/neuron/111/
- http://www.neuroelectro.org/ephys_prop/35/data/
- Lots of rat data (specially S1) -- eg. Markram 2015, John Choi

*** Janelia suggestions (Druckmann, Svoboda and others)
**** LiDa16 - Robust neuronal dynamics in premotor cortex during motor planning
- mouse ALM region
- ext fig 2c - L5 pyr cells: ~5Hz baseline (n=300)
- activity during sensorimotor tasks
**** LiCh15 - A motor cortex circuit for motor planning and movement
- mouse ALM region
- Ext Fig 1B: L5 FS = ~8Hz contra, ~12 hz ipsi; L5 PYR = ~4.5 Hz
- activity during sensorimotor tasks
**** Jaco12 - Regular spiking and intrinsic bursting pyramidal cells show orthogonal forms of experience-dependent plasticity,
- layer V of barrel cortex (mouse S1,S2; L2/3,4,5A,5B)
- spontaneous activity  for RS cells (10.6 ± 2.2)
-  IB cells (11.8 ± 1.9)
- activity during sensorimotor tasks

**** Hook15 - Dual-channel circuit mapping reveals sensorimotor convergence in the primary motor cortex
- mouse vM1 with stim to vS1; L2/3; in vitro
- When illumination was restricted to L5 axons,􏰆1 AP/trial was evoked at Vrest of 􏰉60 mV (1.01 +- 0.39 APs) or 80 mV (1.06
  +-0.42 APs).
- AP firing was more persistent during somatic illumination (4.17 􏰍 0.95 APs/trial at 􏰉60 mV; 6.28 􏰍 2.69 APs/trial at 􏰉80 mV). N = 8 neurons
**** RahB13 - Thalamocortical input onto layer 5 pyramidal neurons measured using quantitative large-scale array tomography
- mouse S1; L5,4;
- distribution of synapses from thalamic inputs (compares tomography to sCRACM)
**** Isom09 - Microcircuitry coordination of cortical motor information in self-initiation of voluntary movements
- rat M1; L2/3, L5A, L5B, L2I; rest and movement
- superficial: 5.1 ± 6.6 Hz, n = 32
- deep: 8.9 ± 7.3 Hz, n = 38; P < 0.03
- identified layer 2/3: 2.2 ± 2.6 Hz, n = 6
- identified layers 5–6: 9.4 ± 8.6 Hz
- fast-spiking interneurons fired at lower rates in superficial layers than in deep layers, although the difference was not
  substantial
- baseline activity was much lower in regular-spiking neurons and pyramidal cells than in fast- spiking interneurons (max ~40 Hz)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161025_114951.png][fig]]
**** Tsub13 - Neural dynamics and information representation in microcircuits of motor cortex
- interesting high level features about M1 coding
**** others
- Dekock rat S1
- Michael Bercht M1
- Helmchen
- Kleinfeld
- Simon Peron
- Special issue: http://journal.frontiersin.org/researchtopic/738/motor-cortex-microcircuits-frontiers-in-brain-microcircuits-series#articles
*** Suter 2013, Cereb cortex
- cites monkey+rat paper - 10hz
- (Chen and Fetz 2005; Isomura et al. 2009)

** LFP/population oscillations
- Cast13 -  The motor cortex: a network tuned to 7–14 Hz (mostly rat; some mouse)

* 16oct17 SFN poster - effect of synaptic distribution on network dynamics
** Abstract
Modeling the subcellular distribution of synaptic connections in cortical microcircuits

Salvador Dura-Bernal1, Benjamin A Suter2, Samuel A Neymotin, Gordon MG Shepherd, William W Lytton1,3
1 Department Physiology & Pharmacology, SUNY Downstate, Brooklyn, NY 11203, USA
2 Department Physiology, Northwestern University, Chicago, Illinois, 60611, USA
4 Kings County Hospital Center, Brooklyn, NY 11203, USA
E-mail: 	salvadordura@gmail.com

Understanding cortical microcircuits requires not only mapping connections at the level of cell populations, but also
determining the location of synapses along dendritic trees. Experimental evidence has highlighted very specific patterns of
subcellular organization that depend on the brain region, cell type and cortical depth. These distinct patterns of
innervation are likely to subserve important neural coding functions and have effects at multiple spatiotemporal scales,
including the meso- and macro-levels. Incorporating accurate subcellular connectivity in cortical computational models is
however challenging. Experimental data is generally sparse and obtained using a variety of techniques and formats, and
neuronal simulators tend to lack specific tools to ease the task of synapse placement. Hence, we developed NetPyNE, a Python
package to facilitate the development of biological neuronal networks in the NEURON simulator, with an emphasis on the
incorporation of multiscale anatomical and physiological data. NetPyNE seamlessly converts a set of a simple, standardized
high-level specifications in a declarative format, into a NEURON model. The subcellular distribution of synapses along the
dendrites can be specified, and is automatically adapted to the morphology of each model neuron, which could range from a few
to thousands of compartments. Different methods are available to provide subcellular synaptic location information, including
2D density maps derived from subcellular Channelrhodopsin-2-Assisted Circuit Mapping (sCRACM) data; 1D cortical-depth maps;
or using subsets of dendritic trees (section lists) based on the more common categorical data found in the literature
(eg. layer 4 cells targeting the layer 1 apical tuft). Using this tool we were able to analyse the network-level effects of
synaptic distribution in a multiscale model of primary motor cortex (M1) with morphologically detailed layer 5 corticospinal
and corticostriatal cells. Our work demonstrates the important role of subcellular patterns in investigating cortical
microcircuits, and facilitates future collaborations between anatomists, physiologists and modelers.

Acknowledgments: Research supported by NIH grant U01EB017695.

** TO DO (4 weeks)
*** DONE Separate simConfig and netParams in diff files (week 1)
*** DONE Add netParams.version and netParams.description and keep track in sdnotes.org (week 1)
- in nb keep version model with hg changeset, and description
*** DONE Parametrized model, cfg file for each sim (week 1)
- simConfig/cfg_16apr21.py
- netParams/net_v5.py
- in init.py
from simConfig import cfg_16apr21.py as cfg
from netParams import net_v5 as net

- in netParams.py
import __main__ as top
cfg = top.cfgFile.cfg.netCfg

in simConfig add methods to backup

simplify! -- add net params directly to simConfig and use from __main__ import cfg
*** DONE Reproduce sam's M1 model with pure netpyne format (week 1)
- cfg - done
- cell types - done
- netParams - done
- sim - done (just avg rates, not plots)

*** DONE Tune to reasonable rates (make table from papers) using only inputs, E-I scaling (week 2)
- check conn plot makes sense
-- revisit conn since IT5B getting very low input from L23 -- ok
- make table with firing rates from papers + gmgms -- ~ok
- save pop rates (and measure of oscillations?) -- ok
- save json nice format -- ok
- set up batch grid search or evol --ok
- raster plot with pop labels by side

- E-I scaling justified since from different papers
- test with reduced vs full model?
- only PT cells
**** TODO find 2.6K full PT net with decent rates
- if PT too high doesn't matter since probably due to overlapping syns

*** DONE Implement sCRACM-based subcellular distribution (week 2)
- make sure have data from Ben
- Note: Since photostimulation was with a cylindrical beam, sCRACM maps represent the 2-D projections of the 3-D distribution
  of inputs.
- import sections from hoc - use only spiny
- implement also 1D version
**** DONE center full cell in soma! - just subtract soma coords to all
- important since scracm takes as ref pia and assumes soma at 0,0,0
**** TODO Obtain final sCRACM map for current PT cell (average over several cells?, electrotonic rescale)
- wait for Ben's email
- for electrotonic rescale, set PT cell in sCRACM conditions
- select map that has soma at closest yfrac to BS0284 (820 um)
- stimulate center of all sections, and obtain rescaling factor for each section
- use code in synapse.hoc!


**** DONE Apply to net
- normalize sCRACM map (use only pixels that include some dendrite)
- sum weights of all syns and normalize to sum
- distribute syns randomly such that total normalized weight in each pixel ~= sCRACM amplitude

*** DONE Compare network dynamics with uniform vs scracm based distribution (week 3)
**** TODO average over multiple iseeds, wseeds, subcellwseeds?
**** TODO oscillations - use jing's / psd
**** TODO layerwise info transfer
- traces along dendrite
- check papers for ideas
*** DONE Generate figs and make poster (week 4)

** Synaptic distributions
*** Code from neurosim
Scattering synapses in a dendritic tree
Use of rangevarplot to see temporospatial dendritic activity

- https://docs.google.com/document/d/15e7myvlxFECb0WVX-90o3yUZ280TdSNAGcHSve1ph7Y/edit
- /hybsim/rangevarplot.py
-- setsyns():   Set up AMPA,NMDA synapses at regular locations in secl sectionlist
-- mkrvp():     set up the RangeVarPlots to go from beg to end
-- setevents(): sets up 1st event for copying but also sets up the vectors for interpolation; called in the finitialize loop
-- outev():     save output to vout[] vectors every evdelt time
-- setwt():     Set weights for AMPA and NMDA
-- chkwt():     print out information about synaptic locations types and weights up to max syns
-- stats():     print min,max,mean,stdev for a vector or list or numpy array
-- vrec():      record voltage from location to recvec
-- setandrun(): Setup the simulation and run it once
-- showpl():    show the dendrite sections with syns -- determined by list apicmain
-- secinfo():   Routine to permit click on Shape (or PlotShape) to get information about a location
-- stimzone():  show the dendrite sections with syns -- determined by list apicmain

*** Code from Ster12 (suggested by Ben)
- https://github.com/davidcsterratt/dcs-hoc
- Following this thread on the NEURON discussion forum, the PointProcessDistributor.hoc file can be used to distribute point
  processes on a morphology in NEURON. To run it, try
- The TreePlot code can be useful for plotting quantities over dendritic trees.
- https://www.neuron.yale.edu/phpBB/viewtopic.php?f=8&t=2264

*** to visualize need to set reduced HH morphology using pt3d
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161030_113714.png][fig]]
-     def shape_3D(self):
        """
        Set the default shape of the cell in 3D coordinates.
        Set soma(0) to the origin (0,0,0) and dend extending along
        the X-axis.
        """
        len1 = self.soma.L
        h.pt3dclear(sec=self.soma)
        h.pt3dadd(0, 0, 0, self.soma.diam, sec=self.soma)
        h.pt3dadd(len1, 0, 0, self.soma.diam, sec=self.soma)
        len2 = self.dend.L
        h.pt3dclear(sec=self.dend)
        h.pt3dadd(len1, 0, 0, self.dend.diam, sec=self.dend)
        h.pt3dadd(len1 + len2, 0, 0, self.dend.diam, sec=self.dend)
    #
    def set_position(self, x, y, z):
        """
        Set the base location in 3D and move all other
        parts of the cell relative to that location.
        """
        for sec in self.all:
            # note: iterating like this changes the context for all NEURON
            # functions that depend on a section, so no need to specify sec=
            for i in range(int(h.n3d())):
                h.pt3dchange(i,
                        x - self.x + h.x3d(i),
                        y - self.y + h.y3d(i),
                        z - self.z + h.z3d(i),
                        h.diam3d(i))
        self.x, self.y, self.z = x, y, z
*** Code to show mark at pointprocess
Shape.point_mark()
Syntax:
.point_mark(objvar, colorindex)

.point_mark(objvar, colorindex, style)

.point_mark(objvar, colorindex, style, size)

Description: draw a little filled circle with indicated color where the point process referenced by objvar is located. Note,
if you subsequently relocate the point process or destroy it the proper thing will happen to the mark. (at least after a
flush)

The optional arguments specify the style and size as in the Graph.mark() method of Graph. This extension was contributed by
Yichun Wei yichunwe@usc.edu.

Shape.point_mark_remove()
Syntax:
.point_mark_remove([objvar])
Description:
With no arg, removes all the point process marks.

*** Code to find distance to nearest section and arc?
http://www.neuron.yale.edu/neuron/static/new_doc/visualization/shape.html#Shape.nearest

Shape.nearest() Syntax: d = shape.nearest(x, y) Description: returns the distance (in model coordinates) to the nearest
section. The section becomes the selected section of the Shape. It is NOT pushed onto the section stack and it is NOT
colored. The nearest arc position of the selected section as well as the section is available from push_section().
Shape.push_selected() Syntax: arc = shape.push_selected()

if (arc >= 0) {

pop_section()

}

Description: If there is a selection for the Shape class, then it is pushed onto the section stack (becomes the currently
accessed section) and the arc position (0 to 1) returned. If no section is selected the function returns -1 and no section is
pushed.

Note that it is important that a pop_section be executed if a section is pushed onto the stack.

*** Default uniform dist leads to only 5 syns in total!!
- deterministic so always same 5
- all ~1000 conns go to these 5 syns
*** Steps to distribute syns
- calculate all conns/syns using just Python dicts (add option to cell funcs so no NEURON objs created)
- distribute syns using Python dicts
- create all NEURON conns+syns (use same func as when load py)
*** Data from Ben
- ratio.dat - vector of 300 numbers
- from calculateGridSigma() in synapses-epsprate.hoc know that:
-- 10x30 matrix (makes sense)
-- sigma_grid = new Vector(300)
    for ii=0,9 {
        for jj=0,29 {
            sigma_grid.x[ii*30+jj] = $o1.x[ii*30+jj] / avg * sigma_uniform
        }
    }
}

- sigma_uniform = 1.5 / 8 // spines/um (1.5) * fraction of all input pathways (1/8th for L2/3)
-- no need to do that here since num syns will be determined by syns in model
-- just need density
-- interesting though that L2/3 is just 1/8th !!!

- data is from L2/3 should be similar to fig 6K from Sute15:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161103_183352.png][fig]]

- how to align?
-- assume 0,0,0 is in same coordinates as in PT 3dpt

- avg density map or map for a particular PT cell?
-- if map corresponds to PT cell in Ben's repo then different cell -- could compare depth
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161103_191038.png][fig]]

- IMPORT SECTIONS FROM hoc
- use only spiny

- The stimulation grid consisted of 30 rows and 10 columns, with uniform 50 um spacing be- tween sites. The upper edge of the
  grid was aligned to the pia, and the grid was then centered on the soma. The height of the grid (1500 um) was chosen to
  ensure coverage across all layers and into white matter. The width of the grid (500 um) was chosen based on the maximal
  dendritic dimensions ob- served in our reconstructions.

- original map had understimated response of far away syn - due to electrotonic -- is this when multiple syns activated
  (nonlinear summation) ?

- make compromises!

*** Steps to convert from sCRACM map to dendritic density distribution
- Each pixel (50um x 50um) of the 10x30 sCRACM map represents (normalized) somatic EPSC in response to photostimulation-induced
  depolarization of axons in that volumetric pixel. The amplitude of each pixel depends on:
-- number of synapses between ChR2-positive axons and dendrites
-- strength of synapses
-- electrotonic distance from the soma

- Ben's method to generate dendritic syns from sCRACM map:
-- use cell model with reconstruction matching sCRACM map, and membrane model with sCRACM conditions (23ºC; blocked Na,K channels)
-- assume fixed num of syns per dendritic length (or per pixel?)
-- adjust syn weights based on sCRACM amplitudes (could also fix weights, and adjust num of syns)
-- since not considering electrotonic distances, there will be diffs between measured and simulated
-- rescale syns by electrotonic factor (he found syns close to soma were fine; far were underestimated)
-- if do for enough cells, could find systematic conversion method/rule (maybe as func of yfrac) without simulation

- Method for network given very limited time:
-- for each postsyn cell we know: 1) total number of syns, 2) syns per unitary conn (set to 5), and 3) weight of unitary conns.
-- unitary conn weights are based on Lefort -- somatic EPSP in mV -- and constrained to 0.3 - 1.0 (* fixed scaling factor)
-- can adjust weights of 5 syns/conn to match sCRACM data, but also should be a function of unitary conn weight
-- for net preferably use BS0284 since intrinsics well tuned, and already ran sims using it to tune network
-- since don't have sCRACM map for BS0284 could use 1) average of all, 2) average of cells (or single cell) with similar soma yfrac
-- adjust sCRACM map based on electrotonic scaling derived by simulating BS0284 in sCRACM conditions (23ºC; blocked channels)
-- in network: undo sCRACM, fix weight of syns (eg. unitary conn weight / 5) and use adjusted sCRACM map to set location of syns
-- adjusted sCRACM map pixel amplitude should be proportional to sum of weights of syns in that pixel

- Note: have to use density (syns/um of dend) because strength of EPSP depends of density not on total num of syns --
  attenuates as moves along dendrite!

- Found bug in Ben's code! closest 4 points in grid not necessarily surrounding it
-- easier to find nearest points to x coord; and then nearest to y coord

After SfN can redo all the last steps properly and include CSP cells and sCRACM maps for different yfracs,
calculate electrotonic scaling more thoroughly etc.

*** issue when have multiple subcell conn rules
- 1st step is to delete old synapses before repositioning conns
- but since syns can be shared, the subsequent rules might decide to remove synapses that were not only used by the original
  redundant conns but also by the first subconn rules
- solution: dont add syns if subconn rules??
-- add syns in the addConnsObj

*** Implementing sCRACM map conversion for BS0284 cell (using netpyne - wrong)
- copy to sep folder relevant files: /analysis/scracm
- remove channels - compare to Ben's code
- set up batch sim to stimulate each pixel
- Ben uses Exp2Syn and VecStim to provide input
*** Converting sCRACM map to syn density for BS0284 cell
- Use synapse.hoc (now synapse_sfn16.hoc) which reproduces sCRACM conditions
- Use morphology and membranee from BS0284 cell tuned by Sam -- used in M1
- Set conditions of sCRACM (23º, blocked channels Na and K)
- Assume uniform syn distribution assuming 1.5/8 syns per um of dend (only in spiny)
- For each synpase calculate the weights based on laser properties and syn depth
- Obtain peak value (pA) in soma in response - stored in map_peak_vc - can save to file
- Compare (divide by) experimental map to get ratio map (ratio.m in matlab)
- To verify: use extrw arg of map() to rescale syn weights by ratio

- Need to align with grid!!
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161108_172138.png][fig]]
-- prev cell: soma pt3dadd(203.294, -400.216, -79.8, 2.71926);
-- prev grid:  for ii=0,9 { grid_x.append(ii*50-25) }; for ii=0,29 { grid_y.append(367-ii*50) }
-- current cell: soma pt3dadd(203.294, -400.216, -79.8, 2.71926);
-- current grid: assume same x, but y starting at 0 = 0--ii*50
-- although tuft doesn't quite reach top!

- Actually BS0284 soma depth is 735, so using:
-- for ii=0,29 { grid_y.append(735-820-ii*50) }  // soma y = 820; soma depth = 735
-- closest sCRACM cells are 5 (734 um) and 1 (729um)

- Conversion to syn density map has to be using original cell!:
-- calculate uniform using orig morph and scracm conditions
-- find ratio dividing by expt
-- calculate syn density 2d map = uniform * ratio * 1.5 syns/dend
-- calculate 1d map by avging across rows
-- use syn density maps in network with physio cells

** Data analysis
*** alias to cp files
alias scpm1 'ssh no "scp -r ma:///tera/salvadord/m1/data/\!:1 /u/salvadord/Models/m1/data/." ; scp -r
no:///u/salvadord/Models/m1/data/\!:1 /u/salvadord/Models/m1/data/.'

alias sma 'ssh -t no "ssh -t ma \!:1"'

alias scptarm1 'sma "cd /tera/salvadord/m1/data ; /bin/tar -cvzf \!:1.tar.gz \!:1" ; ssh no "scp -r
ma:///tera/salvadord/m1/data/\!:1.tar.gz /u/salvadord/Models/m1/data/\!:1.tar.gz" ; scp -r
no:///u/salvadord/Models/m1/data/\!:1.tar.gz /u/salvadord/Models/m1/data/\!:1.tar.gz ; tar zvxf
/u/salvadord/Models/m1/data/\!:1.tar.gz -C /u/salvadord/Models/m1/data/ ; rm /u/salvador/Models/m1/data/\!:1.tar.gz'

*** new code in analysis folder
- utils.py - generic funcs
- sfn16.py - specific to this poster
*** finding net with suitable firing rates
- IT2 - 1-8 Hz (< L5)
- IT4 - ?
- IT5A - 6-12Hz (> IT2)
- IT5B - 6-12Hz (> IT2)
- PT5B - 6-14 Hz (> IT2)
- IT6 - 4-10 Hz (< L5)
- CT6 - 4-10 Hz (< L5)

- FS2 - 5-30 Hz
- LTS2 - 5-20 Hz (< FS2)
- FS5 - 10-40 Hz
- LTS5 - 5-30 Hz (< FS5)
- FS6 - 10-40 Hz
- LTS6 - 5-30 Hz (< FS5)

*** use jings' osc freq measure
*** info theory, nTE?!
yeah, py is just call to C code in infot.mod

[3:51]
you looking for full code in py?

mohamed.sherif	[3:53 PM]
example is here:
(/u/mohdsh/Projects/notebooksDir/ca3cannabisMTL_mohdsh_notebook.dol:38538:29)

**** moh's code
# calculate nTE of AMPA using tentropspks - in parallel
%cpaste
def wrap_dindiv_tentrospks_AMPA(mykey):
    arr_indivTentropspks = np.zeros((800))
    for mypyr in range(800):
            iseed = mykey[4]
            inputVec_AMPA = h.Vector()
            outputVec = h.Vector()
            inputVec_AMPA.from_python(ddrivingHisto[iseed]['AMPA'][mypyr])
            outputVec.from_python(doutputHisto[mykey][mypyr])
            arr_indivTentropspks[mypyr] = inputVec_AMPA.tentropspks(outputVec, vtmp, nshuf)
    return (mykey, arr_indivTentropspks)
--

results = Parallel(n_jobs = 15, verbose = 15)(delayed(wrap_dindiv_tentrospks_AMPA)(mykey) for mykey in datadic) # took 7.9min

dindiv_tentropspks_AMPA = dict(results)

*** Granger causality
**** cliff granger
- Granger yeah, nTE no
Granger should be on neurosim? bsmart.py


This file contains all the function definitions necessary for running spectral
Granger causality. It is based on Mingzhou Ding's Matlab code package BSMART,
available from www.brain-smart.org.

Typical usage is as follows:
from bsmart import pwcausalr
F,pp,cohe,Fx2y,Fy2x,Fxy=pwcausalr(x,ntrls,npts,p,fs,freq);

Outputs:
	F is the frequency vector for the remaining quantities
	pp is the spectral power
	cohe is the coherence
	Fx2y is the causality of channel X to channel Y
	Fy2x is the causality of channel Y to channel X
	Fxy is the "instantaneous" causality (cohe-Fx2y-Fy2x I think)
Inputs:
	x is the data for at least two channels, e.g. a 2x8000 array consisting of two LFP time series
	ntrls is the number of trials (whatever that means -- just leave it at 1)
	npts is the number of points in the data (in this example, 8000)
	p is the order of the polynomial fit (e.g. 10 for a smooth fit, 20 for a less smooth fit)
	fs is the sampling rate (e.g. 200 Hz)
	freq is the maximum frequency to calculate (e.g. fs/2=100, which will return 0:100 Hz)

The other two functions (armorf and spectrum_AR) can also be called directly, but
more typically they are used by pwcausalr in intermediate calculations. Note that the
sampling rate of the returned quantities is calculated as fs/2.

To calculate the power spectrum powspec of a single time series x over the frequency range 0:freq,
use the following (NB: now accessible via "from spectrum import ar")
from bsmart import armorf, spectrum_AR
[A,Z,tmp]=armorf(x,ntrls,npts,p) # Calculate autoregressive fit
for i in range(freq+1): # Loop over frequencies
    [S,H]=spectrum_AR(A,Z,p,i,fs) # Calculate spectrum
    powspec[i]=abs(S**2) # Calculate and store power

In either case (pwcausalr or spectrum_AR), the smoothness of the spectra is determined by the
polynomial order p. Larger values of p give less-smooth spectra.

Version: 2011feb11 by Cliff Kerr (cliffk@neurosim.downstate.edu)

**** sam granger
or LFP - there's a version cliff wrote based on mingzhou ding's matlab code

[8:05]
that's in /usr/site/nrniv/local/python/bsmart.py

[8:05]
example use is in /u/samn/plspont/load.py

[8:05]
check notebook for what it produces

[8:07]
[for the spike train version it's in matlab but have some C wrappers - probably better to translate to python at some point]


def grangerVST (ts1,ts2,sampr,WINS,INCS,order=30,maxfreq=125):
  winsz = int(WINS*sampr); incsz = int(INCS*sampr)
  sidx,eidx = 0,winsz;
  Gx2y,Gy2x = [],[];
  maxsz = len(ts1)
  idx=0
  while sidx < maxsz and eidx < maxsz:
    if idx % 10 == 0: print idx
    F,pp,cohe,Fx2y,Fy2x,Fxy=granger(ts1[sidx:eidx]-mean(ts1[sidx:eidx]),ts2[sidx:eidx]-mean(ts2[sidx:eidx]),order=order,rate=sampr,maxfreq=maxfreq)
    Gx2y.append(Fx2y); Gy2x.append(Fy2x);
    sidx += incsz; eidx += incsz;
    idx += 1
  return F,numpy.array(Gx2y),numpy.array(Gy2x)


**** other granger in hoc/mod
//** matgcspks(vec1,vec2,samplingrate,pathin1,pathin2,pathout,pid])
// this function calls /usr/site/nrniv/local/matlab/callmatgcspks to send a signal to
// /usr/site/nrniv/local/matlab/matgcspks and run MZD's granger causality on spike trains
// this function returns an NQS with 1 row containing output
// vec1,vec2 are binned spike trains (spikes per time)
// returns a vector containing vec1->vec2,  vec2->vec1 granger causality
obfunc matgcspks () { local sampr,pid localobj vspks1,vspks2,fpin1,fpin2,fpout,str,vop,strin,strout
  if(numarg()==0) {printf("matgcspks(vec1,vec2,samplingrate)\nvec1,2 are binned spike trains\n") return nil}
  vspks1=$o1 vspks2=$o2 sampr=$3 vop=new Vector(2)
  fpin1=new File() fpin2=new File() fpout=new File() str=new String() strin=new String2() strout=new String()
  {strin.s=$s4 strin.t=$s5 strout.s=$s6 pid=$7}
  {fpin1.wopen(strin.s) fpin2.wopen(strin.t)}
  if(!fpin1.isopen()) {printf("matgcspks ERRA: couldn't open %s for writing\n",strin.s)  return nil}
  if(!fpin2.isopen()) {printf("matgcspks ERRA: couldn't open %s for writing\n",strin.t)  return nil}
  {vspks1.vwrite(fpin1)  fpin1.close() vspks2.vwrite(fpin2)  fpin2.close()}
  sprint(str.s,"/usr/site/nrniv/local/matlab/callmatgcspks %d",pid)
  {printf("%s\n",str.s) system(str.s)}
  fpout.ropen(strout.s)
  while(!fpout.isopen()){
    printf("matgcspks ERRB: couldn't open %s for reading\n",strout.s)
    fpout.ropen(strout.s)
  }
  vop.vread(fpout)
  return vop
}
*** to visualize 3d cell shape use Shape.observe()
shape.observe(sectionlist)

objref sl
sl = new SectionList()
soma sl.append()
dendrite_1[8] sl.append()
Shape[0].observe(sl)

** Poster
*** Methods
- Show experimental data its based on
-- single cell morph+ephys
-- conn matrices (LSPS)
-- sCRACM (syn distributions)

- mention netpyne + web + example?

**** scracm description
- inject ChR2 in certain presyn axons (eg. L2/3)
- short pohotostimulation 1ms 2mW in specific grid (12x24, 50um) location
- depolarizes axons; use TTX (blocked Na+ and K+ ->no AP)
- axon terminal Ca2+ channels open -> glutamate release
- measure EPSC in soma

- provides a two-dimensional ‘image’ of the distribution of specific input within the dendritic arbors of the recorded cell

- EPSCsCRACM amplitudes depend on the density of ChR2-positive axons, the fraction of axons that make synapses with the
  recorded neuron, the strength of the synapses, and their electrotonic distance from the soma

- sCRACM maps were normalized to the largest pixels within a map and thus represent the relative strength of input within the dendritic tree.

- Average sCRACM map of layer 2/3 inputs to M1-CSPs (n = 23 neurons). L, Input profiles by soma depth. M, Location of perisomatic input from layer 2/3 relative to soma position, plotted as a function of soma depth. For each profile, the input depth was calculated as the center of mass across the perisomatic pixels.

*** Results
- Network size effect
- Cell model effect
- Syn distribution effect
-- note default is just total of 5 syns - all inputs overlap there!
-- compare radial (1d) vs map (2d)

- rates
- oscillations (use jing measure)
- raster ordered by yfrac

*** Discussion

- Future:
-- num cells 10k, volume 300um
-- full 3d IT cells
-- long range inputs
-- syn distributions for other cell types, sources (sCRACM or other)
-- scale syn weights appropriately (electrotonic - same soma response)
-- effect of Ih channel
-- info transfer measures
-- plasticity

** Emails with Ben about sCRACM
*** to Ben (16nov03)
I'm working on my poster which is supposed to show the network-level effects of using sCRACM-based synaptic density maps for L2/3 -> PT.

The network model includes the detailed PT cell model (BS0284). However, the only data you sent me with the sCRACM code ('csp_syn_input_v6/ratio.dat') seems to correspond to cell BS0477 (see figs attached).

Could you please send the sCRACM map/data for the BS0284 cell, and/or the average map shown in fig 6K?

Sorry for the late email, if I don't hear back from you I I'll try to use the data I have, but not sure makes much sense.
*** from Ben (16nov03)
Hi Salva! I'll be brief because late here.

The network model includes the detailed PT cell model (BS0284). However, the only data you sent me with the sCRACM code ('csp_syn_input_v6/ratio.dat') seems to correspond to cell BS0477 (see figs attached).

Could you please send the sCRACM map/data for the BS0284 cell, and/or the average map shown in fig 6K?

The conditions for sCRACM (TTX and 4-AP in bath, which block Na and K channels) aren't compatible with recording intrinsic
properties, such as AP firing (also, sCRACM was at room temp). Conversely, for intrinsics I usually use synaptic blockers
(NBQX for AMPAR, CPP for NMDAR, and gabazine in bath), which is not compatible with input mapping. In theory I could have
first recorded intrinsics at 34C (but without synaptic blockers), then added TTX and 4-AP and done sCRACM mapping. I did not
do that (although that monster experiment was on my wish list). So in general for a given neuron we have either intrinsics or
synaptic input, but not both. The exception to this is that for the sCRACM maps I *did* record some subthreshold current
injection steps, negative and positive, which should allow some calibration of passive properties and Ih in the sCRACM cells.

So: For BS0284 I only have intrinsics and morphology. For BS0477 I have sCRACM maps, morphology, and (probably) some
subthreshold current steps.

I don't recall right now whether the membrane model that I used with BS0477 was exactly the BS0284 model, or whether I refit
the passive parameters first.

Actually, I have a simplified membrane model, a so-called "sCRACM membrane model", without Nax (blocked by TTX) and
K_something (I'll have to check which is blocked by 100 uM 4-AP), and runs at 23C. This is what I used for BS0477
simulations.

Tomorrow, Friday, is Carolina's birthday (and a big day at work for me), so I probably won't get a chance to look at this
more closely until Saturday.


The concept, in my mind, is to use a "typical' membrane model for CSP, and insert this into the specific reconstructions
paired with maps; I'm not sure whether or not to adjust the membrane model's passive parameters to each sCRACM cell. This
gets at the basic question: how similar are passive properties (or active, for that matter) across the CSP population? Some
of this variability is quantified in my first CSP paper, but mostly focused on AP shape.

Bottom line: for now I would recommend treating the BS0284 membrane model (either mine, or the result of Sam's evolution as
published) as a "representative CSP", disable/remove Nax and K_something, lower temp to 23C, and use this membrane model as
is in whichever sCRACM cells you use.

I think there are ~15 CSP neurons where I have both L2/3 sCRACM maps and full reconstructions. I'll have to check that
number. BS0477 is one of these. Ideally you would use all of these in the network, according to their soma yfrac. But are you
hoping to do that for SfN?

Hope this helps a bit,
Ben.

*** From Ben 2 (16nov03)
Shorter: for simulation of sCRACM, for the purpose of converting the raw maps into dendritic density distributions, I used
BS0477 because there I have maps and dendritic reconstruction. The membrane model will need to come from a different CSP (or
multiple other CSP), after removing channels that were pharmacologically blocked during sCRACM experiments (I used BS0284
membrane model with adjustments for sCRACM conditions). But this model could potentially be adjusted to better fit the
limited subthreshold current step responses that I do have for the sCRACM cells. This would result in dendritic density maps
for each specific sCRACM cell.

To use this in a network model, the membrane model needs to be made physiological again (undoing sCRACM).

Assume we calculate the dendritic density distribution for a number of paired map/reconstruction experiments - perhaps we
will find that there is a very consistent, regular conversion pattern from sCRACM map to synaptic density map. If that is
true, then we could attempt a systematic conversion (not simulating) of maps to synaptic density, and then apply this across
a population of postsynaptic CSP.

*** to Ben (16nov04)
Ben, thanks for your 2 emails, very clear. I only have 1 week to run the network simulations (which take a long time) under the different conditions, analyse the results (rates, osc freqs, layerwise info transfer), and make the poster. Plus I have to prepare a talk for a workshop on Saturday. I should have started before with sCRACM, but been busy setting up the network and developing NetPyNE -- putting in an R01 grant with Mike Hines in February!

Therefore I will have to make some compromises/assumptions for this poster. The main idea was to illustrate 1) the concept that syn distributions affect network dynamics,  2) compare effects using uniform distribution vs radial (1d) vs mapped (2d), and 3) that sCRACM data can be incorporated into the network.

Here's a short summary of my understanding of the data and how to use it:

- Each pixel (50um x 50um) of the 10x30 sCRACM map represents (normalized) somatic EPSC in response to photostimulation-induced
  depolarization of axons in that volumetric pixel. The amplitude of each pixel depends on:
-- number of synapses between ChR2-positive axons and dendrites
-- strength of synapses
-- electrotonic distance from the soma

- Method to generate dendritic syns from sCRACM map:
-- use cell model with reconstruction matching sCRACM map, and membrane model with sCRACM conditions (23ºC; blocked Na,K channels)
-- assume fixed num of syns per dendritic length (or per pixel?)
-- adjust syn weights based on sCRACM amplitudes (could also fix weights, and adjust num of syns)
-- since not considering electrotonic distances, there will be diffs between measured and simulated
-- rescale syns by electrotonic factor (he found syns close to soma were fine; far were underestimated)
-- if do for enough cells, could find systematic conversion method/rule (maybe as func of yfrac) without simulation


And given the very limited time, here is a possible way of how to apply it to the network (makes some bold assumptions/approximations):

-- in net for each postsyn cell we know: 1) total number of syns, 2) syns per unitary conn (set to 5), and 3) weight of unitary conns.
-- unitary conn weights are based on Lefort -- somatic EPSP in mV -- and constrained to 0.3 - 1.0 (* fixed scaling factor)
-- for net preferably use BS0284 since intrinsics well tuned, and already ran sims using it to tune network
-- since don't have sCRACM map for BS0284 could use 1) average of all, 2) average of cells (or single cell) with similar soma yfrac
-- adjust sCRACM map based on electrotonic scaling derived by simulating BS0284 in sCRACM conditions (23ºC; blocked channels)
-- in network: undo sCRACM, fix weights of syns (eg. unitary conn weight / 5) and use adjusted sCRACM map to set location of syns
-- adjusted sCRACM map pixel amplitude should be proportional to sum of weights of syns in that pixel

So, basically it would be great if you can send me sCRACM maps for cells with similar soma depth to BS0284 (or all the sCRACM maps and I can sort through them), and/or the average sCRACM map shown in the paper.

Let me know what you think and if you have other suggestions. After SfN I can redo all the last steps properly to include CSP cells and sCRACM maps for different yfracs, calculate electrotonic scaling more thoroughly etc.

Hope your big day at work went well; say happy birthday to Carol and hope you guys have fun.

Thanks
Salva

*** from Ben (16nov06)
Dear Salva, I fear my response is going to be less well organized than hoped.  Nevertheless, hopefully it's useful. I attach
a ZIP with data you requested, and a brief description of the contents near the bottom of this email. Second, some inline
responses below. Third, I attach a text file with a long response - there are multiple parts, perhaps not in the most logical
order.

and developing NetPyNE -- putting in an R01 grant with Mike Hines in February!  Congrats this sounds awesome - would like to
hear/talk more. Will Hines be at SfN? Perhaps all three of us could get together?

Therefore I will have to make some compromises/assumptions for this poster.  The main idea was to illustrate 1) the concept
that syn distributions affect network dynamics, 2) compare effects using uniform distribution vs radial (1d) vs mapped (2d),
and 3) that sCRACM data can be incorporated into the network.  What if you simplify and compare (1) uniform vs. (2) radial
density from maps averaged across rows? I write about this much more detailed in the attached .txt file. In short - the 2D
maps are artificial, a result of experimental technique, the underlying distribution is probably 1D (radial).

Here's a short summary of my understanding of the data and how to use it:

- Each pixel (50um x 50um) of the 10x30 sCRACM map represents (normalized)
The maps are only normalized for group analysis. The raw maps are not normalized. During experiment, I adjusted laser power
to get a consistent peak response when stimulation over the soma (I think ~100 pA, maybe it was ~150 or 200 pA, not sure - in
any case, it was approximate). The goal of this was to ensure that the responses remained within a similar amplitude regime
across experiments, not to achieve perfect calibration across experiments. When we do want to look across maps, we normalize
to the peak response (which is always over the soma). In fact, I *think* I usually first convert each raw map into a vector
(sum across each row), and then normalize the vector to its peak.

somatic EPSC in response to photostimulation-induced
 depolarization of axons in that volumetric pixel. The amplitude of each
pixel depends on:
-- number of synapses between ChR2-positive axons and dendrites
-- strength of synapses
-- electrotonic distance from the soma
Also, that synapses near the slice surface are more strongly activated
than those deeper in the slice, due to scattering of the blue light.
This z-dependent activation is the same for all pixels, but needs to
be taken into account in the sCRACM simulation.

- Method to generate dendritic syns from sCRACM map:
-- use cell model with reconstruction matching sCRACM map, and membrane
model with sCRACM conditions (23ºC; blocked Na,K channels)
and z-dependent gradient of activation

-- assume fixed num of syns per dendritic length (or per pixel?)
not per pixel

-- adjust syn weights based on sCRACM amplitudes (could also fix weights,
and adjust num of syns)
I prefer fixing weights and adjusting # syns, but adjusting weights is
more efficient; see .txt file for lots on this.

-- since not considering electrotonic distances, there will be diffs between
measured and simulated
-- rescale syns by electrotonic factor (he found syns close to soma were
fine; far were underestimated)
Correct. Iterate until good fit, but I found that 1 iteration was
probably enough (which also suggests that the electrotonic attenuation
is linear?).

-- if do for enough cells, could find systematic conversion method/rule
(maybe as func of yfrac) without simulation
Correct, would be nice and seems possible.

And given the very limited time, here is a possible way of how to apply it
to the network (makes some bold assumptions/approximations):

-- in net for each postsyn cell we know: 1) total number of syns, 2) syns
per unitary conn (set to 5), and 3) weight of unitary conns.
-- unitary conn weights are based on Lefort -- somatic EPSP in mV -- and
constrained to 0.3 - 1.0 (* fixed scaling factor)
-- for net preferably use BS0284 since intrinsics well tuned, and already
ran sims using it to tune network
-- since don't have sCRACM map for BS0284 could use 1) average of all, 2)
average of cells (or single cell) with similar soma yfrac

I recommend using a radial function ("profile" or vector) corresponding to the same yfrac as BS0284. Because there is quite a
bit of variability in the maps from cell to cell, maybe we should smooth the profiles (moving average across yfrac), or
divide yfrac into bins and calculate an average profile for each bin. I did this with 3 bins previously, and am including a
.fig that contains these data. But, perhaps better would be to just keep the variability intact, because you can simulate
each of the individuals and then instantiate many of each in the model - i.e. don't average and then apply the average to all
cells in the model, but instead repeatedly sample the distribution of maps. Recall that deep CSP get no / very little L2/3
input - so I wasn't able to map these. The radial input strength (from Anderson&Sheets) predicts/shows this.

-- adjust sCRACM map based on electrotonic scaling derived by simulating
BS0284 in sCRACM conditions (23ºC; blocked channels)
Yep, this means: adjust density of synapses (per dendritic length) as
a function of y, fitting the simulated response profile to the
experimental response profile.

-- in network: undo sCRACM, fix weights of syns (eg. unitary conn weight /
5) and use adjusted sCRACM map to set location of syns
I don't quite get this - didn't we already "set the location of syns"
in the earlier steps? Perhaps you mean that you wish to randomize
these a bit in each instantiated neuron? That sounds good.

-- adjusted sCRACM map pixel amplitude should be proportional to sum of
weights of syns in that pixel
I don't get this, but I'm tired.

So, basically it would be great if you can send me sCRACM maps for cells
with similar soma depth to BS0284 (or all the sCRACM maps and I can sort
through them), and/or the average sCRACM map shown in the paper.

DATA attached in ZIP:

m1l23-to-m1-csp.mat The full data set; for variable names, "n" means normalized; "s" means smoothed, I think? you can just
use "maps" (the raw maps) and "nprofs" (normalized profiles). sy is soma depth, yf is soma yfrac. "list" contains the cell
IDs. All these arrays are in the same order, so the 1st map is from the 1st cell in "list". Hopefully the rest is
self-explanatory.

soma-relative-to-grid.mat Data about where the soma was relative to the grid: I tried to center the grid on the soma, and
align the upper edge to the pia, but there may be some small discrepancies. I don't recall exactly what each variable in this
.mat means, for now hopefully this detail isn't so important (but see my notes in .txt about alignment discrepancy and
"divide by zero" issues).

Four .fig files showing the individual maps, and profiles, and binned
average maps, and more.

Let me know what you think and if you have other suggestions. After SfN I can redo all the last steps properly to include CSP
cells and sCRACM maps for different yfracs, calculate electrotonic scaling more thoroughly etc.

Does your network model include full (i.e. with dendrites) models of CSP at varying yfrac depths? If so, which
reconstructions are you using for this?

What are the sources of synaptic input to CSP? Only from the local circuit, i.e. L2/3 and L5 IT/PT? Or are you including
long-range inputs?

Hope your big day at work went well; say happy birthday to Carol and hope you guys have fun.

Thank you, and good luck!

Ben.

**** Additional text file
Does your network model include full (i.e. with dendrites) models of CSP at varying yfrac depths? If so, which
reconstructions are you using for this?

What are the sources of synaptic input to CSP? Only from the local circuit, i.e. L2/3 and L5 IT/PT? Or are you including
long-range inputs?

======================================== Your "radial (1d) vs mapped (2d)" concept: The maps are 2D because I scanned the
laser in a 2D pattern. The neuron in the slice is still 3D, as is the dendritic length density. The laser stimulation is
designed to be like a "pencil beam", meaning that we would like to stimulate all the synapses throughout the thickness of the
slice, at a given "pixel". But in practice, the intensity falls off rapidly with depth below the surface of the slice. In my
sCRACM simulation I accounted for this, <i.e. with a z-dependent activation function.

I have very little reason to believe that the synaptic density is a "2D" function: my idea is that the axonal density is a
radial (y) function, which combines with the 3D dendritic density distribution, resulting in a synaptic density. The synaptic
density per linear dendritic length should thus be a function of y. But when you make a map, you are taking a front-view 2D
snapshot, then because the dendritic density per pixel varies in x (less dendrites at the edges, lots in the middle of the
map), the synaptic density per pixel is now a function of x and y. And the synaptic response per pixel is a function of this
synaptic density per voxel, and how strongly these synapses are activated as a function of z. The stimulation effectively
averages each 3D voxel across z (weighted by z-depth), resulting in a 2D pixel. The goal, then, is to reverse all these
measurement effects and calculate the # of synapses per length of dendrite.

Summary: the map data are 2D, but the underlying synaptic density (that we wish to extract for use in the network model) is
probably a radial function. To find this radial function we must account for z-dependent activation, the full 3D dendritic
density distribution, and electrotonic attenuation.

Note: this assumes we are looking at CSP that are not near the edges of the innervated region, and hence that the axon
density is a radial function. Indeed, this was true for my experiments.

========================================
My take (some of the details are rough, I haven't reviewed my notes from when I was coding it):

I estimated the total # of excitatory synapses onto CSP by measuring the linear density of spines in various compartments of
a CSP, under the assumption that each spine represents one excitatory synapse. I don't recall the final estimate, but I think
around 20'000 spines.

Next I made a list of all sources of excitatory input onto CSP, based on my own tracing and electrophysiology studies. As
best I can recall: L2/3, L5 IT, L5 PT; contra M1; ipsi S1, S2, M2; thalamus. Note: inputs from very frontal areas are
tricky - rather than just M2, could also include orbital cortex. I then estimated the fraction of total synapses from each of
these sources - don't know if I can give a good rational for how I estimated this - maybe based on a rough estimate of the
relative # of presynaptic neurons labeled retrogradely in each area, i.e. S2 population is smaller than S1 population. So
perhaps you should just assume equal proportions for now.

From this I arrived at an estimate of the total # of L2/3 synapses on a single CSP. Something like 2k-3k, as I recall. This
serves as a starting point / rough constraint to see whether the various numbers / estimates in the network remain
realistic. For example, if there are 5 synapses per unitary L2/3 connection, then this suggests about 400 presynaptic L2/3
neurons for each CSP.

However, I realize that in your network simulation the size of the network is a parameter, and thus the # of presynaptic
neurons, and the total # of synapses on a single CSP, may be scaled relative to what I measured in experimental
reality. Still, scaling or no scaling, I think it's important to make sure that when the network is fully instantiated and
configured, the numbers (such as total # of excitatory synapses, total # of synapses per dendritic length, unitary strength)
are within experimentally determined ranges - accounting of course for e.g. lack of long-range inputs and scaling of the
model.

=============== As I recall, I struggled quite a while with the problem of synapse number and synapse strenght (or weight),
specifically, how to disentangle these? The sCRACM maps really don't provide data to separate these parameters. Much of what
I wrote above (regarding total # of spines, for example) is really about constraining these parameters, or trying to make
sense of them. As I recall, I wanted to make all synapses have the same weight, and just vary the number of synapses in each
dendritic segment. In my mind, this is more realistic: I'm not aware of evidence showing a wide variability in the strength
of individual, neighbouring synapses, nor of synapses (of the same type/source) but at different locations in the dendritic
arbor. However, there is evidence that e.g. the # of spines varies across the dendritic arbor.

I am not saying that all synapses are equally strong (measured at the synapse, not the soma) - there probably is some
variation, at least. But based on the evidence that I know, my gut feeling is that it's more likely that L23->CSP synapses
fall into a small range of weights, but that their # varies across dendritic location (rather than a uniform density and
variable weights). Of course, it could be some variation.

Does this distinction even matter? I would have guessed yes, it does - that 10 small synapses on one dendrite behave
different from 1 synapse that's 10x stronger. Certainly if you factor in stochastic transmission failures this should matter,
i.e. likelihood/quantity of transmitter release given a presynaptic AP. Also, when you throw in NMDARs, the depolarizations
at nearby synapses could affect each other. So even though in the sCRACM data we can't easily factorize the product of # and
W, I felt like it would matter in the model. However, what I recall now, is that after I made a model with many (2k?)
synapses, each with realistic weights (meaning they each gave something like 0.1 or 0.2 mV depolarization at soma), I then
went on to reduce the # of synapses (and scale up their weight) by factors of 10 and 100, in order to reduce the runtime of
the simulation. But first I compared the somatic response for the full and rescaled models - and to my surprise, I found very
little differences, justifying the use of a simplified (fewer synapses) and much faster model. Of course, I suspect that this
depends on the pattern of activation (i.e. # and timing of activated synapses).

Long story short: I would prefer to keep the W fixed (or randomized within a small range) across the entire L2/3 synapse
population, and vary the # of synapses per dendritic length. However, based on my earlier work, the simulation results may be
very similar if you just fix the synapses and vary their W when fitting to the maps.

I don't actually recall which version I implemented in the code that I sent to you: was it varying the density, or the weights?

===============

PROBLEM: alignment - if there is a small error in alignment of map and reconstruction, this could lead to "divide by zero"
type errors, i.e. where a stimulus on a pixel with seemingly very low dendritic length gives a sizable somatic response, so
the density of synapses is then assumed to be very high (but in fact, could be a case of slight misalignment at edge of a
pixel). This also relates to the resolution of the method (was a larger area stimulated than just ~60 um diameter?).

For this reason, I think analyzing the yfrac-profile may make the most sense. What I mean, is that you simulate the full 3D
situation with the reconstruction, but once you have the simulated map, you average across rows to generate a profile - just
like we typically do in the analysis of the experimental maps - and compare this y-profile to the experimental
y-profile. From this comparison, you get a radial correction factor, aka a profile of ratios simulated/measured. Then apply
this ratio_y to all synapses across each row, re-run the simulation, and redo the comparison. Theoretically you can iterate
until the errors cease to get smaller; but in practice, a single iteration may already get you very close (as it did for me
with BS0477).

========================================================================


*** to Ben (16nov06)
Hi Ben, Thanks so much for your email, as always very useful and full of interesting details. Quick answers to your
questions, and then a couple quick questions from me:

Will
Hines be at SfN? Perhaps all three of us could get together?
Hines won't be there, but we can meet with Bill who is helping me write the grant.

What are the sources of synaptic input to CSP? Only from the local circuit, i.e. L2/3 and L5 IT/PT? Or are you including
long-range inputs?  Local circuit and what we call background or driving inputs, ie. Netstims simulating long range inputs,
currently with same params for all cells. Netstims are connected to the AMPA and GABAA syns of each cell (5 syn contacts per
connection = total of 10 syn inputs).  Currently each CSP cell has ~1000 syn inputs, all except 10 from exc and inh local
connections; X of whcih are from exc L2/3. This is for a net of 150x150 um which results in 2,664 cells. The idea is to scale
to 300x300 um -- which results in ~10k cells -- and add long range inputs, so the num of syns/cell will increase
signficantly, hopefully reaching the experimental numbers you mentioned.

Does your network model include full (i.e. with dendrites) models of CSP at varying yfrac depths? If so, which
reconstructions are you using for this?  Using the same model (BS0248) for all CSPs, although they are located at different
yfracs. Hope to add different reconstructions soon.



Intro to my questions: I'm implementing the code to calculate the map or profile of ratios simulated/measured. I have your
code synapses_epsprate.hoc, but this code assumes you already have a ratio map (loaded from ratio.dat -- fig which I showed
in 1st email), and uses it to obtain the syn density map = ratio map (ie. peak_experimental/peak_uniform) *
sigma_uniform. The code also has funcs to compare the cell response with uniform vs mapped syn distributions, by generating
EPSPs (Exp2Syn+Vecstim) which are distributed randomly across synapses, and recording the soma output -- for 33 iterations
where num EPSPs increases from 4k to 20k.

My questions: How do you calculate the initial ratio map (ratio.dat)? Do you simply use as peak_experimental the values
(normalized?) from the original sCRACM map?  Do you need the full EPSP procedure (33 iterations etc) to calculate the ratio
map? In my head I was planning on simply stimulating the syns in each of 10x30 voxels for the uniformly distributed vs mapped
synapses, and find the ratio. Sorry if I'm missing something obvious.  If possible, could you please send me the code you
used to generate the initial ratio map (eg. ratio.dat)?

Thanks again!

*** from Ben (16nov07)
What are the sources of synaptic input to CSP? Only from the local
circuit, i.e. L2/3 and L5 IT/PT? Or are you including long-range
inputs?

Local circuit and what we call background or driving inputs, ie. Netstims
simulating long range inputs, currently with same params for all cells.
Netstims are connected to the AMPA and GABAA syns of each cell (5 syn
contacts per connection = total of 10 syn inputs).
Currently each CSP cell has ~1000 syn inputs, all except 10 from exc and inh
local connections; X of whcih are from exc L2/3. This is for a net of
150x150 um which results in 2,664 cells. The idea is to scale to 300x300 um
-- which results in ~10k cells -- and add long range inputs, so the num of
syns/cell will increase signficantly, hopefully reaching the experimental
numbers you mentioned.

Hmmm, I find this a bit concerning :( - if I understand you correctly,
namely that a CSP has 100:1 ratio of local to long-range input
synapses? It just seems so far from reality. But I guess "reality" is
still a guess on my part. I would be happier if each neuron had a
realistic # of synapses, and a realistic fraction of those were local
inputs. But, that's just me thinking on little sleep ... will be
better to sit down and let you walk me through your rational and plans
in person, and then pass judgement ;)

I do like the idea of the scale you are using now, and plans for
scaling up to 10k local cells together with long-range inputs.

I realize that your (collectively meaning our "M1 network" models over
the last few years) focus has been on the local M1 network - but
probably the most important finding of my PhD was that M1 CSP receive
monosynaptic excitation from *every* area that projects to M1. On top
of that, these inputs also excite L2/3, so CSP get a "second wave" of
excitation, most likely. I believe that the interplay of these two
long-range input pathways (direct to CSP and indirect via L2/3), along
with the various forms of disynaptic inhibition, are likely key to
understanding how M1 works. Future stuff!

Does your network model include full (i.e. with dendrites) models of
CSP at varying yfrac depths? If so, which reconstructions are you
using for this?

Using the same model (BS0248) for all CSPs, although they are located at
different yfracs. Hope to add different reconstructions soon.

Okay, but for SfN all the dendritic CSP will be at the same yfrac? Or
are they positioned at different yfracs, but you just give them the
BS0284 dendrites? And assume that they all get the same subcellular
input pattern (i.e. the pattern seen at just a BS0284-equivalent
yfrac)? I guess this works since you don't actually form synapses from
axon / dendrite overlap (a la Markram rat barrel model). A 3D
rendering would be weird, but the model works like this, I guess?

Intro to my questions:
I'm implementing the code to calculate the map or profile of ratios
simulated/measured. I have your code synapses_epsprate.hoc, but this code
assumes you already have a ratio map (loaded from ratio.dat -- fig which I
showed in 1st email), and uses it to obtain the syn density map = ratio map
(ie. peak_experimental/peak_uniform) * sigma_uniform. The code also has
funcs to compare the cell response with uniform vs mapped syn distributions,
by generating EPSPs (Exp2Syn+Vecstim) which are distributed randomly across
synapses, and recording the soma output -- for 33 iterations where num EPSPs
increases from 4k to 20k.
Cool.

My questions:
How do you calculate the initial ratio map (ratio.dat)? Do you simply use as
peak_experimental the values (normalized?) from the original sCRACM map?
Do you need the full EPSP procedure (33 iterations etc) to calculate the
ratio map? In my head I was planning on simply stimulating the syns in each
of 10x30 voxels for the uniformly distributed vs mapped synapses, and find
the ratio. Sorry if I'm missing something obvious.
If possible, could you please send me the code you used to generate the
initial ratio map (eg. ratio.dat)?

This involves a simulation of an sCRACM experiment, one grid location
at a time, just like in the experiment. And this is where I took into
account the attenuation of blue light within the slice, resulting in
z-dependent activation strength of synapses. I started with uniform
synapse density in all dendrites. Simulate an sCRACM mapping
experiment. Then for each of the 10x30 pixels I calculated the ratio
of experimental peak response to simulated peak response. So now I
have a map of ratios, essentially an error function. Next I multiplied
the synaptic density in each pixel by this pixel-specific ratio. In
theory, there is no reason to believe that this change alone should
result in a good simulation: hopefully it gets you closer, though, and
then you would iterate like this until adequate fit achieved. But in
practice, after one iteration the map already looked pretty good (aka
similar to experiment). Essentially, the peak response at soma gave
almost a linear readout of the synaptic density at each pixel! (I
don't know whether this will be true for all cells, but we should find
out)

I'm a bit confused about the 33 iterations. Do you mean varying the
total # of synapses? I'm not saying you're wrong - honestly, I may not
recall my own code/approach all that well after >3.5 years. I do
recall varying the total synapse #, but I think this was only after I
had found the non-uniform (aka mapped) distribution, and was then
trying to understand the effect and trade-offs of synapse # vs.
synapse weight, etc.

Okay, so here's what I'm gonna do - dig around in my code and try to
find some answers / info for you.

1. I am attaching "synapses.hoc". This comes from "v5" of my model (I
had originally sent you "v6"). I'm not sure, but it's possible that in
v5 I achieved the sCRACM simulation and resulting ratio.dat, and then
in v6 was focused mostly on executing the "physiological" model with
different synapse distributions, aka the whole "epsprate" stuff. In
"synapses.hoc" you will find the code that "simulates sCRACM". My
apologies for not realizing sooner that the v6 code I gave to you does
not include these functions.

2. Going full hog, I am including my "journal" for the synaptic model.
This is a text file where I kept track of my progress, my dilemmas,
different approaches, trials and many errors. And also, sometimes, my
personal thoughts. Probably nothing too personal, but since there was
nobody else to talk to about these things in my lab or nearby (except
occasionally Gordon), I did a lot of "talking in the form of writing".
Feel free to start at the top and read it all (about 3 months worth,
I'm guessing), or just scan it until you find the relevant parts.
Hopefully this helps.

*** To Ben (16nov07)
Fantastic!! synapse.hoc is exactly what I needed! I was going nuts looking at the other code and thinking I didn't understand how you got the ratio haha .. so happy to see this code! :)  The other EPSP code must definitely be for some later experiments to compare the syn distributions etc.  The journal.txt also looks pretty useful ... I'll look for any juicy personal stuff ;)

a CSP has 100:1 ratio of local to long-range input synapses?


Yes, but this is just the default way we've done models in the past, to provide some driving activity so the net is not dead. These inputs usaully have relatively high rates and weights. But don't worry, they are a temporary "stand-in" until we add the proper long range inputs.
Very interesting that CSP receive monosynaptic input inputs from every area, and the "2nd wave" of excitation -- and great that you have data on it, look forward to incorporating it!

Or are they positioned at different yfracs, but you just give them the BS0284 dendrites?
And assume that they all get the same subcellular input pattern (i.e. the pattern seen at just a BS0284-equivalent yfrac)?
Yes and yes -- but hope to add at least 3 or 4 different reconstructions for different yfracs.

I guess this works since you don't actually form synapses from axon / dendrite overlap (a la Markram rat barrel model). A 3D rendering would be weird, but the model works like this, I guess?

and yes, does look a bit weird!

We can have a good chat about the model and future steps at sfn
Thanks!

*** to/from Ben (16nov08-09)
Hey Ben,

So I got the ratio maps for the BS0284 PT cell we are using in the net. For sCRACM I selected the 2 cells that had closest soma depth: cell 19 (819 um) and cell 23 (810 um). The ratios seem consistent with the previous example you had and also with the observation of having a ratio of ~10x in apicals vs basal.

There are some very high-valued pixels which I suspect are related to the "division by zero" issue you mentioned. Also, after the 1st iteration the new ratios are close to 1 in most of the grid, except the edges, but I suspect this is partly an artifact since there are little or no dendrites in those pixels.

One quick question: I assumed the y 3d points of the BS0284 represent cortical depth, ie. soma was as ~820 um. Can you confirm that is the case? When I plot the shape it seems like the tuft doesn't quite reach the top (0-0.1 mm -- see fig attached) as in most of the cells you show in your 2015 paper.

Now I just have to run sims to compare the effects in the net, analyse the data and make a poster! ;)

thanks
salva

<scracm_cell19toBS0248.png><scracm_cell23toBS0248.png>
<PastedGraphic-1.tiff>


-----
Dear Salva,
The soma depth (relative to pia) of BS0284 is 735 um. But read on ...

The discrepancy probably is due to me working on the CSP model well before I did the sCRACM mapping and M1/S2 project, i.e. before I started analyzing the dendritic geometry. So for the modeling, I just imported the reconstruction into NEURON as is (which means that I did my best during imaging and setup in Neurolucida to align the neuron/images sensibly, but the pia is not necessarily at y=0, and the soma is not necessarily at x=0).

It's late here and my head's foggy, so I don't recall exactly how I aligned the mapping grid to the reconstruction in NEURON. I figure this should be in the code that I sent you, but I'm really not sure right now. What you can see in v6 is that I imported the BS0477 reconstruction into NEURON, and then I tweaked it a bit to get morph.hoc (added some SectionLists, and also inserted an initial axon segment that I took from BS0582). However, I don't know whether the BS0477 reconstruction (as imported into NEURON) is aligned to pia and centered on soma? You can check this by just opening v6/morph.hoc and checking the coordinates in NEURON - but I'm not set up to do that right now/here.

Digging into the synapses.hoc file, in the procedure setupGrid(), there is a line that reads as follows:
    for ii=0,29 { grid_y.append(367-ii*50) }

Maybe that "367" is a magic number, chosen to bring the grid into alignment with the BS0477 reconstruction?

I assume the journal.txt file has info about this, but it's too late for me to go digging in that tonight.


--------

Hi Salva,
I'm confused though - why are you using BS0284 morphology together with sCRACM maps? Maybe this will make sense to me in the morning. I should be in bed but wanted to check Google's election results graphics first ...

I would suggest:

1.a. Calculate the synapse density by combining maps and morphology from a single neuron (e.g. BS0477) and the membrane model from BS0284 with sCRACM adjustments. For this, either align the reconstruction with pia at y=0, or align grid to reconstruction.
1.b. Convert the synaptic density map into a radial density vector by averaging across rows.
2. Repeat these steps, if you like, for other such neurons at various yfrac values.
3. Bin these neurons into yfrac ranges (top, middle, bottom of L5B) and calculate an average radial synapse density vector for each bin. You now have three radial synapse density vectors.
4. Insert BS0284 morphology and physiological membrane model into the network. Pick the corresponding radial synapse density vector and insert synapses on each BS0284 dendrite segment according to this vector. This requires that you calculate the dendrite segment's depth below the pia, then look up the corresponding element in the density vector.
5. Repeat #4 for other morphologies, either using BS0284 model or other/new membrane models when available.


--------

Ben,

I think we briefly discussed this in prev emails. The reasons I'm using BS0284 morph with sCRACM maps are:
1) I'm not sure of the soma depth of BS0477 (guess ~770 um based on morph and -367 value in setupGrid()).
2) I don't know what sCRACM map corresponds to BS0477; and I don't have any other morphs/reconstructions of cells used to obtain the sCRACM maps.
3) The morph of BS0477 looks very different to BS0284. Since I also want to compare the 2d map distribution (not just the radial), the BS0477 sCRACM map is probably not the best to extract info in the x dimension (of course, I don't know how different the morphs of cells of other sCRACM maps are either)
4) I'm using BS0284 in the net, so it would be good to use an sCRACM map of a cell with a similar soma depth.

---------

I think we briefly discussed this in prev emails.
Okay. I'm sure you're right about this, I know we discussed a lot.
These are just my thoughts at present.

The reasons I'm using
BS0284 morph with sCRACM maps are:
1) I'm not sure of the soma depth of BS0477 (guess ~770 um based on morph
and -367 value in setupGrid()).
Regarding grid alignment and soma depth, there are two issue: (1)
where the grid was relative to the cell during mapping (rotation and
offsets), and (2) what the soma depth is relative to pia, and together
with cortical thickness, its yfrac. In a perfect experiment these
measurements would all be consistent. However, during the mapping
there are errors in rotating the grid to match radial axis of the cell
or the pia, and in aligning the grid in x, and also in pin-pointing
the location of the soma (all I can see at low-magnification is the
pipette, and its tip is sub-resolution and buried in the slice). After
reconstructing we see the soma precisely, but it can be difficult to
identify the pia and WM in exactly the same way as in the live slice.
Also, the slice shrinks prior to reconstructing - I try to measure and
compensate. Then there's rotation: hard to align the reconstruction
exactly as it was during mapping. For all these reasons, "alignment"
for simulating the map is a challenge - this is exactly where I
stopped my efforts when Gordon said to cease modeling. But I have done
a fair bit of work already towards this challenge, and hopefully in
the future we can make use of that. For example, see the file
"soma-relative-to-grid.mat" in the ZIP that I sent earlier in this
thread.

All this is good reason why I think it's better to focus on the radial
distribution for now, and not look at 2D distributions until we can
properly solve the alignment problem.

That said, the soma depth (from mapping) is in the .mat file that I
included in a ZIP earlier in this thread: "m1l23-to-m1-csp.mat"
You can look up the cell ID, sy (soma depth), and the raw maps and
vectors in that .mat file.

2) I don't know what sCRACM map corresponds to BS0477; and I don't have any
other morphs/reconstructions of cells used to obtain the sCRACM maps.
The reconstructions are all on neuromorpho.org and the maps are in
"m1l23-to-m1-csp.mat" file.

3) The morph of BS0477 looks very different to BS0284. Since I also want to
compare the 2d map distribution (not just the radial), the BS0477 sCRACM map
is probably not the best to extract info in the x dimension (of course, I
don't know how different the morphs of cells of other sCRACM maps are
either)
Without solving the alignment properly, I don't think looking at 2D
synaptic density makes sense.

To be clear, you need to simulate a 2D map, but I think the synaptic
density should be a function of y only. You'll of course still get a
2D map from this, because in a 2D view of the dendrites the dendritic
length density varies in x and y.

4) I'm using BS0284 in the net, so it would be good to use an sCRACM map of
a cell with a similar soma depth.

Have you compared the "physiological" behavior of (BS0477 morph with
BS0284 membrane) to (BS0284 morph with BS0284 membrane), i.e.
stimulating the former with current steps and seeing what you get in
terms of f-I, AP width, and so on? If this looks reasonably CSPish,
then I think it would be fine to use it in the network model, no?

I should have subthreshold current steps (under sCRACM conditions) for
BS0477, and can share these with you if you would use them now? The
idea would be to see how closely (BS0477 morph with BS0284 membrane)
simulated under sCRACM conditions fits the experimental BS0477 steps -
if good fit, then reasonable to use this.


---------

Thanks Salva! It looks good :) and this is all very exciting for me.

Quick tip: the pixels don't look square - but since both x and y axes are um and the grid was square, I think they should. Try using "axis equal; axis tight;" command in Matlab - or what tool are you using?

Question: "Rescaled uniform sim" means that it is now non-uniform, rescaled via one iteration based on ratio exp/uniform, and now represent (hopefully) the real synaptic density - yes? Just making sure I follow your labels correctly.


Wahoo, guess what I just found? Non-sCRACM isteps for BS0477. I explain this all within a txt file in the attached ZIP. Briefly: at the beginning of an sCRACM mapping experiment, when patching the first cell of the day generally, I started without TTX and 4-AP in the bath. So I'd patch a cell, and then flash blue light with an LED to make sure that I could see at least some response from the ChR2. Once confirmed that there's a response like this, I would then add the TTX and 4-AP to the bath and wait a few minutes before commencing mapping in sCRACM mode. So BS0477 happened to be the first cell that I patched that day, and in this case I used the opportunity to record some isteps before I added the drugs to the bath. So we actually have spiking data from this cell - but, it's at room temperature (21.7C in this case). Still, hopefully this is useful for calibration. And I also have subthreshold isteps recorded after the drugs were added, i.e. in sCRACM mode. So together I think this should allow for pretty decent constraints on the model!

Have a look at the attached ZIP file - I also included some images, which may be useful for making a little figure if you want, or to measure dimensions. And there are some additional traces beyond what I described above (for example, LED stimulation in CRACM and sCRACM modes).

By the way, Fig. 5A in my "Reciprocal" paper explains graphically how sCRACM mapping works. If you'd like to use it on your
poster, go ahead. Probably you an just zoom in to the PDF and screenshot it. But if you want the original vector file, just
let me know.

*** Notes from Ben on slack (16nov10)
SLACK log 11/10/2016
Seeing a bunch of earlier messages here. I used to get Slack notifications when I was mentioned, but I guess that stopped at some point in the past. Anyhow I did a search through the history. Just some brief comments:
1. Salva's AP width comments: note that "AP width" is measured as the FWHM. At phys temp this is around 0.65 ms for CSP,
   longer for LTS interneurons, even longer for CSTR, and the fastest are still FS interneurons (0.3-0.4 ms). FWHM is the
   width between rising and falling edge of the AP, measured half-way between threshold and peak. AP width measurements are
   heavily influenced by access resistance - higher Racc, longer apparent APs. I did all the AP width characterization a long
   time ago (like 2009/10), but pretty much simultaneously for all 4 cell types. In my more recent recordings of CSTR (which
   I did for our U01 last year), it seems like the CSTR AP width that I measure is shorter (faster) than in that earlier
   study - to the point where I don't know how much of a difference there is between CSP and CSTR. I have not yet quantified
   these new CSTR intrinsics, because my focus was on the morphology. But I'm organizing the data - slowly - to be able to do
   this efficiently. One important difference is that back on 2009/10 I was recording from mice aged ~P21-P28. For that same
   study, after reviews, I also recorded from older animals (up to P120), but I only did this for CSP because that was the
   focus / what reviewers asked. The answer for CSP was that AP width was largely unchanged with age (although a slight trend
   towards getting faster) - this is all in the CerCor paper. My recent CSTR recordings were done in older animals, meaning
   adult (I believe around 6-8 weeks old) - so it's possible that CSTR APs get faster with age, or it's possible that the
   faster APs are due to my patching ability getting better (and thus Rs being lower than in
2009/10). That last thing is something I should be able to quantify to some degree.
Furthermore, the "adaptation" of firing rate seems less evident in my recent CSTR recordings. Again, still need to quantify.
These are all things I've mentioned to (at least) Sam already, just want to raise it again here.
ben.suter [11:30AM]
2. CSTR ephys data and reconstructions: I'm working on this, it's just tedious and slow and I'm already stretched thin. But
   I've made progress. This boils down to going through my notes, identifying the promising recordings, checking the traces
   to confirm that it passes quality control, and then packaging these traces up together with notes, images and - when
   available - morphology. I think we'll end up with N=17 CSTR with 34C intrinsics. Good news is that I did a lot more stuff
   with these cells than back in 2009/10, meaning that we have more than just 1-second current step families to work with,
   and hence many additional constraints on optimization. Spike stim (very short, high amplitude stim, to generate a single
   AP at low latency; repeated 4x for averaging). comboneg: subthreshold, low amplitude current steps of both long and short
   duration, with amplitude chosen to give small responses; but then repeated 30x so that after averaging you get a very
   smooth trace - purpose is to constrain passive parameters. Chirps/PRBS: two different ways of examining the frequency
   response, via ZAP. A subset of the 17 neurons also has paired morphology.
This data set is my main focus (in my spare time), because I think it holds a fair bit of promise: it will allow us to apply
multiple fitting approaches and compare the relative outcomes. First, fitting a membrane model to the paired morph + traces,
and doing this independently for ~10 such neurons. Second, repeating this but holding some parameters fixed across this
population - channel kinetics, mainly, maybe also Ih gradient. In theory, one could do this systematically for each parameter
in the model - the idea being that if you find a parameter that, when held fixed across the population, still results in fits
that are as good as when you let this parameter be optimized individually for each cell, then this is good reason to use a
fixed final parameter. On the other hand, this approach could identify parameters that seem to be variable across the
population. If so, somebody could do some targeted pharmacology experiments to confirm this. Third, using all the traces and
morphology (not just paired), i.e. swapping traces and morphology in all(?) possible combinations, and then optimizing across
this very large population (N=17 sets of traces and N=19 morphologies, combined as desired). What's neat is that within this
population there will be a small subset that are the "true pairs". My hunch is that by analyzing the performance (and
evolution) of these "true pairs" within the larger "mixed pairs" population, we can find something useful. Finally, we can
put it all in the network and ask what the effects are on the network of (a) a single CSTR membrane model, (b) ~10 membrane
models that are paired with their real morphologies, (c) large set of mixed (un-paired) models.
3. sCRACM: there has been a *lot* of communication lately (and earlier) between me and Salva on email. I realize that Slack
   may have been better long-term, but email is easier for me to handle and search, etc. Hopefully we/Salva can archive those
   email chains and add to your notebook system, or whatever. I also shared my journal that I kept while developing the
   synaptic input model (including sCRACM simulation). There's a lot in there about design trade-offs and considerations of
   the model, but also specific model implementation details.
In terms of including subcellular synaptic localization in the network model, as I've said there's lots in my emails with Salva. Briefly highlighting a few points: experimentally a key finding was that CSP receive direct monosynaptic input from *every* brain areas that projects to M1 (well, every area that I looked at, which included most
sources). These inputs also directly excite L2/3, which excites CSP. So CSP seem to get long-range input twice, first directly and then (1 synapse later) via L2/3, along with disynaptic inhibition (probably also twice). This is without even engaging the rest of M1 (which follows after). To me this is a big deal, and I think provides a handle/hint as to what the local network may do. Importantly, to me this reemphasizes the point that a local M1 model is not nearly as useful as one that includes long-range inputs from other areas (incl. thalamus). At the same time, including those long-range inputs raises the question of what activity they transmit, and questions about convergence/divergence, etc. But to be more concrete: *most* of the synapses on a CSP seem to be long-range. My estimate is that ~1/6th to 1/8th of excitatory synapses on a CSP neuron are local (including from L2/3, L5, maybe L6), and the rest are from thalamus, contra M1, ipsi S1, ipsi S2, ipsi M2, and maybe some other areas to a lesser degree (contra M2, ipsi RSP?, perirhinal cortex). This probably has important implications for the way that the "purely local" M1 model is set up and runs - i.e. your external driver synapses vs. local synapes, etc.
Regarding the subcellular distributions, the important work that remains is setting up the code (and processing pipeline) in order to automatically process all of the many sCRACM maps that we have. Probably the biggest issue is aligning the maps to morphology. Recall, though, that I generally only have paired morphology + maps for the L2/3 input pathway. For all the other pathways we have the maps, but no paired morphology. The good news, though, is that my analysis of the morphology showed that CSP are *very* regular/predictable in terms of their dendritic density as a function of x and y (once you know the soma position). So long-term I think the goal should be to calculate a formulaic description of synaptic input density as a function of yfrac, for each source and post-synaptic cell type. We have data for just one cell-type, CSP (but recall that there is a barrel cortex data set also from Svoboda lab - not by cell-type, but
across more layers). Further, I expect that we'll find that synaptic density is a radial function (i.e. does not vary
horizontally). Neurons located near the edge (i.e. lateral or medial) of the axonal innervation will, of course, receive
fewer synapses and in a L/M asymmetric manner, but this would be due to dendritic / axonal overlap. If the L2/3 data supports
this expectation, then for all the datasets we'd be looking to derive S_i(y_soma, y_dend) where "i" is a specific source
(e.g. L2/3 or S2 or S2 L5), y_soma is the soma depth (or yfrac), and y_dend is the y-position (or yfrac) of each dendritic
segment.

The sCRACM dataset do show variability from cell to cell at similar yfracs, so this is something to address. My suggestion is
to start by smoothing the profiles-vs-yfrac graphs and then either fitting a smooth surface (to get S_i) or creating a binned
lookup table. We could always add some randomness for each individual cell when the network is constructed. Alternatively, we
can use the profiles without smoothing, and simply lookup the profile for closest matching yfrac. The former seems better.

Thus the initial goal is to obtain a reliable method for converting raw sCRACM maps (or y-profiles) into synaptic density y-profiles, via sCRACM simulation, which we can validate with the paired L2/3 data set. Hopefully the results show us how to convert the maps from other data sets (where we don't have the paired morphology) into synaptic density profiles as well. Initial results (from me then and Salva now) look encouraging, in the sense that so far the relationship between sCRACM response and simulated synaptic density has been simple (a linear scaling). If the same holds for the remaining paired maps+morph examples from L2/3, I would swap in morphology from cells at a similar yfrac and apply this non-simulated conversion to obtain synaptic density, simulate the mapping, and compare the simulated map to the experimental map. If the error is not bad, we could repeat this for the other datasets. However, if we find that there is no simple relationship / conversion method, then we would have to stick to using the sCRACM simulation with every map: for the
data sets where we only have the maps and no paired morphology, we would use reconstructions with closely matched yfrac (and
because CSP morphology is such a clear function of yfrac, this should be a sound approach). Either way (conversion by
scaling, or extraction by simulation) we end up with synaptic density y-profiles.

While we have sCRACM data for many inputs to CSP, I did not map this for L5 IT or PT inputs (did not work with rabies) - for
that, we should rely on studies with paired recordings and reconstructions, like (Markram et al 1997). The other thing
missing is subcellular maps of inhibitory input - not clear whether the sCRACM method would work for this. I believe others
have some data on this, with much less spatial resolution (see Adam Carter at NYU) - saw this on SfN poster, not sure if they
published it. Most of their work is in prefrontal cortex (PFC), but aside from being a different area, I think their papers
likely contain other data that would be useful for our models. Specifically in regards to the effect of various channels on
synaptic input to spines, and subcellular location effects. For example:

Little J.P. and Carter A.G. (2012) Subcellular synaptic connectivity of layer 2 pyramidal neurons in the medial prefrontal
cortex, J. Neurosci. 32(37): 12808-12819.

Seong H.J., Behnia R., and Carter, A.G. (2014) The impact of subthreshold membrane potential on synaptic responses at
dendritic spines of layer 5 pyramidal neurons in the prefrontal cortex. J. Neurophysiol. 111(10): 1960-72.

Marlin J.J. and Carter A.G. (2014) GABA-A receptor inhibition of local calcium signaling in spines and dendrites,
J. Neurosci. 34(48): 15898- 911.

(Marlin & Carter, 2014) is the one I was thinking of above, that looks at interneuron input to L5 pyramidals (in PFC), for
three classes of interneuron: PV (FS), SOM (LTS), 5HT3a.

[1:20]
============= STOP ==============

* 16oct26 Differences between HH_reduced cells individually vs net
** check mod global vars
- checked h.nmax_kdr h.celsius and correct values
** check using parallelcontext
- works ok
** iclamp
- added outside of netpyne and got same effect
** tested running non-netpyne code right after netpyne
- works ok
** h.topology() and h.List
- same
** mechs FOUND error: some params set to 0.0 not working; ASSIGNED props picked up as as PARAMS
- improve but still diffs
** geom identical
** topology identical
** h and h.cvode (global variables) identical
** setupRecording - modifies output!!!
why?:

for cell in sim.net.cells:
   sim.fih.append(h.FInitializeHandler(cell.initV))
- so actually difference was due to not setting vinit of cell
** h.run vs sim.runSim() - different results
- same as when add setupRecording()
- difference due to not setting vinit of cell

** plotting - ok?
** timer - ok
** if not do import but instead load netParams from file
- different!
- because celsius not set

** removing channels 1 by 1
- none of these had effect (visible)
      #sec.insert('ih') # h-current
      #sec.insert('ca_ion') # calcium channels
      #sec.insert('cal') # cal_mig.mod
      #sec.insert('can') # can_mig.mod
      #sec.insert('cat') # cat_mig.mod
      #sec.insert('cadad') # cadad.mod - calcium decay
      #sec.insert('kBK') # kBK.mod - ca and v dependent k channel
      #sec.insert('nap') # nap_sidi.mod
      #sec.insert('ican') # ican_sidi.mod

- remove kap
-- more hyperpol spikes in normal
-- netpyne version looking better (no weird osc)

- remove kdr
-- just 1 spike
-- almost identical
-- netpyne peak ~5-10 mV higher

- remove nax
-- identical just rises to ~-45mV

- remove k_ion, na_ion (just pas left)
-- identical just rises to ~-45mV

- only pas, nax,kdr (no params set)
-- identical with 1 spike

- added gbar_nax  gbar_kdr axon.gbar_nax kdr_vhalfn
-- identical with multiple spikes

- added k_ion na_ion
-- identical

- added ek
-- different!!!

- FOUND! -- ek an ena !!

** init.py code used to test
"""
init.py

Starting file to run NetPyNE-based model.

NetPyNE is a modularized framework to develop and run large-scale network simulations in NEURON.
Built solely in Python with MPI support.

Usage:
    python init.py # Run simulation, optionally plot a raster

MPI usage:
    mpiexec -n 4 nrniv -python -mpi init.py

Contributors: salvadordura@gmail.com
"""

runnormal=1
runnetpyne=1
compare=1

if runnormal:
	# non-netpyne
	from neuron import h
	h.load_file("stdrun.hoc")
	from pylab import *
	import sys
	import pickle
	import numpy
	#from conf import *

	useCSTR = True

	cells = []
	clamps = []
	lv = []
	lclr = ['b','r']

	if useCSTR:
		#from CSTR6 import *
		import CSTR6
		cells.append(CSTR6.CSTR6())
		clamps.append(h.IClamp(0.5,sec=cells[-1].soma))
		clamps[-1].amp=.3; clamps[-1].delay=0; clamps[-1].dur=1e3
		lv.append(h.Vector()); lv[-1].record(cells[-1].soma(0.5)._ref_v)

	vt = h.Vector(); vt.record(h._ref_t)

	h.dt=0.025
	h.tstop = tstop = 1000.0

	print cells[0].soma.v
	h.run()
	#ion()
	print 'v0 after run:',lv[0].to_python()[0]

	for v,clr in zip(lv,lclr): plot(vt,v,color=clr,linewidth=1)




if runnetpyne:
	from netpyne import sim
	from neuron import h
	from pylab import *
	h.load_file("stdrun.hoc")

	cfg, netParams = sim.readCmdLineArgs()
	sim.initialize(
	    simConfig = cfg,
	    netParams = netParams)  				# create network object and set cfg and net params
	sim.net.createPops()               			# instantiate network populations
	sim.net.createCells()              			# instantiate network cells based on defined populations
#	sim.net.connectCells()            			# create connections between cells based on params
#	sim.net.addStims() 							# add network stimulation
#	sim.setupRecording()              			# setup variables to record for each cell (spikes, V traces, etc)

	p_ek = -104.0 # these reversal potentials for in vitro conditions
	p_ena = 42.0
	for sec in sim.net.cells[0].secs.values():
		sec.hSec.ek = p_ek # K+ current reversal potential (mV)
		sec.hSec.ena = p_ena # Na+ current reversal potential (mV)

	h.v_init = sim.net.cells[0].secs.soma['vinit']
	h.dt=0.025
	h.tstop=1000.0
	clamp=h.IClamp(0.5,sec=sim.net.cells[0].secs.soma.hSec)
 	clamp.amp=0.3; clamp.delay=0; clamp.dur=1e3

 	lv = []
	lclr = ['r']
	lv.append(h.Vector()); lv[-1].record(sim.net.cells[0].secs.soma.hSec(0.5)._ref_v)
	vt = h.Vector(); vt.record(h._ref_t)

	#sim.runSim()                      			# run parallel Neuron simulation
	h.run()
	print 'v0 after run:',lv[0].to_python()[0]

	#figure()
	for v,clr in zip(lv,lclr): plot(vt,v,color=clr,linewidth=1)

	show()

#	sim.gatherData()                  			# gather spiking data and cell info from each node
#	sim.saveData()                    			# save params, cell info and sim output to file (pickle,mat,txt,etc)
#	sim.analysis.plotData()         			# plot spike raster



if compare:
	# v1_dirh=dir(h)
	# v1_dirho=dir(h.cvode)
	# v1_dich={}
	# v1_dicho={}
	# for x in v1_dirh:
	# 	if x not in ['nseg']:
	# 		try:
	# 			v=h.__getattribute__(x) #getattr(h,x)
	# 			v1_dich[x] = v
	# 		except:
	# 			pass
	# 			#print 'ERROR READING '+x
	# for x in v1_dirho:
	# 	if x not in ['nseg']:
	# 		try:
	# 			v=h.cvode.__getattribute__(x) #getattr(h,x)
	# 			v1_dicho[x] = v
	# 		except:
	# 			pass
	# 			#print 'ERROR READING '+x


	# # non-netpyne
	# from neuron import h
	# #h.load_file("stdrun.hoc")
	# from pylab import *
	# import sys
	# import pickle
	# import numpy
	# #from conf import *

	# useCSTR = True

	# cells = []
	# clamps = []
	# lv = []
	# lclr = ['b','r']

	# if useCSTR:
	#   from CSTR6 import *
	#   cells.append(CSTR6())
	#   clamps.append(h.IClamp(0.5,sec=cells[-1].soma))
	#   clamps[-1].amp=.3; clamps[-1].delay=0; clamps[-1].dur=1e3
	#   lv.append(h.Vector()); lv[-1].record(cells[-1].soma(0.5)._ref_v)

	# vt = h.Vector(); vt.record(h._ref_t)

	# h.cvode.active(0) #much faster

	# h.tstop = tstop = 1000.0

	# h.run()
	# ion()

	# for v,clr in zip(lv,lclr): plot(vt,v,color=clr,linewidth=4)
	# show()



	# v2_dirh=dir(h)
	# v2_dirho=dir(h.cvode)
	# v2_dich={}
	# v2_dicho={}
	# for x in v2_dirh:
	# 	if x not in ['nseg']:
	# 		try:
	# 			v=h.__getattribute__(x)
	# 			v2_dich[x] = v
	# 		except:
	# 			pass
# 			#print 'ERROR READING '+x
# for x in v2_dirho:
	# 	if x not in ['nseg']:
	# 		try:
	# 			v=h.cvode.__getattribute__(x) #getattr(h,x)
	# 			v2_dicho[x] = v
	# 		except:
	# 			pass
	# 			#print 'ERROR READING '+x



	# COMPARE
	c1 = sim.net.cells[0]
	c2 = cells[0]

	for secName,sec in c1.secs.iteritems():

		# check mechs
		for mechName,mech in sec.mechs.iteritems():
			for propName in mech:
				for seg in sec.hSec:
					v1 = getattr(getattr(seg, mechName, None), propName, None)
					v1b = mech[propName]
					seg2 = getattr(c2,secName,None)(seg.x)
					v2 = getattr(getattr(seg2, mechName, None), propName, None)
					if v1 != v2:
						print '\n'+secName+' '+mechName+' '+propName+' '+str(seg.x)
						print 'netpyne real  :',v1
						print 'netpyne dict  :',v1b
						print 'normal postrun:',v2

		# check geom
		for propName in sec.geom:
			v1 = getattr(sec.hSec, propName, None)
			v1b = sec.geom[propName]
			sec2 = getattr(c2,secName,None)
			v2 = getattr(sec2, propName, None)
			if v1 != v2:
				print '\n'+secName+propName+' '+str(seg.x)
				print 'netpyne real  :',v1
				print 'netpyne dict  :',v1b
				print 'normal postrun:',v2

		# check topology
		secRef = h.SectionRef(sec=sec.hSec)
        if secRef.has_parent():
            v1_parentSec = secRef.parent().sec
            v1_parentX = h.parent_connection()
            v1_childX = h.section_orientation()
        h.pop_section()  # to prevent section stack overflow

        sec2 = getattr(c2,secName,None)
       	secRef = h.SectionRef(sec=sec2)
        if secRef.has_parent():
            v2_parentX = h.parent_connection()
            v2_childX = h.section_orientation()
        h.pop_section()  # to prevent section stack overflow
        if v1_parentX != v2_parentX: print "DIFFERNT parentX"
        if v1_childX != v2_childX: print "DIFFERNT childX"


	# check h
	# for x in v2_dich:
	# 	if v2_dich.get(x,None) != v1_dich.get(x,None):
	# 		print 'netpyne: '+x+' '+str(v1_dich.get(x,None))
	# 		print 'normal : '+x+' '+str(v2_dich.get(x,None))

	# check h.cvode
	# for x in v2_dicho:
	# 	if v2_dicho.get(x,None) != v1_dicho.get(x,None):
	# 		print 'netpyne: '+x+' '+str(v1_dicho.get(x,None))
	# 		print 'normal : '+x+' '+str(v2_dicho.get(x,None))

* 16oct28 Differences between PT HH_full cell individually vs net
- mechanism parameters for secs with nseg>1
- shape3d shows wrong shape, but params look ok
-- try not setting L,diam - same
-- try creating topology first
-- importing wasn't pushing the section before reading 3dpts!! - fixed

** code to test

"""
init.py

Starting file to run NetPyNE-based model.

NetPyNE is a modularized framework to develop and run large-scale network simulations in NEURON.
Built solely in Python with MPI support.

Usage:
    python init.py # Run simulation, optionally plot a raster

MPI usage:
    mpiexec -n 4 nrniv -python -mpi init.py

Contributors: salvadordura@gmail.com
"""

runnormal=1
runnetpyne=1
compare=1

if runnormal:
    # non-netpyne
    from neuron import h,gui
    h.load_file("stdrun.hoc")
    from pylab import *
    import sys
    import pickle
    import numpy
    import cfg

    cfg=cfg.cfg

    useCSPI_full = True

    cells = []
    clamps = []
    lv = []
    lclr = ['b','r']

    if useCSPI_full:
      from PTcell import *
      cells.append(PTcell())
      clamps.append(h.IClamp(0.5,sec=cells[-1].cell.soma))
      clamps[-1].amp=.3; clamps[-1].delay=0; clamps[-1].dur=1e3
      lv.append(h.Vector()); lv[-1].record(cells[-1].cell.soma(0.5)._ref_v)
      vinitSPI_full = h.v_init


    vt = h.Vector(); vt.record(h._ref_t)

    h.cvode.active(0)
    h.dt=0.05
    h.tstop = tstop = 1000.0

    print cells[0].cell.soma.v
    h.run()
    print 'v0 after run:',lv[0].to_python()[0]

    for v,clr in zip(lv,lclr): plot(vt,v,color=clr,linewidth=1)


    v2_dirh=dir(h)
    v2_dirho=dir(h.cvode)
    v2_dich={}
    v2_dicho={}
    for x in v2_dirh:
        if x not in ['nseg']:
            try:
                v=h.__getattribute__(x)
                v2_dich[x] = v
            except:
                pass
            #print 'ERROR READING '+x
    for x in v2_dirho:
        if x not in ['nseg']:
            try:
                v=h.cvode.__getattribute__(x) #getattr(h,x)
                v2_dicho[x] = v
            except:
                pass
                #print 'ERROR READING '+x


if runnetpyne:
    from netpyne import sim
    from neuron import h,gui
    from pylab import *
    h.load_file("stdrun.hoc")

    cfg, netParams = sim.readCmdLineArgs()
    sim.initialize(
        simConfig = cfg,
        netParams = netParams)                  # create network object and set cfg and net params
    sim.net.createPops()                        # instantiate network populations
    sim.net.createCells()                       # instantiate network cells based on defined populations
#   sim.net.connectCells()                      # create connections between cells based on params
#   sim.net.addStims()                          # add network stimulation
#   sim.setupRecording()                        # setup variables to record for each cell (spikes, V traces, etc)


    h.celsius=34.0
    h.v_init = sim.net.cells[0].secs.soma['vinit']
    h.cvode.active(1)
    h.dt=0.05
    h.tstop=1000.0
    clamp=h.IClamp(0.5,sec=sim.net.cells[0].secs.soma.hSec)
    clamp.amp=0.3; clamp.delay=0; clamp.dur=1e3

    lv = []
    lclr = ['r']
    lv.append(h.Vector()); lv[-1].record(sim.net.cells[0].secs.soma.hSec(0.5)._ref_v)
    vt = h.Vector(); vt.record(h._ref_t)

    #sim.runSim()                               # run parallel Neuron simulation
    h.run()
    print 'v0 after run:',lv[0].to_python()[0]

    #figure()
    for v,clr in zip(lv,lclr): plot(vt,v,color=clr,linewidth=1)

    #show()

#   sim.gatherData()                            # gather spiking data and cell info from each node
#   sim.saveData()                              # save params, cell info and sim output to file (pickle,mat,txt,etc)
#   sim.analysis.plotData()                     # plot spike raster

    v1_dirh=dir(h)
    v1_dirho=dir(h.cvode)
    v1_dich={}
    v1_dicho={}
    for x in v1_dirh:
        if x not in ['nseg']:
            try:
                v=h.__getattribute__(x) #getattr(h,x)
                v1_dich[x] = v
            except:
                pass
                #print 'ERROR READING '+x
    for x in v1_dirho:
        if x not in ['nseg']:
            try:
                v=h.cvode.__getattribute__(x) #getattr(h,x)
                v1_dicho[x] = v
            except:
                pass
                #print 'ERROR READING '+x


if compare:

    # COMPARE
    c1 = sim.net.cells[0]
    c2 = cells[0].cell

    for secName,sec in c1.secs.iteritems():
        secNameSplit = secName.split('_')
        if len(secNameSplit) > 1:
            secInd = int(secName.split('_')[1].replace('_',''))
            sec2 = getattr(c2,secNameSplit[0],None)[secInd]
        else:
            sec2 = getattr(c2,secName,None)
        # check mechs
        for mechName,mech in sec.mechs.iteritems():
            for propName in mech:
                for seg in sec.hSec:
                    v1 = getattr(getattr(seg, mechName, None), propName, None)
                    v1b = mech[propName]
                    try:
                        seg2 = sec2(seg.x)
                        v2 = getattr(getattr(seg2, mechName, None), propName, None)
                    except:
                        v2 = 'Exception'
                    if v1 != v2:
                        print '\n'+secName+' '+mechName+' '+propName+' '+str(seg.x)
                        print 'netpyne real  :',v1
                        print 'netpyne dict  :',v1b
                        print 'normal postrun:',v2

        # check geom
        for propName in sec.geom:
            if 1: #not propName in ['L','diam']:
                v1 = getattr(sec.hSec, propName, None)
                v1b = sec.geom[propName]
                v2 = getattr(sec2, propName, None)
                if v1 != v2:
                    print '\n'+secName+' '+propName+' '+str(seg.x)
                    print 'netpyne real  :',v1
                    print 'netpyne dict  :',v1b
                    print 'normal postrun:',v2

        # check 3d geom
        secRef = h.SectionRef(sec=sec.hSec)
        numPoints = int(h.n3d())
        if numPoints:
            points = []
            for ipoint in range(numPoints):
                x = h.x3d(ipoint)
                y = h.y3d(ipoint)
                z = h.z3d(ipoint)
                diam = h.diam3d(ipoint)
                points.append((x, y, z, diam))
            v1 = points
            v1b = sec.geom.pt3d
        h.pop_section()

        secRef = h.SectionRef(sec=sec2)
        numPoints = int(h.n3d())
        if numPoints:
            points = []
            for ipoint in range(numPoints):
                x = h.x3d(ipoint)
                y = h.y3d(ipoint)
                z = h.z3d(ipoint)
                diam = h.diam3d(ipoint)
                points.append((x, y, z, diam))
            v2 = points
        h.pop_section()

        if v1 != v2:
            print '\n'+secName+' pt3d'
            print 'netpyne real  :',v1
            print 'netpyne dict  :',v1b
            print 'normal postrun:',v2


        # check topology
        secRef = h.SectionRef(sec=sec.hSec)
        if secRef.has_parent():
            v1_parentSec = secRef.parent().sec
            v1_parentX = h.parent_connection()
            v1_childX = h.section_orientation()
        h.pop_section()  # to prevent section stack overflow
        secRef = h.SectionRef(sec=sec2)
        if secRef.has_parent():
            v2_parentX = h.parent_connection()
            v2_childX = h.section_orientation()
        h.pop_section()  # to prevent section stack overflow
        if v1_parentX != v2_parentX: print "DIFFERNT parentX"
        if v1_childX != v2_childX: print "DIFFERNT childX"


    #check h
    for x in v2_dich:
        if v2_dich.get(x,None) != v1_dich.get(x,None):
            print 'netpyne: '+x+' '+str(v1_dich.get(x,None))
            print 'normal : '+x+' '+str(v2_dich.get(x,None))

    #check h.cvode
    for x in v2_dicho:
        if v2_dicho.get(x,None) != v1_dicho.get(x,None):
            print 'netpyne: '+x+' '+str(v1_dicho.get(x,None))
            print 'normal : '+x+' '+str(v2_dicho.get(x,None))

 * 16nov12 SFN'16
** Distribution of work for M1 network model
- Cell resonance -
- Synaptic distribution - sal
- Ih - sal
- Long range inputs - sal
- Plasticity -
- Information flow / functional - sal
- Oscillations (beta/gamma) -
- Transformation hypothesis STR-SPI

** Discussion with Ben
- Big paper with long range inputs, syn distribution + Ih ?
-- Ih not strong point of model, don't have dendritic recordings-- incorporate data, retune cell
-- could do paper on single PT cell with syn distirbution and test systematically short duration inputs
-- if use in network, we don't have any info on the input spiking patterns from other regions

- sCRACM methods paper?
-- need to do more work to fit membrane model to data we have from the sCRACM cells -- check if it matters
-- find out if pattern as a function fo cortical depth
-- need way to validate results? imaging data on number of spines
-- could perhaps do experiments in his lab if reviewers ask for it
-- if include in bigger paper maybe don't need so much detail

* 16nov-17mar See [[*PAPER%201][PAPER 1]]
* 17mar09 NEURON-UI
** tutorial
- just once
from: /u/salvadord/Documents/ISB/Models/NEURON-UI/libs/models/PTCell/mod
nrnivmodl

from /u/salvadord/Documents/ISB/Models/NEURON-UI/libs:
ln -s models/PTCell/mod/x86_64/ x86_64

reload page

- insert pointprocess
- space plot - click to add recording of section
- play step by step (10x)
- results - apply voltage colouring; play stepbystep

- tstop - single step

- modify /libs/Models

** loading m1
- add __init__.py so make package

- python console:
import os
os.chdir('models/m1/sim')
import m1net
net=m1net.M1net()

- javascript console:
M1net.setGeometryType("cylinders")

** m1net.py
import logging
from neuron import h

from geppettoJupyter.geppetto_comm import GeppettoCoreAPI as G
import neuron_utils
import neuron_geometries_utils


class M1net:

    def __init__(self):
        logging.debug('Loading M1net')

        neuron_utils.createProject(name='M1net')
        import init

        # h.load_file("models/m1net/cells/PTcell.hoc")
        # self.PTCell = h.PTcell()

        self.t_vec = h.Vector()
        self.t_vec.record(h._ref_t)
        neuron_utils.createStateVariable(id='time', name='time',
                              units='ms', python_variable={"record_variable": self.t_vec,
                                                           "segment": None})

        neuron_geometries_utils.extractGeometries()

        logging.debug('M1net loaded')

** random colors
in chrome javascript:

var alreadyIncluded = [""];
var cellColor = {};
var getRandomColor = function () {
    var letters = '0123456789ABCDEF';
    var color = '0x';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
};
for (var i = 0; i < 10; i++) {
    cellColor[i] = getRandomColor();
}
for (var i in GEPPETTO.getVARS().splitMeshes) {
    var segmentSplit = i.split(".");
    if (segmentSplit.length > 1) {
        var segment = segmentSplit[1];
        var segmentParsed = segment.replace(/[0-9]/g, '').replace('_', '');
        if (alreadyIncluded.indexOf(segmentParsed) == -1) {
            alreadyIncluded.push(segmentParsed);
            for (var cellColorIndex in cellColor) {
                for (var j in GEPPETTO.getVARS().splitMeshes) {
                    if (j.indexOf(segmentParsed + cellColorIndex) != -1) {
                        var mesh = GEPPETTO.getVARS().splitMeshes[j];
                        GEPPETTO.SceneController.setThreeColor(mesh.material.color, cellColor[cellColorIndex]);
                    }
                }
            }
        }
    }
}

* 17mar20 Gordon emails - update on M1 network
** to gordon
Hi Gordon,

Bill mentioned you had a meeting tomorrow and asked me to send you an update on the M1 network model.

Here you can download a pdf detailing how the model was built (including refs used in each case) and some preliminary results: https://drive.google.com/open?id=0B8v-knmZRjhtU1M0bEw4QVBpN3c

Many of the required parameters are still missing from the literature so we did our best to estimate them from what was available.

Please let us know what you think and if you have any suggestions.

Thanks!
Salva
** from grodon
Hi Salva,

Thanks, looks interesting -- lots of progress, it looks like. My main question is -- Where are you going with it?

One thing that came to my mind, for an idea that could be explored by modeling -- possibly the motor cortex (or elsewhere for
that matter) operates in different modes, or along a continuum of modes, which at the extremes could be called "IT mode" (or
IT-CT mode), in which IT neurons are highly active and PT neurons are not, and "PT mode", in which the converse is the case;
there could also be a hybrid/mixed IT-and-PT mode where everyone is active. The h-current in PT neurons could be one
regulator (itself regulated by, for example, noradrenergic input from locus ceruleus, etc), but there could be others as well
of course. For example, maybe different upstream sources (e.g. M2 vs S1), which target different subsets of M1 neurons, could
promote the one or the other mode.

Schematic cartoon depiction attached.

One major thing that's missing from the model, in my opinion, is somatosensory input. We have gotten very interested in
studying the ascending somatosensory pathways that carry tactile info from the forelimb/paw through VPL thalamus and forelimb
S1 to forelimb M1. It would be great to incorporate that in the model. It relates directly to a longstanding notion of a
"transcortical loop" that has been studied physiologically but not yet well understood at the key level of cell-type-specific
circuits (involving VPL, S1, M1, and corticospinal neurons).

-Gordon

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170320_201413.png][fig]]
** to gordon

Hi Gordon,

Thanks for feedback and schematics. The model already includes inputs from VPL, PO, S1, S2, cM1, M2 and OC based on Hooks 2013, Suter 2015 and others (see slides 7-9). However, at the moment there is no feedback from M1 to these regions, since neurons there are modeled as simple spike generators. If you have recorded spiking patterns from these regions it would be interesting to try them in the model -- currently using 1-5Hz Poisson distributed spikes (simulating background activity).

Our two main ideas to explore using the model are M1 dynamics in response to:
1. increased input from 1 or more of these regions (eg.  VPL or M2 vs S1),
2. increase/decrease h-current in PT cells.

I believe these match well with the suggestions in your email. The schematics with the different modes of operation will be very useful to guide these explorations.

Salva
** from gordon
Hi Salva,

Yes, I saw that you have modeled those long-range inputs -- what I'm referring to is specifically the forelimb (not vibrissa)
related somatosensory --> motor pathways, which have not yet been studied (for the most part).

Did you mean VL? By VPL I am referring to the ventral posterior lateral nucleus, which is the primary relay for the lemniscal
afferents carrying tactile signals from the forelimb (and other parts of the lower body). It projects to forelimb S1, not M1.

The vibrissal system is fairly different -- for one, vibrissal S1 (whisker barrel cortex) and vibrissal M1 are widely
separated, unlike other S1 and M1 for other body parts such as the arm and leg, where the S1 and M1 representations are
side-by-side (or possibly overlapping; still controversial). For another, whiskers are of course dead, and their muscles also
lack muscle spindles; and they are a 'scanning' system, unlike the forelimb.

Anyways, this is stuff for down the road a little ways; will keep you posted.

-Gordon

** to gordon
Hi Gordon,

Ah, yes that's one of my big concerns: most data used in model comes from forelimb M1, except cortical long-range input
connectivity which is from vibrissal M1 (vM1). Ben also mentioned M1 and vM1 were quite different and had reservations in
combining data from both. Do you think we should avoid using the S1, S2, cM1, M2, OC input laminar profiles and dendritic synaptic distribution (sCRACM)
from Hooks 2013? If so, do you have any insights/data/refs we can use instead?

And yes, sorry, I meant VL (not VPL). We do have a simple, loosely constrained model of rat VPL->S1 (with plasticity) that we
could potentially adapt and connect to M1 to explore the "transcortical loop" -- so if/when you have laminar/cell-type
connectivity data for this pathway, we could incorporate it into the model.

Thanks
Salva
** from gordon
In my view, data from vM1 can and should be used in cases where it's lacking for forelimb M1, I don't see a general problem
with that. Note that for S2 input, that was done by Ben, for forelimb M1 (not Hooks for vM1). And he mapped M2 inputs to
forelimb M1 corticospinals.

* 17mar22 Bug - PT v trace doesn't match spkt
** symptoms
- only for PT cells, full net sims on multiple cores (48) -- maybe for other cells but not clear
- recording also wrong - even if set 1 cell, records multiple cells - one per core - (pop, index) not working
- spkts don't match the V_soma
- potentially could be due to recent change in cell distribution -- sim.nextHost
- could be 2 different errors: cell recording vs spkt != v_soma

** finding cause
- run sim on single core
- threshold is -15 !
- also need to solve recording cells in multiple cores

* 17mar27 Meeting with gordon
** questions and meeting notes
- any data for S1 -> M1 forelimb? ok to use vibrissal S1? - not currently
- any in vivo recordings of M1 or projecting areas? - will check if something to send
- study different modes (IT, PT, hybrid) based on different inputs and H-current - frequency response
- Bopp 2017 j nsci paper - ultrasound L4  (12% conns core thalamic inputs, VL/PO; forelimb)

- diff in motor cx vs sensory cx - significant?

- VPL->S1->M1 - complex, extent of overlap of forelimb S1/M1, never localized M1 differentiated, have to tackle now
- low resolution of technique
- somatosnsory tactile info lemniscal -> S1 -> M1
- 5 linear arrays, thalamus

- 3rd week april; early may; mid may

* 17jun06 Meeting with gordon
** Depolarization block
- Bianchi 2012 (Migliore): “our model suggested that background synaptic activity in the gamma range involving less than 3%
  of the total number of excitatory synaptic inputs converging on any given CA1 pyramidal neuron, could easily generate an
  aggregate peak input current larger than 1 nA. This makes the depolarization block an important property of a neuron, since
  in a large active network several neurons will likely be in a depolarization block at any given time.”
“We suggest that this state should be explicitly taken into account by computational models at all scales of implementation.”

- possible to test in vivo/in vitro?

- Trussell 2002
“In the developing rat MNTB [auditory stem], neurons express high levels of N-methyl-D-aspartate (NMDA) receptors, whose
synaptic activation results in a ‘depolarization block’ of transmission, in which maintained depolarization prevents phasic
signaling in the postsynaptic neuron [13•]. By activating presynaptic α2-adrenergic receptors with norepinephrine, release is
inhibited, the depolarization block is relieved and phasic transmission is thereby facilitated.”

- no opinion - mostly slice so hard to know in vivo

** Test PT output as func of ih in vitro/vivo

** Test long-range inputs (and interaction with inh)

** Inh conn
Use fixed I/E ratios at cell-by-cell basis, mediated via disynaptic inhib

- Yamawaki Shepherd 2015 JNeuro
- disynaptic inhibition accompanies excitation in a precisely 'tuned' manner
- I/E ratio is specific for different presynaptic cells types, with CTs generating relatively more I (ie. higher I/E), than IT
- I is tuned to E at the level of each postsynaptic E neuron, independent of E cell type.
-- This holds in the extreme: an E neuron will get zero I if it gets zero E. If it does get E, the amount of I will be
tuned according to the I/E ratio for the presynaptic class.

- ratios fixed; absolute levels vary

** stimulation of 200 ms? random spk time; oscillations or actual recordings instead?
- explore different types


** gmgs comment
- widening of epsp - fig 9

- patterns of input vs more idealized input
- input to layer 1 vs layer 2/3 (dendritic structures, not cell bodies) - can do experimentally
- PO - can do experimentally - svoboda

- thalamocortical inputs to tuft
- they are gonna test PO -> PT (usually lack of inputs)
- also looking at VM (basal ganglia) -> PT apical tufts; probably true for csp in rostral area; possible to make prediction
-- ih regulates spk input to L1
- in retrosplenial cx, have PT neuron with thalamic input L1A, inh input

- corticocortical signaling - varying params, downstream responses are linear, scales -- another feature to model
-- vary intensity - check linear , vary by cell types (not clear, if would engage inh cells)

* 17jul11 CNS17
** poster
*** abstract
Data-driven multiscale model of mouse M1 microcircuits
Salvador Dura-Bernal1, Samuel A Neymotin1,3, Benjamin A Suter4, Gordon MG Shepherd2, William W Lytton1,5

1 Department Physiology & Pharmacology, SUNY Downstate, Brooklyn, NY 11203, USA
2 Department Physiology, Northwestern University, Chicago, IL 60611, USA
3 Department Neuroscience, Brown University, Providence, RI 02912, USA
4 Institute of Science and Technology (IST) Austria, Klosterneburg, 3400, Austria
5 Kings County Hospital Center, Brooklyn, NY 11203, USA

E-mail: 	salvadordura@gmail.com


We developed a detailed multiscale computational model of mouse primary motor cortex (M1) microcircuits, based on novel data
provided by experimentalist collaborators. The model simulates at scale a cylindrical volume with a diameter of 300 μm and
cortical depth 1350 μm of M1. It includes over 10,000 cells distributed across cortical layers based on measured cell
densities, with more than 40 million synaptic connections. Neuron models were optimized to reproduce the current-clamp
electrophysiological properties of major classes of M1 neurons, with a special emphasis on layer 5 corticospinal (SPI) and
corticostriatal (STR) neurons. Cell ionic channel distributions were constrained by literature and optimized to reproduce
with high precision in vitro recordings for these two cell types, which used detailed cell morphologies with 700+
compartments from morphological reconstructions. The network was driven by the main long-range inputs to M1: thalamus,
primary and secondary somatosensory cortex (S1, S2), contralateral M1, secondary motor cortex (M2), and orbital cortex
(OC). Local and long-range network connectivity was based on optogenetic circuit mapping studies which have demonstrated that
connection strength cannot be fully defined by layer identification but depends strongly on cortical depth and on the subtype
of pyramidal cell. Therefore highly specific synaptic input positional distribution along dendritic trees of these different
types were incorporated. We hypothesize that these distinct patterns of dendritic innervation will have different effects
that reflect roles in multiple co-existing neural coding patterns.

The model was developed using NetPyNE, a novel Python package that facilitates the development of biological neuronal
networks in the NEURON simulator, and emphasizes the incorporation of multiscale anatomical and physiological data at varying
levels of detail. Parallel simulations were executed on the XSEDE San Diego Supercomputer Center. Our M1 model incorporates
quantitative experimental data from 14 publications, therefore accumulating previously isolated knowledge into a unified
framework.

We studied the output of the 15 local M1 populations in response to increased input from each of the seven long-range inputs
modeled. Sensory information from S1, S2 and sensory thalamus primarily modulated M1 superficial layers, which projected
unidirectionally to layer 5B corticospinal neurons. Secondary motor cortical areas, as well as basal ganglia-relaying
thalamic direct inputs, also modulated the same layer 5B circuits. Firing rates, oscillations, and information transfer
(measured using Granger causality and normalized transfer entropy) demonstrated differences in dynamics and information flow
along the two parallel pathways is encoded, transformed and integrated. At the dendritic scale, the distinct innervation
patterns in corticospinal neurons facilitated the integration of information from distinct regions, and the modulatory role
of HCN (H current) ion channels, which has been hypothesized to provide a mechanism to translate action planning into action
execution.

Acknowledgments Research supported by NIH grant U01EB017695, NIH R01EB022903 and NIH R01MH086638.

*** include
Methods:
- pops + pie charts?
- CSP, STR tuning
- Ih effects, sheets?
- Long rane conn profiles; acc bar charts -- replot?? (exp -> model)
- local conn (exp-> model) - check sfn
- dendritic conn -

Results:
- Example 2 pathways: long -> IT2 -> PT vs long -> PT
- raster, zoomed raster, histogram, rate PSD, granger, nTE
- effect of ih (include sheets here?)

- interaction of 2 inputs?
- effect of uniform dist vs scracm


Results

* 17Sep07 Bernstein
** temp figures for paper draft / slides
- Use

- S2 input->IT->PT delay + ih modulation: v45_batch11_0_4_1
-- rasters ok
-- traces: IT5A ok, PT just 1 spk

- M2 input-> use poster

* 17Jan15 Plasticity papers suggested by Arnd Roth
- Bono17
- Bitt17
- Sjos06

* 17Nov10 Questions for gmgs (sfn) (some still pending)=
- weight reversal effect in PTs (same as CA1 pyr George09 + rat S1 fig7b) ??
- sheets fig 4 "HCN channels appear to be abundant in the basal and proximal apical dendrites as well" vs exp dist ?
- other modes of operation:
-- mixed: sensory input with low ih = IT/CT mode + PT mode = eg. S2->upper IT->PT
--- continuum?
-- CT - with L6 OC inputs?
--- not focus
-- inhib
--- no info

* 18Apr21 Email to gmgs
** questions
Hi Gordon,
Sorry for the delay getting back to you. I have been working on many of the changes you (and bill) suggested and
fixing some issues we found with the connectivity. You can see more detail in this gdoc: ....

I have 2 questions:
1) You mentioned dendritic input profiles should vary with depth. Currently, the profiles come from Hooks 2013 and Suter
   2015, and are specific for each cell type+layer. They use the cell soma as frame of reference, not absolute cortical depth
   -- as in panel G of figs 6,7,9,12 in Hooks 2013. Should I be doing something different?

2) Long-range inputs from vM1 (fig 7C, Hooks 2013) project stronger to upper vs lower L5B, similar to L2/3 inputs. However,
   vM2 (fig 9C, Hooks 2013) and VL (fig 2E, Yamawaki 2015) project stronger to lower vs upper L5B. Is this a reasonable assumption to use for L5B PT cells?

Thanks
Salva

** answers
Question #1 -- now I think I understand -- you are implementing this based on layer-based averages, not the exact cortical depth of soma

Question #2 -- I would say 'no' -- there may be some differences, but they strike me as underwhelming, and not something you'd want to hang your hat on, at least not quite yet  ...

BTW, the Sam paper I was referring to is this:
Synaptic information transfer in computer models of neocortical columns.
Neymotin SA, Jacobs KM, Fenton AA, Lytton WW.
J Comput Neurosci. 2011 Feb;30(1):69-84. doi: 10.1007/s10827-010-0253-4. Epub 2010 Jun 17.
PMID: 20556639
** changes
- Left VL -> L5B input as is, since Yamawaki15 elife data seems reasonable: M1 not vM1, binned laminar profile from 6 slices in
0.1 NCD steps, only L5Bupper slightly lower, but L5Bmid and L5Blower quite high.
-- Actually --  VL -> L5B profile has strong effect -- make uniforma as suggested by gordon!

- Modified M2, cM1 -> L5B, since Hooks13 data not clear: vM1 instead of M1, no data points on graph

* 18Aug23 Evol optim
** fitness function
- pop rates within range
- exponential increase from ideal rate?
- if x < minX then y=maxY
- mean across populations
- mean([min(maxY, e^(abs(x-ideal)/width) for p in pops]
-- maxY = 100
-- e.g. for PT: ideal = 10, width=2


* 19Jun12 Reproducibility issue in Don's M1 model
** cell density scale = 0.1 (indetical)
*** 8 cores
 /m1_don % mpi 8 init.py
numprocs=8
NEURON -- VERSION 7.6.1-5-g0993b3e master (0993b3e) 2018-08-09
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2018
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 mod/HCN1.mod mod/IC.mod mod/IKsin.mod mod/MyExp2SynBB.mod mod/MyExp2SynNMDABB.mod mod/ar_traub.mod mod/cadad.mod mod/cadyn.mod mod/cagk.mod mod/cal_mh.mod mod/cal_mig.mod mod/can_mig.mod mod/canin.mod mod/cat_mig.mod mod/cat_traub.mod mod/catcb.mod mod/gabab.mod mod/h_BS.mod mod/h_harnett.mod mod/h_kole.mod mod/h_migliore.mod mod/hin.mod mod/ican_sidi.mod mod/kBK.mod mod/kap_BS.mod mod/kapcb.mod mod/kapin.mod mod/kctin.mod mod/kdmc_BS.mod mod/kdr_BS.mod mod/kdrin.mod mod/nafx.mod mod/nap_sidi.mod mod/nax_BS.mod mod/savedist.mod mod/vecstim.mod
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 

Creating network of 15 cell populations on 8 hosts...
  Number of cells on node 4: 125 
  Number of cells on node 6: 125 
  Number of cells on node 1: 125 
  Number of cells on node 2: 125 
  Number of cells on node 5: 125 
  Number of cells on node 7: 125 
  Number of cells on node 0: 126 
  Number of cells on node 3: 125 
  Done; cell creation time = 4.17 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 4: 5429 
  Number of synaptic contacts on node 4: 20334 
  Number of connections on node 3: 5477 
  Number of synaptic contacts on node 3: 21959 
  Number of connections on node 0: 5731 
  Number of synaptic contacts on node 0: 22172 
  Number of connections on node 5: 5591 
  Number of synaptic contacts on node 5: 21879 
  Number of connections on node 2: 5645 
  Number of synaptic contacts on node 2: 21855 
  Number of connections on node 1: 5690 
  Number of synaptic contacts on node 1: 22470 
  Number of connections on node 6: 5693 
  Number of synaptic contacts on node 6: 23496 
  Number of connections on node 7: 5702 
  Number of synaptic contacts on node 7: 23457 
  Done; cell connection time = 9.98 s.
Adding stims...
  Number of stims on node 0: 0 
  Number of stims on node 5: 1 
  Number of stims on node 3: 0 
  Number of stims on node 4: 1 
  Number of stims on node 2: 3 
  Number of stims on node 6: 1 
  Number of stims on node 7: 3 
  Number of stims on node 1: 2 
  Done; cell stims creation time = 0.09 s.
Recording 0 traces of 0 types on node 0
Recording 0 traces of 0 types on node 5
Recording 0 traces of 0 types on node 4
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 2
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 7
Recording 0 traces of 0 types on node 6

Running simulation for 500.0 ms...
0.1 s
0.2 s
0.3 s
0.4 s
  Done; run time = 535.39 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 0.30 s.

Analyzing...
  Cells: 1001
  Connections: 0 (0.00 per cell)
  Spikes: 55 (0.11 Hz)
   IT2 : 0.035 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.960 Hz
   IT4 : 0.079 Hz
   IT5A : 0.156 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.140 Hz
   PT5B : 0.084 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.471 Hz
   IT6 : 0.000 Hz
   CT6 : 0.065 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
  Simulated time: 0.5 s; 8 workers
  Run time: 535.39 s
>>> 
>>> >>> 

>>> 
>>> 
>>> 
>>> 
Saving output as data/sM1_06-06-2019_01.json  ... 
Finished saving!
  Done; saving time = 0.60 s.
Plotting raster...
Plotting spike histogram...
  Done; plotting time = 3.01 s

Total time = 553.72 s
>>> list(sim.allSimData['spkt'])
[10.050000000100075, 10.050000000100075, 11.650000000100098, 13.650000000100126, 13.650000000100126, 15.25000000010015, 18.350000000100025, 20.750000000099888, 20.800000000099885, 26.050000000099587, 26.050000000099587, 26.90000000009954, 26.90000000009954, 27.450000000099507, 27.95000000009948, 28.10000000009947, 34.95000000009909, 35.30000000009907, 40.15000000009879, 40.15000000009879, 41.45000000009872, 41.8000000000987, 42.400000000098665, 42.70000000009865, 45.85000000009847, 48.550000000098315, 49.40000000009827, 50.850000000098184, 53.35000000009804, 55.250000000097934, 56.40000000009787, 61.900000000097556, 63.350000000097474, 64.55000000009755, 64.55000000009755, 68.50000000009845, 70.30000000009886, 75.10000000009995, 75.65000000010008, 77.20000000010043, 77.75000000010056, 77.75000000010056, 77.80000000010057, 80.10000000010109, 81.70000000010145, 83.80000000010193, 83.80000000010193, 84.15000000010201, 85.10000000010223, 88.30000000010295, 91.10000000010359, 93.20000000010407, 94.85000000010444, 98.00000000010516, 100.55000000010574]
>>> list(sim.allSimData['spkid'])
[561.0, 633.0, 346.0, 391.0, 479.0, 108.0, 250.0, 719.0, 190.0, 391.0, 479.0, 922.0, 957.0, 346.0, 719.0, 190.0, 719.0, 190.0, 391.0, 479.0, 633.0, 719.0, 190.0, 561.0, 108.0, 719.0, 190.0, 346.0, 250.0, 719.0, 190.0, 719.0, 190.0, 391.0, 479.0, 719.0, 190.0, 719.0, 346.0, 190.0, 922.0, 957.0, 633.0, 561.0, 719.0, 391.0, 479.0, 190.0, 108.0, 719.0, 190.0, 250.0, 719.0, 190.0, 346.0]
*** 12 cores
 /m1_don % mpi 12 init.py
numprocs=12
NEURON -- VERSION 7.6.1-5-g0993b3e master (0993b3e) 2018-08-09
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2018
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 mod/HCN1.mod mod/IC.mod mod/IKsin.mod mod/MyExp2SynBB.mod mod/MyExp2SynNMDABB.mod mod/ar_traub.mod mod/cadad.mod mod/cadyn.mod mod/cagk.mod mod/cal_mh.mod mod/cal_mig.mod mod/can_mig.mod mod/canin.mod mod/cat_mig.mod mod/cat_traub.mod mod/catcb.mod mod/gabab.mod mod/h_BS.mod mod/h_harnett.mod mod/h_kole.mod mod/h_migliore.mod mod/hin.mod mod/ican_sidi.mod mod/kBK.mod mod/kap_BS.mod mod/kapcb.mod mod/kapin.mod mod/kctin.mod mod/kdmc_BS.mod mod/kdr_BS.mod mod/kdrin.mod mod/nafx.mod mod/nap_sidi.mod mod/nax_BS.mod mod/savedist.mod mod/vecstim.mod
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 

Creating network of 15 cell populations on 12 hosts...
  Number of cells on node 7: 83 
  Number of cells on node 4: 84 
  Number of cells on node 5: 83 
  Number of cells on node 3: 84 
  Number of cells on node 8: 83 
  Number of cells on node 10: 83 
  Number of cells on node 6: 83 
  Number of cells on node 11: 83 
  Number of cells on node 9: 83 
  Number of cells on node 1: 84 
  Number of cells on node 2: 84 
  Number of cells on node 0: 84 
  Done; cell creation time = 5.06 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 8: 3564 
  Number of synaptic contacts on node 8: 13047 
  Number of connections on node 4: 3712 
  Number of synaptic contacts on node 4: 13797 
  Number of connections on node 2: 3777 
  Number of synaptic contacts on node 2: 14332 
  Number of connections on node 6: 3646 
  Number of synaptic contacts on node 6: 14304 
  Number of connections on node 7: 3678 
  Number of synaptic contacts on node 7: 14941 
  Number of connections on node 1: 3743 
  Number of synaptic contacts on node 1: 14777 
  Number of connections on node 5: 3803 
  Number of synaptic contacts on node 5: 14813 
  Number of connections on node 9: 3735 
  Number of synaptic contacts on node 9: 14759 
  Number of connections on node 11: 3648 
  Number of synaptic contacts on node 11: 15155 
  Number of connections on node 3: 3853 
  Number of synaptic contacts on node 3: 15320 
  Number of connections on node 0: 3884 
  Number of synaptic contacts on node 0: 15662 
  Number of connections on node 10: 3915 
  Number of synaptic contacts on node 10: 16715 
  Done; cell connection time = 16.05 s.
Adding stims...
  Number of stims on node 6: 0 
  Number of stims on node 1: 0 
  Number of stims on node 7: 1 
  Number of stims on node 9: 3 
  Number of stims on node 0: 1 
  Number of stims on node 11: 2 
  Number of stims on node 10: 4 
  Number of stims on node 2: 0 
  Number of stims on node 3: 0 
  Number of stims on node 5: 0 
  Number of stims on node 8: 0 
  Number of stims on node 4: 0 
  Done; cell stims creation time = 0.12 s.
Recording 0 traces of 0 types on node 5
Recording 0 traces of 0 types on node 9
Recording 0 traces of 0 types on node 0
Recording 0 traces of 0 types on node 8
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 11
Recording 0 traces of 0 types on node 4
Recording 0 traces of 0 types on node 2
Recording 0 traces of 0 types on node 7
Recording 0 traces of 0 types on node 6
Recording 0 traces of 0 types on node 10

Running simulation for 500.0 ms...
0.1 s
0.2 s
0.3 s
0.4 s
  Done; run time = 557.53 s; real-time ratio: 0.00.

Gathering data...
>>> 
>>> >>> 
  Done; gather time = 0.32 s.
>>> 
>>> 
Analyzing...

  Cells: 1001
  Connections: 0 (0.00 per cell)
  Spikes: 55 (0.11 Hz)

   IT2 : 0.035 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.960 Hz
   IT4 : 0.079 Hz
   IT5A : 0.156 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.140 Hz
   PT5B : 0.084 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.471 Hz
   IT6 : 0.000 Hz
   CT6 : 0.065 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
  Simulated time: 0.5 s; 12 workers
  Run time: 557.53 s
>>> >>> 

>>> 
>>> 
>>> >>> 

Saving output as data/sM1_06-06-2019_01_12cores.json  ... 
Finished saving!
  Done; saving time = 0.98 s.
Plotting raster...
Plotting spike histogram...
  Done; plotting time = 3.17 s

Total time = 583.45 s
>>> sim.analysis.plotRaster(saveFig=1)
Plotting raster...
(<Figure size 1000x800 with 1 Axes>, {'include': ['allCells'], 'spkts': [10.050000000100075, 10.050000000100075, 11.650000000100098, 13.650000000100126, 13.650000000100126, 15.25000000010015, 18.350000000100025, 20.750000000099888, 20.800000000099885, 26.050000000099587, 26.050000000099587, 26.90000000009954, 26.90000000009954, 27.450000000099507, 27.95000000009948, 28.10000000009947, 34.95000000009909, 35.30000000009907, 40.15000000009879, 40.15000000009879, 41.45000000009872, 41.8000000000987, 42.400000000098665, 42.70000000009865, 45.85000000009847, 48.550000000098315, 49.40000000009827, 50.850000000098184, 53.35000000009804, 55.250000000097934, 56.40000000009787, 61.900000000097556, 63.350000000097474, 64.55000000009755, 64.55000000009755, 68.50000000009845, 70.30000000009886, 75.10000000009995, 75.65000000010008, 77.20000000010043, 77.75000000010056, 77.75000000010056, 77.9500000001006, 80.10000000010109, 81.70000000010145, 83.80000000010193, 83.80000000010193, 84.15000000010201, 85.10000000010223, 88.30000000010295, 91.10000000010359, 93.20000000010407, 94.85000000010444, 98.00000000010516, 100.55000000010574], 'spkinds': [561, 633, 346, 391, 479, 108, 250, 719, 190, 391, 479, 922, 957, 346, 719, 190, 719, 190, 391, 479, 633, 719, 190, 561, 108, 719, 190, 346, 250, 719, 190, 719, 190, 391, 479, 719, 190, 719, 346, 190, 922, 957, 633, 561, 719, 391, 479, 190, 108, 719, 190, 250, 719, 190, 346], 'timeRange': [0, 500.0]})
>>> 
>>> ^D
** cell density=0.2 - diffs!!!
*** 8 cores 
/m1_don % mpi 8 init.py
numprocs=8
NEURON -- VERSION 7.6.1-5-g0993b3e master (0993b3e) 2018-08-09
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2018
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 mod/HCN1.mod mod/IC.mod mod/IKsin.mod mod/MyExp2SynBB.mod mod/MyExp2SynNMDABB.mod mod/ar_traub.mod mod/cadad.mod mod/cadyn.mod mod/cagk.mod mod/cal_mh.mod mod/cal_mig.mod mod/can_mig.mod mod/canin.mod mod/cat_mig.mod mod/cat_traub.mod mod/catcb.mod mod/gabab.mod mod/h_BS.mod mod/h_harnett.mod mod/h_kole.mod mod/h_migliore.mod mod/hin.mod mod/ican_sidi.mod mod/kBK.mod mod/kap_BS.mod mod/kapcb.mod mod/kapin.mod mod/kctin.mod mod/kdmc_BS.mod mod/kdr_BS.mod mod/kdrin.mod mod/nafx.mod mod/nap_sidi.mod mod/nax_BS.mod mod/savedist.mod mod/vecstim.mod
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 

Creating network of 15 cell populations on 8 hosts...
  Number of cells on node 6: 251 
  Number of cells on node 5: 251 
  Number of cells on node 2: 251 
  Number of cells on node 1: 252 
  Number of cells on node 0: 252 
  Number of cells on node 3: 251 
  Number of cells on node 4: 251 
  Number of cells on node 7: 251 
  Done; cell creation time = 9.32 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 7: 22092 
  Number of synaptic contacts on node 7: 87545 
  Number of connections on node 5: 22098 
  Number of synaptic contacts on node 5: 86416 
  Number of connections on node 6: 22333 
  Number of synaptic contacts on node 6: 86940 
  Number of connections on node 3: 22010 
  Number of synaptic contacts on node 3: 88170 
  Number of connections on node 4: 22070 
  Number of synaptic contacts on node 4: 88628 
  Number of connections on node 2: 22319 
  Number of synaptic contacts on node 2: 89376 
  Number of connections on node 1: 22398 
  Number of synaptic contacts on node 1: 88995 
  Number of connections on node 0: 22248 
  Number of synaptic contacts on node 0: 89347 
  Done; cell connection time = 35.44 s.
Adding stims...
  Number of stims on node 3: 4 
  Number of stims on node 5: 6 
  Number of stims on node 6: 6 
  Number of stims on node 2: 6 
  Number of stims on node 1: 1 
  Number of stims on node 0: 2 
  Number of stims on node 4: 6 
  Number of stims on node 7: 2 
Recording 0 traces of 0 types on node 4
Recording 0 traces of 0 types on node 7
Recording 0 traces of 0 types on node 2
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 5
Recording 0 traces of 0 types on node 6
  Done; cell stims creation time = 0.16 s.
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 0

Running simulation for 500.0 ms...
0.1 s
0.2 s
0.3 s
0.4 s
  Done; run time = 1310.98 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 1.13 s.

Analyzing...
  Cells: 2010
  Connections: 0 (0.00 per cell)
  Spikes: 135 (0.13 Hz)
   IT2 : 0.173 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.471 Hz
   IT4 : 0.144 Hz
   IT5A : 0.234 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.070 Hz
   PT5B : 0.084 Hz
   SOM5B : 0.440 Hz
   PV5B : 0.216 Hz
   IT6 : 0.121 Hz
   CT6 : 0.065 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
  Simulated time: 0.5 s; 8 workers
  Run time: 1310.98 s
Saving output as data/sM1_06-06-2019_01_8cores.json  ... 
>>> 
>>> 
>>> >>> >>> 


>>> 
>>> 
Finished saving!
  Done; saving time = 1.17 s.
Plotting raster...
Plotting spike histogram...
  Done; plotting time = 4.53 s

Total time = 1362.91 s
>>> sim.analysis.plotRaster(saveFig=1)
Plotting raster...
(<Figure size 1000x800 with 1 Axes>, {'include': ['allCells'], 'spkts': [8.750000000100057, 10.050000000100075, 10.050000000100075, 10.050000000100075, 10.050000000100075, 11.650000000100098, 11.650000000100098, 11.650000000100098, 13.650000000100126, 13.700000000100127, 14.200000000100134, 14.200000000100134, 14.200000000100134, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 17.450000000100076, 18.300000000100027, 18.350000000100025, 18.350000000100025, 18.350000000100025, 20.750000000099888, 20.90000000009988, 24.100000000099698, 24.100000000099698, 24.100000000099698, 25.950000000099593, 26.050000000099587, 26.15000000009958, 26.35000000009957, 26.55000000009956, 26.70000000009955, 26.90000000009954, 26.90000000009954, 26.90000000009954, 26.90000000009954, 28.050000000099473, 28.350000000099456, 32.00000000009925, 34.850000000099094, 35.25000000009907, 35.65000000009905, 38.500000000098886, 38.90000000009886, 39.65000000009882, 40.0000000000988, 40.15000000009879, 40.50000000009877, 40.55000000009877, 40.650000000098764, 40.650000000098764, 40.75000000009876, 40.75000000009876, 41.55000000009871, 41.55000000009871, 42.10000000009868, 42.30000000009867, 42.900000000098636, 43.90000000009858, 44.000000000098574, 44.05000000009857, 45.15000000009851, 45.50000000009849, 46.05000000009846, 49.250000000098275, 49.30000000009827, 50.10000000009823, 52.20000000009811, 52.70000000009808, 53.35000000009804, 53.35000000009804, 56.25000000009788, 57.30000000009782, 58.55000000009775, 61.00000000009761, 61.750000000097565, 62.800000000097505, 62.8500000000975, 62.9000000000975, 63.20000000009748, 64.45000000009753, 64.55000000009755, 64.55000000009755, 65.50000000009777, 66.40000000009798, 70.10000000009882, 70.95000000009901, 71.10000000009904, 71.75000000009919, 71.8000000000992, 72.2500000000993, 72.2500000000993, 72.90000000009945, 73.85000000009967, 74.35000000009978, 74.60000000009984, 75.50000000010004, 75.50000000010004, 75.70000000010009, 76.55000000010028, 77.00000000010039, 77.35000000010047, 77.75000000010056, 77.75000000010056, 79.15000000010087, 79.55000000010097, 80.10000000010109, 81.75000000010147, 81.75000000010147, 83.80000000010193, 83.90000000010195, 84.9500000001022, 86.40000000010252, 86.45000000010253, 86.50000000010255, 86.55000000010256, 86.60000000010257, 86.60000000010257, 89.00000000010311, 90.75000000010351, 90.80000000010352, 93.20000000010407, 93.20000000010407, 94.00000000010425, 96.90000000010491, 97.05000000010494, 97.70000000010509, 98.00000000010516], 'spkinds': [1355, 1061, 1125, 1130, 1234, 602, 638, 671, 886, 765, 1537, 1542, 1618, 78, 100, 132, 150, 195, 240, 244, 253, 276, 296, 1355, 550, 431, 451, 516, 394, 1461, 1537, 1542, 1618, 1355, 886, 602, 765, 638, 671, 1756, 1770, 1851, 1861, 394, 1461, 1061, 1355, 394, 1461, 78, 195, 132, 1234, 886, 1125, 150, 296, 1618, 1537, 1542, 244, 253, 240, 394, 1461, 1355, 276, 100, 765, 602, 638, 671, 394, 1461, 550, 1355, 431, 516, 394, 1461, 1061, 451, 1355, 1542, 1537, 1618, 394, 1130, 886, 1461, 602, 638, 394, 1355, 78, 1461, 195, 671, 765, 132, 150, 296, 1234, 244, 253, 1125, 1861, 394, 1851, 1756, 1770, 1461, 240, 1355, 100, 276, 886, 394, 602, 1537, 1061, 1618, 1461, 638, 1542, 1355, 550, 394, 431, 516, 1461, 765, 671, 394, 1355], 'timeRange': [0, 500.0]})

*** 18 cores
 /m1_don % mpi 18 init.py
numprocs=18
NEURON -- VERSION 7.6.1-5-g0993b3e master (0993b3e) 2018-08-09
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2018
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 mod/HCN1.mod mod/IC.mod mod/IKsin.mod mod/MyExp2SynBB.mod mod/MyExp2SynNMDABB.mod mod/ar_traub.mod mod/cadad.mod mod/cadyn.mod mod/cagk.mod mod/cal_mh.mod mod/cal_mig.mod mod/can_mig.mod mod/canin.mod mod/cat_mig.mod mod/cat_traub.mod mod/catcb.mod mod/gabab.mod mod/h_BS.mod mod/h_harnett.mod mod/h_kole.mod mod/h_migliore.mod mod/hin.mod mod/ican_sidi.mod mod/kBK.mod mod/kap_BS.mod mod/kapcb.mod mod/kapin.mod mod/kctin.mod mod/kdmc_BS.mod mod/kdr_BS.mod mod/kdrin.mod mod/nafx.mod mod/nap_sidi.mod mod/nax_BS.mod mod/savedist.mod mod/vecstim.mod
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 
	0 

Creating network of 15 cell populations on 18 hosts...
  Number of cells on node 14: 111 
  Number of cells on node 5: 112 
  Number of cells on node 2: 112 
  Number of cells on node 12: 111 
  Number of cells on node 7: 112 
  Number of cells on node 10: 112 
  Number of cells on node 3: 112 
  Number of cells on node 6: 112 
  Number of cells on node 11: 112 
  Number of cells on node 8: 112 
  Number of cells on node 1: 112 
  Number of cells on node 15: 111 
  Number of cells on node 16: 111 
  Number of cells on node 17: 111 
  Number of cells on node 13: 111 
  Number of cells on node 9: 112 
  Number of cells on node 4: 112 
  Number of cells on node 0: 112 
  Done; cell creation time = 9.79 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 1: 9360 
  Number of synaptic contacts on node 1: 34767 
  Number of connections on node 14: 9579 
  Number of synaptic contacts on node 14: 36377 
  Number of connections on node 12: 9732 
  Number of synaptic contacts on node 12: 37710 
  Number of connections on node 15: 9897 
  Number of synaptic contacts on node 15: 37267 
  Number of connections on node 2: 9725 
  Number of synaptic contacts on node 2: 37988 
  Number of connections on node 11: 9811 
  Number of synaptic contacts on node 11: 38501 
  Number of connections on node 7: 9800 
  Number of synaptic contacts on node 7: 38780 
  Number of connections on node 5: 9815 
  Number of synaptic contacts on node 5: 38901 
  Number of connections on node 4: 9854 
  Number of synaptic contacts on node 4: 39360 
  Number of connections on node 17: 9955 
  Number of synaptic contacts on node 17: 39922 
  Number of connections on node 10: 9948 
  Number of synaptic contacts on node 10: 40234 
  Number of connections on node 9: 9918 
  Number of synaptic contacts on node 9: 40295 
  Number of connections on node 16: 9934 
  Number of synaptic contacts on node 16: 40354 
  Number of connections on node 8: 9995 
  Number of synaptic contacts on node 8: 40533 
  Number of connections on node 0: 10072 
  Number of synaptic contacts on node 0: 40359 
  Number of connections on node 3: 10079 
  Number of synaptic contacts on node 3: 41262 
  Number of connections on node 13: 9963 
  Number of synaptic contacts on node 13: 41431 
  Number of connections on node 6: 10131 
  Number of synaptic contacts on node 6: 41376 
  Done; cell connection time = 51.64 s.
Adding stims...
  Number of stims on node 13: 0 
  Number of stims on node 14: 1 
  Number of stims on node 2: 0 
  Number of stims on node 4: 1 
  Number of stims on node 5: 2 
  Number of stims on node 7: 2 
  Number of stims on node 6: 6 
  Number of stims on node 10: 5 
  Number of stims on node 0: 0 
  Number of stims on node 3: 1 
  Number of stims on node 15: 2 
  Number of stims on node 9: 2 
  Number of stims on node 12: 2 
  Number of stims on node 1: 2 
  Number of stims on node 11: 0 
  Number of stims on node 8: 3 
  Number of stims on node 16: 2 
  Number of stims on node 17: 2 
Recording 0 traces of 0 types on node 15
Recording 0 traces of 0 types on node 17
Recording 0 traces of 0 types on node 1
Recording 0 traces of 0 types on node 3
Recording 0 traces of 0 types on node 5
Recording 0 traces of 0 types on node 13
  Done; cell stims creation time = 0.40 s.
Recording 0 traces of 0 types on node 7
Recording 0 traces of 0 types on node 16
Recording 0 traces of 0 types on node 0
Recording 0 traces of 0 types on node 9
Recording 0 traces of 0 types on node 2
Recording 0 traces of 0 types on node 8
Recording 0 traces of 0 types on node 11
Recording 0 traces of 0 types on node 4
Recording 0 traces of 0 types on node 6
Recording 0 traces of 0 types on node 10
Recording 0 traces of 0 types on node 14
Recording 0 traces of 0 types on node 12

Running simulation for 500.0 ms...
0.1 s
0.2 s
0.3 s
0.4 s
  Done; run time = 1186.21 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 1.44 s.

Analyzing...
  Cells: 2010
  Connections: 0 (0.00 per cell)
  Spikes: 135 (0.13 Hz)
   IT2 : 0.173 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.471 Hz
   IT4 : 0.144 Hz
   IT5A : 0.234 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.070 Hz
   PT5B : 0.084 Hz
   SOM5B : 0.440 Hz
   PV5B : 0.216 Hz
   IT6 : 0.121 Hz
   CT6 : 0.065 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
  Simulated time: 0.5 s; 18 workers
  Run time: 1186.21 s
>>> 
>>> >>> 
>>> 
>>> 

>>> 
>>> 
>>> >>> 

>>> 
>>> 
>>> 
>>> Saving output as data/sM1_06-06-2019_01_8cores.json  ... 

>>> 
>>> 
>>> 
>>> 
Finished saving!
  Done; saving time = 1.10 s.
Plotting raster...
Plotting spike histogram...
  Done; plotting time = 3.12 s

Total time = 1254.02 s
>>> sim.analysis.plotRaster(saveFig=1)
Plotting raster...
(<Figure size 1000x800 with 1 Axes>, {'include': ['allCells'], 'spkts': [8.750000000100057, 10.050000000100075, 10.050000000100075, 10.050000000100075, 10.050000000100075, 11.650000000100098, 11.650000000100098, 11.650000000100098, 13.650000000100126, 13.650000000100126, 14.200000000100134, 14.200000000100134, 14.200000000100134, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 15.25000000010015, 17.450000000100076, 18.300000000100027, 18.350000000100025, 18.350000000100025, 18.350000000100025, 20.750000000099888, 20.850000000099882, 24.100000000099698, 24.100000000099698, 24.200000000099692, 25.950000000099593, 26.050000000099587, 26.250000000099575, 26.400000000099567, 26.55000000009956, 26.750000000099547, 26.90000000009954, 26.90000000009954, 26.90000000009954, 26.90000000009954, 28.050000000099473, 28.30000000009946, 32.350000000099236, 34.850000000099094, 35.25000000009907, 35.65000000009905, 38.500000000098886, 39.00000000009886, 39.65000000009882, 40.0000000000988, 40.15000000009879, 40.15000000009879, 40.50000000009877, 40.55000000009877, 40.650000000098764, 40.70000000009876, 41.05000000009874, 41.55000000009871, 41.55000000009871, 42.10000000009868, 42.30000000009867, 42.900000000098636, 43.950000000098576, 44.000000000098574, 44.05000000009857, 44.80000000009853, 46.00000000009846, 46.05000000009846, 49.30000000009827, 49.30000000009827, 50.10000000009823, 52.20000000009811, 52.70000000009808, 52.750000000098076, 53.35000000009804, 53.35000000009804, 56.25000000009788, 57.25000000009782, 59.650000000097684, 60.25000000009765, 61.00000000009761, 61.80000000009756, 62.9000000000975, 63.20000000009748, 63.80000000009745, 64.50000000009754, 64.55000000009755, 66.40000000009798, 66.45000000009799, 68.80000000009852, 70.10000000009882, 70.95000000009901, 71.15000000009906, 71.75000000009919, 71.90000000009923, 72.2500000000993, 72.90000000009945, 73.85000000009967, 74.35000000009978, 74.60000000009984, 75.50000000010004, 75.50000000010004, 75.7500000001001, 76.55000000010028, 77.00000000010039, 77.35000000010047, 77.75000000010056, 77.75000000010056, 79.10000000010086, 79.2500000001009, 80.10000000010109, 81.70000000010145, 81.75000000010147, 83.80000000010193, 83.90000000010195, 85.15000000010224, 86.50000000010255, 86.55000000010256, 86.60000000010257, 86.65000000010258, 86.80000000010261, 87.40000000010275, 89.00000000010311, 90.75000000010351, 90.80000000010352, 92.15000000010383, 93.20000000010407, 93.20000000010407, 94.00000000010425, 97.05000000010494, 97.70000000010509, 98.05000000010517], 'spkinds': [1355, 1061, 1125, 1130, 1234, 602, 638, 671, 765, 886, 1537, 1542, 1618, 78, 100, 132, 150, 195, 240, 244, 253, 276, 296, 1355, 550, 431, 451, 516, 394, 1461, 1537, 1618, 1542, 1355, 886, 765, 602, 638, 671, 1756, 1770, 1851, 1861, 394, 1461, 1061, 1355, 394, 1461, 78, 195, 132, 1234, 886, 1537, 1125, 150, 1618, 296, 1542, 244, 253, 240, 394, 1461, 1355, 276, 100, 765, 638, 602, 394, 671, 1461, 550, 1130, 1355, 431, 516, 394, 1461, 1061, 1537, 451, 1355, 1618, 394, 1542, 1461, 886, 638, 602, 765, 394, 1355, 78, 1461, 195, 671, 132, 150, 296, 1234, 244, 253, 1125, 1861, 394, 1851, 1756, 1770, 1461, 240, 1355, 276, 100, 886, 394, 1537, 1618, 1461, 638, 602, 1061, 1542, 1355, 550, 394, 765, 431, 516, 1461, 671, 394, 1355], 'timeRange': [0, 500.0]})
*** compare net json
*** replace iclamp with netstim
*** remove iclamp location range

* 19Aug7 Converted repo to git
** code on https://github.com/salvadord/M1
http://hivelogic.com/articles/converting-from-mercurial-to-git/
https://github.com/frej/fast-export/issues/9 


/m1_git % ~/Desktop/fast-export/hg-fast-export.sh -r /u/salvadord/Models/m1 --force
git checkout HEAD

master: Exporting simple delta revision 1534/1534 with 1/0/0 added/changed/removed files
Skip .hgtags
Issued 1534 commands
/Library/Developer/CommandLineTools/usr/libexec/git-core/git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:      10000
Total objects:         9888 (       443 duplicates                  )
      blobs  :         4521 (       401 duplicates       2854 deltas of       4437 attempts)
      trees  :         3833 (        42 duplicates       3340 deltas of       3515 attempts)
      commits:         1534 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           2 (         2 loads     )
      marks:        1048576 (      1534 unique    )
      atoms:            288
Memory total:          2579 KiB
       pools:          2110 KiB
     objects:           468 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         26
pack_report: pack_mmap_calls          =         15
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  246142317 /  246142317
---------------------------------------------------------------------

** move data from neurosim to gcloud?
use command line to copy over

* CONNECTIVITY
** relevant notes, chats, emails, discussion
*** Ben - IT, CT L6; L5 PT,IT
so conn: 1) Weiler data doesn't distinguish between IT, PT, CT right?
neurosim-isb@im.partych.at
18:51 [ben.suter] Correct.
18:51 [ben.suter] In theory, should be unbiased sampling
18:51 [ben.suter] BTW this is the Kleinfeld paper:
18:51 [ben.suter] Tsai, P. S. et al. Correlations of neuronal and microvascular densities in murine cortex revealed by direct
counting and colocalization of nuclei and vessels. The Journal of Neuroscience 29, 14553-14570 (2009).

ok so just assume same values for eg. both CT and IT in layer 6?
neurosim-isb@im.partych.at
18:52 [ben.suter] Yes correct

[ben.suter] The only interlaminar cell-type specificity we know about is Anderson&Sheets for L2/3->L5
18:53 [ben.suter] Hmm, gotta check Taro's paper, he may have some stuff between L5A and L5B

[ben.suter] Kiritani et al, Figure 4: looks at relative strength of connections between L5A and L5B:
18:55 [ben.suter] L5B-PT to L5B-PT compared to L5B-PT to L5A-IT
18:56 [ben.suter] L5B-IT to L5B-PT compared to L5B-IT to L5A-IT

*** email to Ben with conn q's on integrating Weiler+A&S
1) To combine weiler+anderson+kiritani conn data, how can we normalize values from these datasets so they make sense
   together? eg. in your spreadsheet each dataset has different min,max values. Maybe just renormalize each dataset to be
   between 0 and 1?

2) To specify the model conns based on experimental data I see 3 (not exclusive) ways of doing it:
a) using bin conn matrix (10x10 or 16x16) — the model allows to specify conns for different yfrac ranges,
b) based on layers (similar to how george did it), converting the bin conn matrix to layers,
c) using a function of yfrac (eg. might want to do this for specific conns, such as L2/3->L5B)

I'd say option a) would be the more 'accurate' way of doing it, perhaps with c) for some of those conns, what do you think?

3) For interneuron conn, I have Apicella et al 2012 as a ref for E->I conns; any refs you can think of for I->E and I->I
   conns? (prev model values based on a rat S1 model developed by cliff)

4) Do you have any data to help constrain the probability vs weight of conn? The approach of prev model was generally to use
   Weiler data to decide probabilty of conn, while keeping weights relatively constant.
*** another email to Ben with conn q's
Been looking at how to combine the Weiler + Anderson conn data. Seems it would be useful to have both as conn matrix with
same granularity (eg. 16 x 16 or higher), so makes it easier to combine the data. I was re-reading some of the chats and
seems that is what we agreed on:

[ben.suter] So, where this leaves us: [ben.suter] Is that I think I need to reanalyze these data sets, so that we end up with
a connectivity matrix for each data set (there will be three to start: unlabeled, csp, cstr), where all matrices are in the
same coordinate system.  [ben.suter] And before I do that, I need to solve a sticky problem of how to set up the coordinate
system so that we can use it for the sCRACM data sets as well, and in general for connectivity.  [ben.suter] Probably: 28
bins, 50 um each, with the center of the 1st row at y=25 um, or yf=0.0357

[ben.suter] You could start with 16 bins, and interp the 10 up to 16 so they m atch
[ben.suter] But that seems silly when we have the underlying data for both, at higher resolution.

Since probably won't have time to do that for SFN poster, do you have any other suggestions as to how to combine the conn
data for this initial version of the model? I could just use the 9x9 Weiler data, and try to approx. rebin the Anderson data
to plug it in (although would lose some 'resolution'). See also related questions below.

Note: only use length-dependence for I->E and I->I? not for E->E? (guess not because have precise data)

*** response from Ben
Been looking at how to combine the Weiler + Anderson conn data. Seems it See below for an immediate solution.

Since probably won't have time to do that for SFN poster, do you have any other suggestions as to how to combine the conn
data for this initial version of the model? I could just use the 9x9 Weiler data, and try to approx. rebin the Anderson data
to plug it in (although would lose some 'resolution'). See also related questions below.  Agree about time, see solutions
below.

1) To combine weiler+anderson+kiritani conn data, how can we normalize
values from these datasets so they make sense together? eg. in your spreadsheet each dataset has different min,max
values. Maybe just renormalize each dataset to be between 0 and 1?

In theory the Glu-LSPS data is all calibrated, so the absolute magnitude should be the same when comparing same pre and post
yfrac in Weiler and A&S papers, and can be tied back to a calibrated # of presynaptic neurons (~200 as I recall). However, it
seems that the Weiler connectivity matrix has been normalized (max = 1). I hadn't realized this difference before, thanks for
bringing it up.

In the interest of time, I'll make a quick suggestion for how to proceed (but need to revisit this). The general idea is that
L5 contained the strongest inputs in Weiler (=1 when normalized). Within L5B, the A&S datasets show the CSP getting the max
input - so we should identify the max value in the A&S matrices with the max value in the Weiler matrix. As follows:

1. Truncate the negative values at 0 for Weiler, so it ranges from 0 to 1.
2. For postsynaptic IT neurons in layers 2, 3, 4, use the Weiler rows
1-3 (yfrac centers 0.15, 0.25, 0.35 respectively).
3. For postsynaptic IT and CT neurons in layer 6, use the Weiler rows
8-9 (yfrac centers 0.85, 0.95 respectively).

4. For the A&S CSP and CSTR matrix, normalize by dividing by the max
across both CSP and CSTR datasets (18.26 in the CSP), then truncate
the negative values at 0. So the CSP should range from 0 to 1, and the
CSTR from 0 to <1.
5. For postsynaptic PT neurons in layer 5B, use the A&S CSP normalized
matrix (6 rows; yfrac centers from 0.47 to 0.78, see spreadsheet).
6. For postynaptic IT neurons in layers 5A and 5B, use the A&S CSTR
normalized matrix (7 rows; 2 rows in L5A, yfrac centers 0.34 and 0.41;
5 rows in L5B, yfrac centers 0.47 to 0.72). For ITs in the deepest
part of L5B (yfrac center 0.78), assume input is zero.

2) To specify the model conns based on experimental data I see 3 (not
exclusive) ways of doing it:
a) using bin conn matrix (10x10 or 16x16) — the model allows to specify
conns for different yfrac ranges,
b) based on layers (similar to how george did it), converting the bin conn
matrix to layers,
c) using a function of yfrac (eg. might want to do this for specific conns,
such as L2/3->L5B)

I'd say option a) would be the more 'accurate' way of doing it, perhaps with
c) for some of those conns, what do you think?

I agree that all of these three ways are useful, although (2b) perhaps
less than the others. While other sources may sometimes report
experimental results "by layer", we should be able to convert their
data to our yfrac values for layer boundaries, and so should be able
to specify the connectivity within our model in terms of yfrac (binned
or distribution or function).

There is a 4th way, similar to (2a), but slightly different: using 50
bins from 0 to 1350 um (27 rows), as indicated in my "Coordinate
systems" spreadsheet - and this system has a rough correspondance of
layer to bin. I think this is the preferred way whenever the data fits
into this system. Sometimes binning at this level will be too noisy,
so being able to use original source (e.g. Weiler 9x9 matrix) may
remain useful.

3) For interneuron conn, I have Apicella et al 2012 as a ref for E->I conns;
any refs you can think of for I->E and I->I conns? (prev model values based
on a rat S1 model developed by cliff)

I haven't had time to dig into this further. As I mentioned, for starters we can assume 80% pyr, 20% interneuron in all
layers.  Initially, let's assume that they get excitatory interlaminar input same as their neighbouring pyramidal neurons. In
L5, I'd use the postsynaptic IT values for the postsynaptic interneurons.

Next phase is to use Apicella data to modify these initial E->I values. Again as an approximation it should be roughly:
inter-laminar excitatory input to interneurons in L5 should go only to LTS interneurons (use same connectivity values as if
these were postsynaptic L5 IT pyramidals) and not to FS. Intra-laminar excitatory input to interneurons in L5 should go only
to FS (use the same connectivity values as if these were postsynaptic L5 IT pyramidals), and not to LTS.

For I->E (and I->I) values, assume that they are strictly local (i.e.  ~ intra-laminar; no interlaminar inteurneuron
connections, to start).  Here I think we should assume that every interneuron contacts any other nearby neuron (pyr or
interneuron) without regard for postsynaptic cell type, in a distance-dependent manner. This will require some length
constant, there must be some data on this somewhere - if you can't find anything, let me know and I'll venture an educated
guess. Strength: I'm really not sure how strong these inhibitory connections should be, relative to E->E/I connections. I
think in general when we see disynaptic inhibition (e.g. stim longrange excitatory inputs, which directly excite M1
pyramidals, but also directly excite M1 interneurons, which then inhibit the M1 pyramidals disynaptically), the inhibition is
much stronger than the excitation. Off the top of my head, I'm not sure how to properly compare these - it depends on Vm at
the time of the synaptic input, because of driving force. I suppose therefore the particular implementation of the synapse in
the model matters too. Let's talk about this some more soon?

For I->I values, I think can treat same as what I wrote here for I->E values. But there likely are celltype-specific rules
among interneuron classes - I just don't know what we know (probably not much) - future work.

4) Do you have any data to help constrain the probability vs weight of conn?
The approach of prev model was generally to use Weiler data to decide
probabilty of conn, while keeping weights relatively constant.

In Weiler, for each stimulus, ~100 neurons each fired ~1 AP.

The somatic response for unitary local connections between L5 pyramidal neurons has been measured (in Taro's paper, for
example; and in Markram/Sakmann papers for rat). Most paired papers do current-clamp, not voltage-clamp. (like we used in
LSPS). Taro's paper doesn't report the distribution of unitary somatic EPSPs, but I'm pretty sure Taro measured that - I can
at some point try to find his data, or I/you can look at his raw traces to measure the EPSP amplitude (and time course). I
think I may have done this already for my synaptic NEURON model, not sure at the moment. I did a quick measurement of an
example trace (Fig. 6C), where the unitary EPSP CSP->CSP had an amplitude of 0.52 mV. There are other example traces given in
Fig. 7, but the scalebar is not calibrated there. We have these data, it's just a matter of finding/analyzing them.

The point is that we should be able to come up with a range/mean/variance of unitary EPSP size for E->E connections within
L5. And we know that the max unitary connections possible is 100 (for the LSPS mapping conditions). So the constraints would
be min=0, max=100 presynaptic neurons, and min/max unitary EPSP taken from Taro's L5->L5 data (or better would be a different
source for L2/3->L5 data, or at least another study showing that L2/3->L5 unitary connections have a similar strength as
L5->L5 connections, even if in rat).


A different, strong approach, combining a lot of experimental data and modeling: Recall that I have a dataset mapping out the
subcellular location of synapses on CSP neurons, originating from pyramidal neurons in L2/3 (aka L2/3->CSP sCRACM data
set). These maps are obtained under similar conditions as the Glutamate LSPS maps (room temperature, NMDA-blocked with CPP,
somatic voltage-clamp). So we could take my full CSP model, add in the L2/3 synapses in the appropriate spatial distribution
obtained from sCRACM (I've already done this in NEURON), and then simulate Glutamate LSPS in NEURON, while varying the
probability and strength of unitary L2/3->CSP connections, subject to the max of 100 presynaptic neurons. Then we compare the
simulated somatic responses to the ones obtained experimentally in Glu LSPS maps, which would tell us which combinations of
probability and strength are consistent with the experimental results. If needed, we can constrain the range of unitary
strength based on what is generally known about cortical unitary EPSPs (may require a conversion to 34C and current-clamp in
the model). The output of this effort would be an estimate of the convergence and unitary strength of L2/3->CSP pathway. Note
that this uses the CSP model in two ways: first, to estimate the relative spatial density of L2/3->CSP synapses by simulating
sCRACM and optimizing to experiment; second, to estimate the L2/3->CSP connection probability and unitary strength by
simulating Glu-LSPS and optimizing to experiment.

I think it's clear (based on having tried to do 1/2 of this proposed approach) that this is a very large effort, and not one
that can be accomplished anytime soon. But I'd urge you to keep this in mind for later stages of the U01, for a few reasons:
it demonstrates the usefulness of subcellular models and experiments so fits U01 well; it could generate estimates of
connectivity that would be very difficult / time-consuming to obtain experimentally (if even currently possible); it
represents a real productive use of the CSP membrane model; also, it does not require a full spiking CSP model, because the
CSP are voltage-clamped, NMDAR are blocked, and we're at room temperature, and the inputs are subthreshold. Most importantly:
I've already done a big chunk of this - made a suitable model, reconstructed multiple CSP for which I also have the sCRACM
data, and implemented a NEURON model that distributes synapses according to experimental sCRACM grids and simulates the
sCRACM mapping experiment in silico. The Glu-LSPS simulation would be very similar to the sCRACM simulation, basically
identical. I'd actually be very excited to work on this, since it would pull together a lot of work I've already sunk a *ton*
of time into. Perhaps we can revisit somewhere down the road if/when I have some downtime experimentally, or as a short
sabbatical or such.

------

I redid the analysis from (Weiler et al 2008), starting from the average map for each of the 102 neurons, and was able to
reproduce the connectivity matrix seen in the paper (and on ModelDB, and in my spreadsheet). However now it is no longer
normalized - the values are in pA, as is the case for the A&S CSP/CSTR data sets.

I plotted all three Glu-LSPS connectivity matrices on a single figure for comparison. They share the same yfrac scale and
alignment, and also the same intensity scale.

Note that the L2/3->L5 pathway is ~2x stronger in the Weiler matrix than in the A&S CSP (and CSTR) matrix, even though the
relative structure remains consistent. I don't have a good explanation for this, yet - I would have expected similar values
in both cases. It's possible that the A&S analysis was done differently than I understand, but I can't think of any
particular difference that would make sense.  It's possible that this ~2x difference reflects the experimenters.  I'll bring
it up with Gordon and let you know if it's an issue. In any case, all the more reason to go with the approach I suggested
above (use Weiler as standard, normalize strongest pixel in CSP and CSTR to 1).

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160805_170501.png][fig]]

*** Papers on connectivity
**** Petrof et al 2015 (J Neusci) {Petr15}:
mouse S1 -> M1 (L2/3, L5, L6)

**** Lefort et al Petersen 2009 (Neuron {Lefo09}
Excitatory Synaptic Connectivity and uEPSP Amplitudes in the Mouse C2 Barrel Column
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151005_231914.png][fig]]
**** Thomson & Lamy 2007 {Thom07}
**** Pfeffer et al 2014 {Pfef13}
- Parvalbumin expressing interneurons strongly inhibit one another but, surprisingly, provide little inhibition to other
  populations.
- In contrast, somatostatin expressing interneurons avoid inhibiting one another, yet strongly inhibit all other populations.

**** Apicella 2011
E->I, I->E (L2/3 + L5A/B) ; FS vs LTS
**** Katzel 2011
I->E all layers M1 mouse
relative densities of FS vs LTS !
**** Markram 2015
pcon and icon for mouse s1 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20151207_141140.png][fig]]

*** Ben instructions to combining Weiler + Anderson conn matrices

1. Truncate the negative values at 0 for Weiler, so it ranges from 0 to 1.
2. For postsynaptic IT neurons in layers 2, 3, 4, use the Weiler rows
1-3 (yfrac centers 0.15, 0.25, 0.35 respectively).
3. For postsynaptic IT and CT neurons in layer 6, use the Weiler rows
8-9 (yfrac centers 0.85, 0.95 respectively).
4. For the A&S CSP and CSTR matrix, normalize by dividing by the max
across both CSP and CSTR datasets (18.26 in the CSP), then truncate
the negative values at 0. So the CSP should range from 0 to 1, and the
CSTR from 0 to <1.
5. For postsynaptic PT neurons in layer 5B, use the A&S CSP normalized
matrix (6 rows; yfrac centers from 0.47 to 0.78, see spreadsheet).
6. For postynaptic IT neurons in layers 5A and 5B, use the A&S CSTR
normalized matrix (7 rows; 2 rows in L5A, yfrac centers 0.34 and 0.41;
5 rows in L5B, yfrac centers 0.47 to 0.72). For ITs in the deepest
part of L5B (yfrac center 0.78), assume input is zero.

*** Email from Ben with more details on conn
Good, I'm glad my answer was helpful. I spoke with Gordon some more today about the Glu-LSPS connectivity data sets. Two
things to discuss: normalization, and diagonals. The normalization approach I described last night is reasonable. But here's
a variant on that, which may be better.

The question is whether or not it makes sense to normalize to the peak input pixel, across the data sets? I explained above
why it makes sense, but there are limitations, and I think I found a better approach. The idea is to do everything as above,
but instead of taking the A&S CSP max value to be same as Weiler max value, normalize differently. If you look at the
non-peak values of the matrix (for example between deep layers), there seems to be a pretty good correspondence already
without rescaling. So I see two approaches:

(A) Don't normalize. The data are from calibrated experiments and shouldn't require normalization, in theory.

(B) Normalize, but not to peak pixel. I'm concerned that normalizing to the peak (a single pixel) could be problematic
because noisy. I'm not yet suggesting a specific normalization approach - I think this is more up your alley, and I'm hoping
you can make some suggestions?  Maybe normalize to the total input across the yfrac ranges that are common to both (Weiler
and A&S datasets)? So average theA&S CSP and CSTR overlapping roles, and then find overlap between that A&S combo and the
Weiler L5 data, and scale the A&S to achieve same total / average input. The A&S CSP and CSTR data sets should remain on the
same scale as each other in any case, since they were acquired in parallel.

I currently prefer approach (A), but if you can recommend a solid approach for (B), let's discuss?

Diagonals: The Glu-LSPS technique leaves "blind spots" for within-layer connections. This is because when you flash the laser
too close to the postsynaptic neuron, the glutamate directly activates the postsynaptic neuron's GluRs, in addition to
causing spikes in presynaptic neurons: we call these "direct inputs" as opposed to "synaptic inputs". Direct inputs are
distinguishable because their onset is faster (within ~7 ms) than synaptic inputs (but this detection criterion is not
foolproof). The first step in analyzing mapping data is to identify pixels where direct inputs occurred, and these pixels are
excluded from further analysis (they are set to NaN): essentially, we can't estimate the strength of synaptic input for those
pixels, due to contamination by direct inputs. Picture a bunch of black pixels punched out of the map, corresponding to the
extent of the postsynaptic dendritic arbor. So why aren't there any black spots / NaNs in the connectivity matrix? Because
each matrix pixel corresponds to an average over ~10 postsynaptic neurons, spread out over a yfrac range of ~0.1, so when one
map has a NaN pixel at a certain location, there's a chance that >=1 of the other 9 maps does not. But even so, this all
means that (a) along the diagonal of the matrix each pixel is perhaps noisier, and (b) we're almost certainly underestimating
the strength of input along the diagonal (between nearby neurons).

For nearby neurons (diagonal of the connectivity matrix), a better technique is paired recordings: and for L5, we have those,
courtesy of Taro. So ideally we would use paired recording data for connections along the diagonal (aka intra-laminar), at
least where it's available.  Taro's data has connection probability, and I think we can determine unitary strength even
though it's not reported in his paper. For other layers, we'll need to turn to the literature, which unfortunately is often
from rat. In that regard, I'd suggest we compare Taro's L5 data to rat L5 data from other labs, and if the results (Pcon,
Wuni) are similar, then good - if not, it may suggest a rat->mouse scaling factor. In any case, Alex Thompson has a review
with useful data for L6 pairs (including putative IT and CT classification). And within L2/3 there should be lots (Feldmeyer,
Sakmann, Petersen probably).  Some may be mouse, most in rat. Most will not be in M1.

What about interlaminar pairs? There are studies looking at L2/3->L5 with paired recordings (incl. I think Alex Thompson; but
also our collaborator Thanos in auditory cortex). Perhaps useful to look at what they found (Pcon, Wuni), which we could use
to compare or even calibrate our Glu-LSPS maps further. At a minimum, I think we should be aware of what those other data
sets predict (approximate Pcon, approximate Wuni), so that if our connectivity doesn't match, we know to reexamine or at
least mention in discussion, to head off reviewer concerns. But best case, these data sets would help us tease apart (Pcon,
Wuni) from Wlsps.

Finally, as Gordon said, if we need to know (Pcon, Wuni) for L2/3->L5, then we can do those experiments. They are
time-consuming.

I asked Naoki about L6, and he confirms that Thompson review (2007) is useful. It has a massive table. The problem is that I
had a quick look and it seems that the data there come from very small # of recorded pairs - and some of the numbers just
don't work out for me. It's a review, so it may still point us towards a relevant paper for IT/CT paired data in L6. A better
resource is a Petersen group Neuron paper by Lefort et al: they recorded pairs (using 8 electrodes, I think) in mouse barrel
cortex. They give PCon and Wuni (mean, std, median, range) as a matrix between all layers. Because it's barrel, we have to be
careful what we use. I think it's most useful for the diagonals (intra-laminar), because my gut tells me that intralaminar
connectivity may be more conserved across areas than interlaminar connectivity is. One thing worth doing here: compare the
Lefort paired recording results to those obtained by Glu-LSPS in barrel cortex (Shepherd & Svoboda, 2005). Those studies were
both done in mouse barrel cortex, so it would give us a way to compare/calibrate the two methods (pairs, LSPS). Gordon's
barrel cortex paper didn't do the full connectivity matrix analysis, but maybe he did it later / could do it now. I have a
feeling this is something he would not prioritize highly, but I can ask gently later in the week.

Important point: when you look at e.g. the Petersen data, you see that the highest PCon is always along the diagonal,
i.e. for intra-laminar connectivity. This makes sense, considering the axons necessarily must pass through a lot of dendrites
as they leave the home layer, i.e.  nearby neurons connect more. In contrast, in the Weiler and A&S matrices, the diagonal is
pretty weak. More evidence that the Glu-LSPS matrix probably underestimates pixels on the diagonal.

In summary:

1. Use A&S for L5 postsynaptic neurons, and Weiler for other layers;
do not normalize.

2. Plan to replace connectivity data along the diagonal, from other sources, in the near future.  2.a For L5->L5, replace the
   A&S connectivity (diagonals) with Taro's data (pairs), once I/you have time to extract the unitary strength (Pcon is
   already available in paper).  2.b. For L6->L6, replace the Weiler connectivity (diagonals) using Naoki's JNeurosci
   findings (IT/CT) and other sources (Thompson; Lefort).  2.c. For L2/3, L4, consider replacing A&S connectivity (diagonals)
   with non-M1 data (pairs) from Lefort (or others).

3. Constrain (Pcon, Wuni) inter-laminar (off-diagonal) connectivity using other sources (pairs; from Lefort, Thompson,
   Sakmann, Feldmeyer, etc.).

4. Modify inter-laminar connectivity for cell-type specificity. Taro and Naoki's papers provide some information for doing
   this, there may be other papers too. This is stuff like L6-CT <-> L5-PT connectivity, and such.

*** Meeting with Ben - notes
- need to do Do L5->L5 diagonal:
2.a For L5->L5, replace the A&S connectivity (diagonals) with Taro's
data (pairs), once I/you have time to extract the unitary strength
(Pcon is already available in paper).

- kawaguchi paper has useful data for step 2
- taro has dynamics (facilitation, depression, etc for future)

**** separating weight+pconn

- pick unitary syn strength uniform everywhere; and modify pconn based on data (0.5mv measure at soma for unitary conn);
  treat LSPS glu map as pconn; modify data where we have additional data
- interesting to see - glu data calibrated 100 presyn spikes (with V-clamp), recording at soma and see this current -
  estimate how many presyn cells are required to generate that; eg syn at 150um from soma with given strength, how many units
  need to be active to give 25pA at the soma;
- strongest input pathway = very strong convergence (30% of presyn neurons are active)
- in barrel cortex there is no strong pathway - so can't do direct connection
- conn prob in cx seem to be 5-10% at most (3 or 7); within a layer 10-20% higher (in general); never interlaminar of 50%;
  has to end up with reasonable values for all layers;
- can try diff approaches: keep constant weight, or reasonable probabilities, vary both systematically to explore within
  reasonable constraints
- if pick unitary strength 1mV (current clamp in soma), to cover spread of strengths in weiler matrix would require 100% conn
  prob - doesn't work, so need to adapt weight; combine with range of reasonable weights (tight contraint)
- Take into account cell density and horizontal spread in model - pcon is in reference to 100um wdith
- use Lefort in future

*** Combining Weiler + Anderson with Kiritani (for diagonals)
- Weiler,2008 + Anderson,2010 in raw pA (V-clamp) values obtained from Glu-LSPS (100 presyn cells/spikes)
- Kiritani have prob of conn (p_con) and unitary conn strength (i_con in mV) matrices based on paired recordings
- Weiler+Anderson diagonals wrong (underestimates) due to Glu-LSPS blind spots

- Ben: when he's comparing IT and PT, both are in L5B specifically.
Except when he then looks at L5A vs L5B ITs later.

Assume that the neurons in pairs were all within ~200 um of each other horizontally, and at roughly same cortical depth.
And hence roughly same layer. Definitely in same "bin" (50 or 100 um) radially.

So he patched CSP in L5B, CSTR in L5B, and CSTR in L5A (Fig. 4). And stimulated either CSP(L5B) or CSTR(L5A+B).

"In the preceding experiments, we recorded from corticospinal and corticostriatal neurons located side by side in layer 5B."

- Need to find comparable connection between Kiritani and Weiler/Anderson (so can scale values), candidates are:
-- IT (L5A+L5B) -> IT (L5A) == IT (L5A+L5B) -> IT (L5A) (pcon=0.111)
-- IT (L5A+L5B) -> PT (L5B) (pcon=0.209)
-- PT (L5B) -> PT (L5B) (pcon=0.039)
-- PT (L5B) -> IT (L5A+L5B) (pcon=0)

- Given layer boundaries:
Layer Boundaries (yfrac)	Feature
0	pia
0.12	L1/2 border
0.31	L3/4 border
0.42	L4/5A border
0.52	L5A/L5B border
0.77	L5B/L6 border
1	white matter


- The equivalent to this 3 pathways in the Weiler/Anderson matrix would be:
1) Kiritani IT (L5A+L5B) -> IT (L5A+L5B) (0.111):
--- Anderson 5x5 matrix (bin centers 0.46875-0.71875) mean = 2.33  std = 0.86 ==  IT+PT (L5A+L5B) -> IT (L5A+L5B)
--- Anderson 5x5 matrix (bin centers 0.46875-0.71875) only diagonals since Kiritani cells same depth: mean = 2.68, std=1.25
--- Not the same: Kiritani presyn is just IT; Anderson presyn is IT+PT; but because PT->IT = 0, then approx same
--- Conclusion: comparable

2) Kiritani IT (L5B) -> PT (L5B) (0.209):
A)
--- Anderson 5x4 matrix (bins 0.468-0.718; 0.53-0.718) mean = 3.3 std = 0.98 == IT+PT (L5A+L5B) -> PT (L5B)
--- Not the same: Kiritani presyn is just IT; Anderson presyn is IT+PT; PT->PT (L5B) != 0, so not same
--- Conclusion: NOT comparable
B)
--- Anderson 1x5 matrix (bins 0.468; 0.53-0.718) mean = 2.19 std = 0.57 == IT (L5A) -> PT (L5B)
--- Not the same: Kiritani presyn is IT L5B; Anderson presyn is L5A
--- But based on Kiritani can assume: IT L5A->PT == IT L5B->PT
--- Conclusion: maybe comparable

3) Kiritani PT (L5B) -> PT (L5B) (0.039)
--- Anderson 4x4 matrix (bins 0.53-0.718; 0.53-0.718) mean = 2.19 std = 0.57 == IT (L5A) -> PT (L5B)
--- Not the same: Kiritani presyn is only PT L5B; Anderson presyn is IT+PT L5B
--- Conclusion: NOT comparable

- Maybe can combine Kiritani pathways to make comparable:
4) Avg of Kiritani IT (L5B) -> PT (L5B) (0.209) and Kiritani PT (L5B) -> PT (L5B) (0.039)
-- Anderson 4x4 matrix (bins 0.53-0.718; 0.53-0.718) mean = 2.19 std = 0.57
-- Anderson 4x4 matrix (bins 0.53-0.718; 0.53-0.718) only diagonals since Kiritani cells same depth: mean = 3.21 std = 1.24
-- Comparable if assume presyn = 50% IT and 50% PT

**** Using only pcon-
1) IT L5 -> IT L5 (diagonal):
-- Kiritani (pcon): 0.111
-- Anderson (scon): 2.33 (understimated)

2B) IT L5A -> PT L5B:
-- Kiritani (pcon): 0.209
-- Anderson (scon): 2.19 (correct estimate)



**** Using both pcon+wcon
Note: "On average, icon did not differ by connection type for the three pathways (p=0.49, Kruskal–Wallis test)"

- Extract wcon (soma EPSP in mV in response to presyn spike)  from Kiritani (fig 6F):
1) IT (L5A+L5B) -> IT (L5A) (pcon=0.111): scon = Icon = 128/277 px = 46.21 uV = 0.04621 mV
--- wcon = scon / pcon = 0.04621 / 0.111 = 0.416 mV

2B) IT (L5A+L5B) -> PT (L5B) (pcon=0.209): scon = Icon = 180/277 px = 64.98 uV = 0.06498 mV
--- wcon = scon / pcon = 0.06498 / 0.209 = 0.311 mV

3) PT (L5B) -> PT (L5B) (pcon=0.039): scon = Icon= 58/277 px = 20.94 uV = 0.02094 mV;
--- wcon = scon / pcon = 0.02094 / 0.039 = 0.537 mV

4) Weighted sum of Kiritani IT (L5B) -> PT (L5B) and PT (L5B) -> PT (L5B)
--- scon = 0.5 * (0.209*0.311 + 0.039*0.537) = 0.042971
--- pcon = 0.5 * (0.209 + 0.039) = 0.124
--- wcon = scon/pcon = 0.3465 mV


- Compare to Anderson:
1) IT L5 -> IT L5 (diagonal):
-- Kiritatni (scon): 0.04621 (pcon=0.111; wcon=0.416 mV)
-- Anderson (scon, avg 5x5): 2.39 (underestimated because includes diagonal)
-- Anderson (scon, avg only diagonal bins): 2.68 (underestimated because all diagonals)

2B) IT L5B -> PT L5B (diagonal):
-- Kiritatni (scon): 0.06498 (pcon=0.209; wcon=0.311 mV)
-- Anderson (scon, avg 1x5): 2.19 (supposed to be correct estimate; but not clear if comparable since IT L5A->PT L5B)

4) IT+PT L5B -> PT L5B (diagonal):
-- Kiritani (scon): 0.04297 (pcon=0.124; wcon=0.3465)
-- Anderson (scon): 3.21 (underestimated because all diagonals)

To combine Kiritani:
- (a+b)/2 * (c+d)/2 == (a*c + b*d)/2 ? NO! - avg scon, avg pcon, and calculate wcon

*** Lefort layer boundaries
- Measure from fig in paper
- Varies depending on fig
- Supplementary fig shows 2 quite different distributions of layers
- From Results:
L1, 128 ± 1 mm; L2, 269 ± 2mm;L3,418±3mm;L4,588±3mm;L5A,708±4mm;L5B, 890 ± 5 mm; L6, 1154 ± 7 mm.

*** Combining Weiler + Anderson with Lefort (to constrain p_con vs i_con)
- Use IT L3->IT L5A as reference (no L3->PT L5A - Anderson,2010)
- Use IT L3->PT L5B as reference (no L3->IT L5B - Anderson,2010)

- Lefort IT L3->IT L5A: pcon (0.057) * icon (930) = Icon (53.5)
- Anderson IT L3->IT L5A: (bins 2x1 0.21825-0.2812; 0.468) = (4.5533+2.9227)/2 = 3.73

- Lefort IT L3->PT L5B: pcon (0.122) * icon (1010) = Icon (123.2)
- Anderson IT L3->PT L5B:  (bins 2x1 0.21825-0.2812; 0.53125-0.59375) = (18.3+10.4+10.3+5.8)/4 = 11.17

- Lefort ratio = 123.2/53.5 = 2.3
- Anderson ratio = 11.17/3.73 = 2.99

- Ratios match which suggests can use pcon vs icon data from Lefort

*** Updating diagonals based on Lefort
- Update diagonal values based on Lefort I_con, after normalizing all to max non-diag I_con (L3->L5B)
- For bins between 2 layers (eg. L4/L5A) use average value (eg.(L4+L5A)/2)
- Need to update also matrix values around diagonal? eg 3x3 bins of L5B? or just pure diagonal?

*** Generating 1st iteration of exc conn values
- Set all weights (unitary conn strength, i_con) to 0.5 (or 1)
- Set all probs of conn (p_con) to normalized Weiler+Anderson raw matrix (normalized based on max=18.26)
- Maybe normalize so that max = 0.3 or some p_con value obtained from Lefort! (max non-diag value = 0.122)
-- Assume: Weiler+Anderson 18.26 == Lefort 0.122 (p_con)

- Alternatively normalize based on I_con:
- Lefort max non-diag ICon is L3->L5B = 0.123
- Weiler+Anderson max non-diag ICon (equivalent) is L2/3->L5A/B = 18.26
-- Assume: Weiler+Anderson 18.26 == Lefort 0.123 (Icon)

- norm factor = 0.123/18.26

- To constrain p_con vs i_con used 2 approaches after scaling Weiler+Anderson to Lefort max non-diag I_con:
-- fix the i_con based on Lefort data, and calculate p_con = I_con/i_con (this yielded better results)
-- fix the p_con based on Lefort data, and calculate i_con = I_con/i_con
*** Inh connectivity

- (E->I) As I mentioned, for starters we can assume 80% pyr, 20% interneuron in all layers. Initially, let's assume that they get
  excitatory interlaminar input same as their neighbouring pyramidal neurons. In L5, I'd use the postsynaptic IT values for
  the postsynaptic interneurons.

- (E->I) Next phase is to use Apicella data to modify these initial E->I values. Again as an approximation it should be roughly:
  inter-laminar excitatory input to interneurons in L5 should go only to LTS interneurons (use same connectivity values as if
  these were postsynaptic L5 IT pyramidals) and not to FS. Intra-laminar excitatory input to interneurons in L5 should go
  only to FS (use the same connectivity values as if these were postsynaptic L5 IT pyramidals), and not to LTS.

- (E->I) From Apicella: aggregate output from the activated neurons, reflecting both probabilities and amplitudes of the underlying
  unitary connections (I_con).

- (I->E and I->I) values, assume that they are strictly local (i.e.~ intra-laminar; no interlaminar inteurneuron
  connections, to start).  Here I think we should assume that every interneuron contacts any other nearby neuron (pyr or
  interneuron) without regard for postsynaptic cell type, in a distance-dependent manner. This will require some length
  constant, there must be some data on this somewhere - if you can't find anything, let me know and I'll venture an educated
  guess.

- (Strength of I->E and I->I) I'm really not sure how strong these inhibitory connections should be, relative to E->E/I
  connections. I think in general when we see disynaptic inhibition(e.g. stim longrange excitatory inputs, which directly
  excite M1 pyramidals, but also directly excite M1 interneurons, which then inhibit the M1 pyramidals disynaptically), the
  inhibition is much stronger than the excitation. Off the top of my head, I'm not sure how to properly compare these - it
  depends on Vm at the time of the synaptic input, because of driving force. I suppose therefore the particular
  implementation of the synapse in the model matters too. Let's talk about this some more soon?

- (Strength of I->I), I think can treat same as what I wrote here for I->E values. But there likely are celltype-specific rules
  among interneuron classes - I just don't know what we know (probably not much) - future work.

- (I->E) Katzel 11 Nat neu has source conn densities/distribution across layers for I->E (+ relative densities of cell types)
-- Katzel: L2/3 post = 76.5% (L2/3), 16.5% (L5), 0% (L6)
           L5 post = 1.5% (L2/3), 87% (L5), 10% (L6)
	   L6 post = 0.3% (L2/3), 2.2% (L5), 97.5% (L6)
-- not strictly local, but can assume local (only intralaminar) initially


- E->I steps:
1) Simplified into L2/3, L5 and L6, and LTS vs FS (since Apicella's findings are grouped this way)
2) Initial p_con and i_con matrices taken from final E->E matrix (Weiler+Anderson raw, scaled+diagonals from Lefort); by
   averaging over corresponding bins
3a) For LTS: i_con and p_con L2/3 E -> L5A/B I used MAX instead of AVERAGE; i_con L5A/B E -> L5A/B I used MIN instead of
   AVERAGE
3b) For FS: i_con and p_con L5A/B E -> L5A/B I used MAX instead of AVERAGE; i_con L2/3 E -> L5A/B I used MIN instead of
   AVERAGE
rationale: increase the strength of pathways suggested by Apicella using p_con and i_con values consistent with E->E matrix

- I->all, I->E, I->I Exponential decay, probLambda = 100 um; GalL17 (sup fig 2); Katz11

*** Latencies/delay chat with Ben
[ben.suter] My initial assumption is that the delay between t_presynaptic_spike_at_axon_initial_segment and t_postsynaptic_EPSP_rise_at_soma is dominated by transmission at synapse and postsynaptic dendritic integration, and that the transmission time from presynaptic AIS to presynaptic axon terminal is short in comparison
[ben.suter] It's been a while since I knew/read about the actual numbers here.
[ben.suter] I should at least check Taro's pair data to figure out what the total delay is between neighbors in L5B
[ben.suter] If my assumption is correct, then the delay for local connections would have a fixed component (at synapse) and a variable component (depending on dendritic synapse location), but the physical distance between pre- and post-synaptic somata would not necessarily be a major factor.
Salvador Dura
hmm very interesting
we should definitely include all this stuff, don't think I've seen that distinction made in other models (maybe I missed)
neurosim-isb@im.partych.at
[ben.suter] I think unmyelinated AP speed is on the order of 1-10 m/s (I'll have to look for a more precise estimate in cortex), which corresponds to a soma->terminal delay of ~0.01 to 1 ms, if we roughly assume an axon length of 100um to 1mm.
[ben.suter] If you take two neighboring CSP in L5B, their soma will be at a depth of ~850 um on average.
Salvador Dura
right, so whats the approx. time for transmission at synapse and postsynaptic dendritic integration?
neurosim-isb@im.partych.at
[ben.suter] If they are connected, the axon will first dive down towards white matter a few hundred micrometers, then branch off from the main axon and take a turn up towards pia again. If it makes a synapse onto the neighbour's basal dendrites, the axonal distance would be maybe ~400 um to ~600 um. But if the synapse is in the apical tuft, I'm guessing the distance could be ~1300 um.
[ben.suter] But if you have for example a L5A neuron synapsing onto basals or apical obliques of a L5B neuron, the axon may not need to turn up again, so the distance might be just 100 um.
[ben.suter] I think the delay "at the synapse" is ~1 ms.
[ben.suter] It all depends a bit on how you measure time, i.e. the AP itself has a width of 0.5-1.5 ms depending on how you measure that.
[ben.suter] But let's say we're measuring from the inflection point of the AP onset.
[ben.suter] At the synapse first you get depolarization as the AP rises, Ca starts coming in, and so on until release of vesicles and postsynaptic binding, and influx of excitatory ions there. So for a single synaptic contact, I guess it makes sense to measure from e.g. AP inflection point to 10% rise time on the postsynaptic side (if you could measure at the dendritic location).
[ben.suter] I think that's ~1 ms, but will need to check that. In any case, it's reasonably fixed for excitatory synapses.
[ben.suter] As it is determined by (a) ion channels at the axon terminal, (b) how much Ca is needed to release vesicles, (c) diffusion and clearing of Glu in the cleft, (d) binding and sensitization at receptors.
[ben.suter] In my mind, I think that the transmission speed from dendrite to soma is lower than along an unmyelinated cortical axon. But as I write this, I realize that I may be quite wrong ... so I need to check this. Actually I should also check my previous simulations to see this.
[ben.suter] For now, my guess is that the soma-to-soma separation (at least for neurons in the same "column") likely makes up no more than 1/3rd of the total delay.
Salvador Dura
ok great, thanks for the explanation — guess we'll have to come up with better delay estimates for point neurons
neurosim-isb@im.partych.at
[ben.suter] Also, since a unitary L5->L5 connection makes 4-6 synaptic contacts, and these can be distributed across the entire dendritic arbor, a single presynaptic spike results in a spread of delays postsynaptically.
[ben.suter] I'm not saying we need to get into that much detail, though.
[ben.suter] Just that changing the soma-to-soma separation by, say, 100-200 um laterally shouldn't have a major effect on the delay.
Salvador Dura
@spread - hmm yeah thats interesting, not sure if we are planning to model multiple synaptic contacts
@soma-2-soma sep - got it, makese sense
neurosim-isb@im.partych.at
[ben.suter] And the axonal distance in the radial dimension does probably vary depending on the class of projection (i.e. from L2->L5B versus L5B->L5B), but wouldn't change much if we adjust the "sparseness"
[ben.suter] I think it'll be cool to implement this and back it up with our own data.
[ben.suter] I'll add that to my list of things to analyse ...
[ben.suter] I guess the question that remains, then is:
[ben.suter] Do we want/need to represent various aspects of the synaptic delays in a pre/post cell-type specific manner?
[ben.suter] I believe that the delay is known to be different when interneurons are involved ...
[ben.suter] So my suggestion is to implement the delay in a way that is flexible, i.e. a function that pulls from pre and post syanaptic properties:
[ben.suter] generate_delay(pre_cell, post_cell) where the function has access to properties of the cell objects, including 3D
position of soma, cell type / transmitter type, and synapse location. To start, for point neurons and a soma-to-soma delay,
I'd go with 5 ms.

*** Latencies/delays for initial version of model
- Ben summary: transmission delay only accounts for 1/3; vel= 1-10m/s; axon not straight line; use 5ms for point-point neurons
- For E->I latencies from Apicella:
"For layer 2/3 stimulation sites, the onset of IPSCs lagged that of EPSCs with a short delay for both corticostriatal and corticospinal neurons (corticostriatal, 3.1 􏲸 0.6 ms, n 􏲺 15; corticospinal, 4.2 􏲸 1 ms, n 􏲺 10; p 􏲺 0.3, t test)"
- delay = minDelay + dist/vel
-- minDelay = 3ms
-- vel = 0.5 m/s = 500 um/ms -- lower than 1-10m/s to account for non-straight axon trajectory

*** Discussion with Sam while revisiting conn

salvadord [4:22 PM]
so you took where connections for both present (E2 -> E2 lefort vs anderson) and used that to scale lefort L4 weights?

[4:16]
guess i'll get more familiar with this data...

salvadord [4:21 PM]
so based on cortical depth, seems like L4 corresponds to upper L5A in weiler + anderson&sheets

samn [4:23 PM]
so could also just extend boundary or # of cells in L5A ?

salvadord [4:24 PM]
since W + A&S only contain conn strength (Icon), I used Lefort to separate that into prob  (pcon) and weight (icon), by using the icon from Lefort, and obtaining pcons based of W+A&S

[4:24]
I also used Lefort data (both icon+pcon) for the diagonals since Ben said they were wrong in W+A&S

[4:25]
@extend boundary - you mean to remove L4?

samn [4:25 PM]
yeah

[4:25]
@separate - ic

salvadord [4:25 PM]
guess so, but why want to remove?

[4:26]
seems like a nice feature that other M1 models don't have, and that gordon has shown

samn [4:26 PM]
@remove - if it's ~within L5A

[4:27]
if really within L5A, though, then not sure why L4 rules differ

salvadord [4:27 PM]
I guess it shouldnt really matter what we call it, since conn should be ~equivalent

[4:27]
L5A conn differs wihtin layer - yfrac based

[4:27]
thats what data in W + A&S show

samn [4:28 PM]
yeah, but thought if L4 ~within L5A then the info should be present in W+A&S

salvadord [4:28 PM]
right, y thats what Im saying, that shouldnt really matter if we call it L4 or not

[4:29]
may vary in terms of what values we choose from Lefort to normalize (eg. L4 vs L5)

[4:29]
but again those should be based on yfrac

samn [4:30 PM]
ok, guess i should read through your notes to see what you did and then decide what to do...may just reduce prob and weight to keep L4 ~same input weights and probabilities as L5A

[4:30]
as you suggested...for simplification


samn [11:34 AM]
reducing excitatory synaptic weights from/to IT_L4 would reduce hyperexcitability but probably want to adjust probabilities too;
for something like this (pre -> post with probability and weight following):
('IT',0.25,0.3125) -> ('IT',0.6875,0.75), 0.00771, 1.01)
('IT',0.3125,0.375) -> ('IT',0.3125,0.375), 0.24283, 0.9
('IT',0.375,0.4375) -> ('IT',0.3125,0.375), 0.01015, 0.715)
cuts across L4 boundaries (0.31-0.41) . is it fair to cut 0.25 -0.3125 into 0.25-0.31 and 0.3 - 0.3125 and then reduce probabilities and weights for the 0.3 - 0.3125 range?

[11:35]
or maybe sufficient to adjust probabilities that are fully within IT_L4 (not the small fractions outside)

[11:36]
since this probability (0.24283): ('IT',0.3125,0.375) -> ('IT',0.3125,0.375), 0.24283, 0.9  , is pretty high

[11:38]
also noticed some redundance between weiler and anderson wiring, eg
addConn(pwmatTY, ('IT',0.3,0.4), ('IT',0.3,0.4), 0.24283, 0.95)
and
addConn(pwmatTY, ('IT',0.3125,0.375), ('IT',0.3125,0.375), 0.24283, 0.95)
won't that double some of the wiring?

[11:39]
sal - if tied up with ibm - i could work on single cell stuff and we can discuss network when you've submitted it

salvadord [11:46 AM]
L4 boundary should be 0.31-0.42 (think it was wrong in dystonia excel)

[11:50]
I think I omitted the small fractions like 0.0025 -- but if yfrac range included 2 different layers I calculated using weighted sum (I assume this refers to combining Lefort layer-based with gmgs yfrac-based)

[11:51]
@redundance - y, but only used 1 of them -- think Ben suggested to give preference to A&S over W, since more detail

samn [11:51 AM]
@redund - netpyne only uses 1 of the rules or only supposed to specify one rule?

[11:51]
think original model had both rules specified (or did i mess that up?)

salvadord [11:52 AM]
only supposed to specify 1

samn [11:52 AM]
ok, will get rid of w

salvadord [11:52 AM]
@original - it had some rules from Weiler because A&S doens't include lowe yfracs

[11:52]
but when data avail from both there should only be the one from A&S

samn [11:53 AM]
ok, so will get rid of redundance

salvadord [11:56 AM]
but yeah you're right, have duplicate rules for interval 0.3-0.4  :confused: sorry about that

samn [11:57 AM]
np, will try to clean it up anywhere there are overlapping pre/post ranges in weiler and a&s

[11:57]
bigger question is what to do with L4 but will first clean up

salvadord [12:03 PM]
I think overlap is just postyfrac 0.3-0.4 (its also evident from the excel sheets)

samn [12:04 PM]
ic, so can cut out weiler connections that have 0.3-0.4 as post

[12:04]
thx

salvadord [12:05 PM]
y, so actually I'm reading Ben's summary at the top, and he did suggest to use both but I guess it must have been a mistake

[12:05]
"2. For postsynaptic IT neurons in layers 2, 3, 4, use the Weiler rows 1-3 (yfrac centers 0.15, 0.25, 0.35 respectively)."

[12:05]
"6. For postynaptic IT neurons in layers 5A and 5B, use the A&S CSTR normalized matrix (7 rows; 2 rows in L5A, yfrac centers 0.34 and 0.41; 5 rows in L5B, yfrac centers 0.47 to 0.72)."

samn [12:07 PM]
ic, might automate overlap check just to make sure...but since you're sure, maybe will just remove 0.3,0.4 targets from weiler

salvadord [12:08 PM]
ok, so that means there's gonna be a gap 0.3-0.3125, right?

samn [12:08 PM]
though 0.3-0.3125 only in a&s

salvadord [12:08 PM]
so maybe need to just adjust the Weiler 0.3-0.4 to 0.3-0.3125 ?

[12:09]
a&s starts at 0.3125

samn [12:09 PM]
ah

@adjust - ic

[12:11]
and that's for both source and target of 0.3-0.4

[12:11]
will do that...

[12:12]
then anything > 0.3125 from weiler will be removed

[12:15]
this seems missing from a&s too: for poty in ['IT','CT']: addConn(pwmatTY, ('IT',0.3,0.4), (poty,0.8,0.9), 0.00112, 2.27)

salvadord [12:27 PM]
a&s only cover post yfrac 0.3125-0.78125

[12:27]
@both source & target - only need to do for target right?

samn [12:31 PM]
don't want to remove redundant source too?

[12:32]
looks like already removed most of redundance but still some small overlaps

[12:36]
@target - ok, makes sense

samn [12:53 PM]
cell type num_Excit_inputs num_Inhib_inputs
IT_L23 66.3853658537 29.3365853659
IT_L4 77.9906542056 29.9345794393
IT_L5A 85.8813559322 42.406779661
IT_L5B 36.4518518519 45.1777777778
PT_L5B 67.0740740741 45.6
IT_L6 18.7903225806 33.5241935484
CT_L6 18.0322580645 33.0161290323

getting rid of that redundance made IT_L4 have
more similar number of E and I inputs as the
other populations ... so may not need to further
adjust L4 too much (or at all...)

[12:57]
possibly, though this is still much higher prob than others; addConn(pwmatTY, ('IT',0.3125,0.375), ('IT',0.3125,0.375), 0.24283, 0.95)

salvadord [1:03 PM]
@similar number - great

[1:05]
much higher - y, can lower to L5A levels

samn [1:05 PM]
k will reduce, thx

samn [2:06 PM]
guess we need a CT corticothalamic model ...

[2:06]
since should differ from IT

salvadord [2:08 PM]
u mean cell model? yeah

samn [2:09 PM]
:slightly_smiling_face: , yeah i was using IT cell model but will look for a better one

salvadord [2:09 PM]
I think Ben suggested would be relatively similar to IT, and since focus of our model was L5 IT vs PT wasn't a major priority

samn [2:09 PM]
oh, ok

[2:10]
so may keep as IT for now

salvadord [2:10 PM]
but I guess if can find one, would be better

samn [2:10 PM]
will see whats out there

salvadord [2:12 PM]
uploaded an image: from Harris&Shepherd 2015
Add Comment

samn [2:12 PM]
thx, nice

salvadord [2:13 PM]
uploaded an image: Pasted image at 2016-07-22, 2:13 PM
  1 Comment

salvadord [2:14 PM]
from Yamawaki & Shepherd, 2015 -- so maybe gmgs might have some reconstructions too

samn [2:15 PM]
that would be nice .. and also a stellate cell if that's in L4 (though maybe not as much in motor)

salvadord [2:15 PM]
and guess we could potentially also update the connectivity based on that paper

samn [2:15 PM]
suppose i will ask him for recons and whether has current clamp on it

salvadord [2:15 PM]
CT conn



salvadord [8:07 PM]
so seems like gordon doesn't actually have the CT ephys, but would record some for us -- since looks like we can ask for data, is the CT ephys what we most need? maybe something else would be more useful for this grant (which focuses on SPI vs STR) ?

[8:10]
eg. Inh cells ephys, E->I or I->I connectivity, long-range inputs, ... ? (just thinking out loud here)

samn [8:43 PM]
Yeah, not sure CT is top priority bit it is a missing cell type

[8:43]
Inh seems valuable too

samn [8:51 PM]
Current clamp for the I cells could be interesting. Have to start somewhere. So depends what gmgs people have time for

salvadord [8:53 PM]
btw just found this paper which looks relevant - eg. see table 2+3 - http://journal.frontiersin.org/article/10.3389/fncel.2013.00174/full

[8:54]
seems like there's CT cells in layer 5 too (?)

samn [8:55 PM]
Thanks, so may have to add slme CT types there.

salvadord [8:56 PM]
y can ask gordon about this paper

[8:57]
/u/salvadord/Papers/Oswa13.pdf

samn [9:13 PM]
if you want, join in on the emails for suggestion...suppose gmgs may want to hear from bill too on whether CT highest priority ... though doubt gmgs will shift his experiments right away

salvadord [9:16 PM]
right, seems like he mentioned having a call to discuss so can wait for that

samn [9:17 PM]
oh, gmgs wanted call? wasn't clear what he meant by details...suppose i'll suggest it

salvadord [9:17 PM]
thats what I understood from "Let's confer about the details."

samn [9:17 PM]
ic

billl [9:20 PM]
great. he actually wants

[9:20]
to talk to us

samn [9:20 PM]
i told him, "Thanks. We could discuss details further over phone or email when Bill returns (he's out of town now). "

billl [10:02 PM]
can set it up for sometime week of Aug 1


----- July 25th -----
samn [9:07 AM]
gordon traveling that week and suggested week after or one after that ... let me know if works for you

billl [9:54 AM]
sure

samn [9:54 AM]
ok, will email him again to find day/time

samn [10:08 AM]
@L23 - so may need to normalize Weiler to Anderson/Sheets data ... take similar 2D locations and determine correspondence factor

[10:10]
any py code for the initial combination of weiler & a/s or all done in excel spreadsheet?

billl [10:11 AM]
excel :(

samn [10:12 AM]
ic, hmm

billl [10:12 AM]
oh i was just expostulating

[10:12]
don't know

samn [10:12 AM]
aha :slightly_smiling_face:

salvadord [10:17 AM]
original weiler data is in matlab, maybe a&s too -- but very easy to read data from excel to python

samn [10:18 AM]
so in original combination of w & a/s - must have been some normalization (?)

salvadord [10:18 AM]
@normalize based on 2d locations - y guess that could work if have enough overlapping points



Combining (Weiler 2008) and (Anderson&Sheets 2010) connectivity matrices after normalizing raw pA values based on Lefort data; and updating diagonals based on Lefort
Normalized by making max raw pA value (L2/3->L5B = 18.26 pA) equivalent to Lefort max non-diagonal I_con (p_con * i_con) value (L2/3->L5B = 0.123)
Normalization factor:            0.006746

samn [10:25 AM]
& lefort was used since has complete mapping between layers/types?

salvadord [10:25 AM]
(but didn't normalize Weiler + A&S with each other, or checked for consistency -- might be necessary since different cells, and different apparatus calibration, but might not be that straight forward -- remember gordon mentioning at SFN meeting that was not possible)

samn [10:25 AM]
or since had diagonals

[10:25]
gmgs said not possible, hmm

[10:26]
so should i attempt the impossible? :slightly_smiling_face:

salvadord [10:27 AM]
only overlapping dat is yfrac 0.3125-0.4 -- but then again different bins sizes for each, so guess can be tricky

[10:27]
sure, go for it

samn [10:27 AM]
so could start from W+A&S raw sheet

salvadord [10:30 AM]
ah actually the that raw sheet, has already been normalized by Ben to maximum pA -- see the prev sheets "Weiler" and "Anderson and Sheets"

[10:30]
This version has raw pA values, it has not been normalized.
This matrix was recalculated by Ben on 9/28/2015.
It has not been verified vs original study, for absolute value.
If normalized to peak (35.9944), it is similar but not exactly the same as the above normalized matrix.

[10:31]
aah no, has not been normalized, ok

samn [10:31 AM]
Combining (Weiler 2008) and (Anderson&Sheets 2010) connectivity matrices, without normalization i.e. using raw pA values

salvadord [12:52 PM]
gordon: "best would be if we could get in touch on Monday August 8th and figure out a mutually convenient time either that day or sometime that week, if that's ok"

[12:52]
sounds good to me

samn [12:53 PM]
yeah

salvadord [2:24 PM]
review of rodent barrel cortex L5 inhib circuits, might be relevant - http://journal.frontiersin.org/article/10.3389/fncir.2016.00035/full

[2:25]
describes in terms of IT and PT cells

samn [2:28 PM]
thanks

samn [3:01 PM]
set up a reminder to “schedule call with gmgs” in this channel at 9am Monday, August 8th, Eastern Daylight Time.

samn [3:02 PM]
anyone else see that reminder?

salvadord [3:26 PM]
yup see it

samn [3:27 PM]
uploaded and commented on an image: 16jul25_w_as_a1.png
1 Comment
reinterpolated weiler data to anderson/sheets CSTR grid - weiler has higher values in many places

samn [3:28 PM]
oh, guess i should have used anderson/sheets IT data

[3:28]
hmm, don't see it there

[3:28]
guess only CSP and CSTR in that xls file

salvadord [3:31 PM]
cstr=IT

samn [3:31 PM]
ah, right :slightly_smiling_face:

salvadord [3:31 PM]
think CSTR subcategory of IT

samn [3:32 PM]
i'll blame that on lack of sleep...

salvadord [3:33 PM]
:slightly_smiling_face:

[3:33]
so Weiler higher, but at least looks like similar pattern

samn [3:33 PM]
yeah, similar for where share values ... so now i can take ratio

[3:34]
and then update the mainly L23 target weights that were from weiler

salvadord [3:34 PM]
so guess that means in combined w matrix we are inflating IT < yfrac 0.3

samn [3:34 PM]
assuming can just update weights

[3:34]
you had some way of separating out weight vs probability ... suppose written in xls file too

salvadord [3:35 PM]
aah so the ones that overlap have similar values in both?

samn [3:35 PM]
@overlap - a/s look lower

[3:36]
well, let me check

salvadord [3:36 PM]
guess if similar, then not really inflating any in combined

samn [3:37 PM]
i meant similar overall pattern but not values

salvadord [3:37 PM]
separating w vs p -- yes, I take the w from Lefort and then calculate p based on W, A&S conn strengths

samn [3:38 PM]
ic, so i'll have to dump lefort to my py file too

[3:38]
and maybe reinterpolate lefort to the a/s grid

salvadord [3:44 PM]
y, I reinterpolated

[3:48]
also if recalculating, have to take into account that according to Ben  diagonals of W + AS are not correct (values lower than they should, due to experimental method) -- so suggested using those from Lefort

samn [3:53 PM]
ic, may not recalc all - just the ones need to adjust; but first want weiler / anderson ratio - so can use non-diagonals for that; if have to use lefort for diagonals should prob do afterward

salvadord [3:54 PM]
ok

samn [4:17 PM]
uploaded an image: 16jul25_w_as_a2.png
Add Comment

samn [4:18 PM]
uploaded and commented on an image: 16jul25_w_as_a3.png
1 Comment
histogram of weiler over anderson/sheets values (where in same locations and excluding diagonals) - not consistent

samn [4:18 PM]
most values in weiler > anderson/sheets; but some smaller

[4:18]
most -> more

salvadord [4:28 PM]
so what values did u use as raw A&S?

samn [4:29 PM]
from this sheet "CSTR - Anderson and Sheets"

salvadord [4:31 PM]
right... just checking those are also pA values... I assume so

samn [4:31 PM]
ic, well, since some weiler are larger and some smaller than a/s, not sure can normalize consistently...

[4:31]
could use mean but ... that could mess up some info too

salvadord [4:31 PM]
y, seems so from paper

samn [4:32 PM]
@seems so - pA, hx

[4:32]
thx

salvadord [4:32 PM]
and you rescaled Weiler values based on A&S bin sizes right?

samn [4:32 PM]
i interpolated weiler values to the a/s grid

[4:32]
using bin centers

[4:32]
as coordinates

salvadord [4:33 PM]
(probably there's a million reason why we cannot do that... but guess thats best we can do with what we have)

samn [4:33 PM]
cannot do that = re-normalize?

[4:34]
or what i did ... apparently invalid :slightly_smiling_face:

salvadord [4:36 PM]
y, re-normalize -- since these normalized grids obtained from single cells... so probably have to rescale based on original raw single cell data (which we actually have)  ... just mentioning, don't think we should try to use single cells!

samn [4:36 PM]
hmm, so guess you're in agreement with gmgs that we shouldn't re-normalize

salvadord [4:36 PM]
I just really don't know if its valid or not :disappointed:

samn [4:37 PM]
maybe i should email gmgs/ben about that too...

salvadord [4:37 PM]
would need to look in detail/understand better all the experimental data

samn [4:37 PM]
though the way we're using the data - we're treating as ~equivalent

salvadord [4:37 PM]
maybe can look through all of Ben's emails on this since already discussed for a while

samn [4:38 PM]
so whatever the details ... numbers should be similar magnitudes (generally true)

salvadord [4:38 PM]
@equivalent - y, and Ben seemed ok with that

[4:38]
u have Ben's emails right? (think were cc'ed, but otherwise in my nb)

[4:38]
I'll try to revisit next week after paper deadline

samn [4:38 PM]
will look ... thanks

samn [8:38 PM]
how'd you map lefort layers to anderson yfrac? can map using layer boundaries but also see lefort has L2 separate from L3 - know L3's yfrac range (when separated from L2) ?

salvadord [10:15 PM]
I mapped Lefort L2 onto Weiler 0.1-0.2, and L3 -> 0.2-0.3

[10:15]
guess could also do more accurately based on Lefor layer boundaries which I just found on paper: L1, 128 ± 1 mm; L2, 269 ± 2mm;L3,418±3mm;L4,588±3mm;L5A,708±4mm;L5B, 890 ± 5 mm; L6, 1154 ± 7 mm.

samn [10:16 PM]
th

[10:16]
thx

[10:17]
have yfrac for the other layers


----- July 27th -----
samn [2:30 PM]
negative numbers in weiler (and other) matrices should be set to 0 ??

[2:31]
5. In all cases, truncate negative weights to 0 when constructing the model.

salvadord [2:34 PM]
y

samn [4:19 PM]
to get connection probabilities divide weiler or anderson/sheets by lefort EPSP (i_con) ? but what units / scaling to use for lefort EPSP in order to produce proper probability?

[4:20]
likely to be details i'm missing since haven't spent as much time with this data, so maybe better to let you handle these adjustments

salvadord [4:24 PM]
ok

samn [4:25 PM]
thanks

[4:26]
/u/samn/m1np/was.py if helpful (doubt it will help you since you know this data better)

salvadord [4:32 PM]
ok thx

*** Rescaling Lefort and Andersonbased on Kiritani
- Kiritani provides wcon an pcon for L5 diagonals
- A&S L5 diagonals are underestimated so can't use as ref to compare with Kiritani (to disentangle wcon and pcon)
- Can rescale Lefort based on Kiritani, so can then used Lefort for non-diagonals

- Bins to take as ref:

-- CAN'T USE Kiritani Avg(L5 PT->PT, PT->IT, IT->PT, IT->IT) with Lefort L5B->L5B
--- Not really comparable since Lefort doesn't distinguish cell types
--- Kiritani - scon: ,  pcon: , wcon:
--- Lefort -   scon: 0.051,  pcon: 0.072, wcon: 0.710

-- Kiritani L5 IT->IT with Lefort L5A->L5A
--- comparable because no PT in L5A
--- Kiritani - scon: 0.04621, pcon: 0.111, wcon: 0.416
--- Lefort   - scon: 0.126,   pcon: 0.191, wcon: 0.660
--- Anderson - scon: 2.39 (5x5 L5A+L5B, 0.4375-0.75)
--- Anderson - scon: 2.48 (2x2 L4/L5A, 0.375-0.5)
--- Weiler   - scon: 3.76 (1x1 L/L5A, 0.4-0.5)
--- Avg(Weiler+Anderson) - scon: (2.48+3.76)/2 =

- Rescale all Weiler+Anderson data so L5A->L5A equivalent to Kiritani: scaling factor = 0.04621/2.48 = 0.01863
- Rescale Lefort wcon so L5A->L5A equivalent to Kiritani: scaling factor = 0.416/0.660 = 0.63

- Now can use Kiritani for wcon of L4/L5, and Lefort for wcon of L2/3, L6
- Can use Kiritani to replace diagonals of L5?
- Can use Lefort (with scaled weight) to replace remaining diagonals

*** Final choices and Python code
- finally got something reasonable! max prob ~0.28, weights range 0.3-1.0 mV; Weiler+A&S rescaled based on Kiritani IT->IT;
  increased diagonal bins by 20% to compensate LSPS; weights taken from Lefort (after thresholding and reducing variability);
  probs calculated from relative strength divided by weight (pmat=smat/wmat)
- m1/data/conn/conn.py

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20160810_183445.png][fig]]

*** New observations regarding CT connectivity from Yamawaki - CHECK!
**** disynaptic inhibition
- Photostimulation of CT neurons evoked IPSCs in CT and IT neurons, but generally only for IT neurons located in layer 6, not
  5B (Fig. 5A)
- IT-5B neurons received almost no inhibition and IT-6 neurons received similar inhibition compared with CT neurons
- In the reverse direction (i.e., IT-> interneuron->CT or IT), inhibitory responses were robust and of similar amplitude in
  CT and IT neurons.
- Analysis of disynaptic inhibition between CT and PT neurons showed that photostimulation of CT neurons generated ~15-fold
  less inhibition in postsynaptic PT compared with CT neurons
- In the reverse direction (PT->interneuron->CT or PT), the IPSCs showed a similarly asymmetric pattern as the EPSCs, with
  relatively strong PT->interneuron->PT responses, but no PT->interneuron->CT responses
- I/E ratio for CT->CT and IT->CT pathways: 4.9 and 2.1􏰎
- I/E ratio for CT->IT-6 and IT->IT-6 pathways: 6.1 and 1.5

**** CT<->PT conn
- Pairwise comparison of response amplitudes suggested that PT neurons received relatively little excitatory input from CT
  neurons (median ratio of CT->PT/CT->CT: 0.20; and 0.04); suggest CT->PT connectivity is relatively rare and often
  essentially absent.
- Virtually no input to CT neurons from PT neurons (median ratio of PT->CT/PT->PT: 0.01)
**** current implementation makes no distinction between IT and CT
- could add differentiation by decreasing CT->PT and PT->CT probabilities
- disynaptic inhibition - consistent with local intralaminar inhibitio
- could check/incorporate I/E r
*** E->I interlaminar (Naka16)
With respect to the former scenario, studies using axonal reconstruction, paired intracellular recordings, and viral tracing
methods indicate that L5 PCs receive input from a substantial number of interneurons in L2/3, L4, and L6, albeit at a lower
frequency than from L5 interneurons (Helmstaedter et al., 2009a,b,c; Jiang et al., 2013; Lee et al., 2015; DeNardo et al.,
2015; Figure 2A). Connections from several different varieties of interneurons in layers 1 and 2/3 have been observed onto L5
PCs (Jiang et al., 2013, 2015).

Despite the existence of these direct translaminar inhibitory pathways, optogenetic experiments mapping inhibitory inputs to
L5 PCs (either from GABAergic non-specifically, or selectively from PV neurons) suggest that inhibition onto L5 PCs most
strongly originates from interneurons within L5 (Schubert et al., 2001, 2006; Brill and Huguenard, 2010; Kätzel et al., 2011;
Pluta et al., 2015). Thus the major source of translaminar inhibition to L5 PCs is more likely to be through the synaptic
recruitment of L5 interneurons by afferent axons from other cortical layers (Figure 2B).

Thus, decided to keep intralaminar (with L5A/B -> L5A/B).

** Issues and solutions
*** Normalization/calibration of data from different papers
- How can we normalize values from these datasets so they make sense together?
**** Solution 1 (current): Don't normalize since data is calibrated
In theory the Glu-LSPS data is all calibrated, so the absolute magnitude should be the same when comparing same pre and
  post yfrac in Weiler and A&S papers, and can be tied back to a calibrated # of presynaptic neurons (~200 as I recall).
**** Solution 2: Normalize wrt to peak value of each conn matrix
**** Solution 3: Normalize wrt to common yfracs bins on each conn matrix
The question is whether or not it makes sense to normalize to the peak input pixel, across the data sets? I explained above
why it makes sense, but there are limitations, and I think I found a better approach. The idea is to do everything as above,
but instead of taking the A&S CSP max value to be same as Weiler max value, normalize differently. If you look at the
non-peak values of the matrix (for example between deep layers), there seems to be a pretty good correspondence already
without rescaling. So I see two approaches:

(B) Normalize, but not to peak pixel. I'm concerned that normalizing to the peak (a single pixel) could be problematic
because noisy. I'm not yet suggesting a specific normalization approach - I think this is more up your alley, and I'm hoping
you can make some suggestions?  Maybe normalize to the total input across the yfrac ranges that are common to both (Weiler
and A&S datasets)? So average theA&S CSP and CSTR overlapping roles, and then find overlap between that A&S combo and the
Weiler L5 data, and scale the A&S to achieve same total / average input. The A&S CSP and CSTR data sets should remain on the
same scale as each other in any case, since they were acquired in parallel.

*** Separation of conn strength (I_con) into probability of connection (p_con) and unitary weight (i_con)
**** Solution 1: use unitary EPSP to calculate LSPS weights knowing that max unitary conns = 100
In Weiler, for each stimulus, ~100 neurons each fired ~1 AP.

The somatic response for unitary local connections between L5 pyramidal neurons has been measured (in Taro's paper, for
example; and in Markram/Sakmann papers for rat). Most paired papers do current-clamp, not voltage-clamp. (like we used in
LSPS). Taro's paper doesn't report the distribution of unitary somatic EPSPs, but I'm pretty sure Taro measured that - I can
at some point try to find his data, or I/you can look at his raw traces to measure the EPSP amplitude (and time course). I
think I may have done this already for my synaptic NEURON model, not sure at the moment. I did a quick measurement of an
example trace (Fig. 6C), where the unitary EPSP CSP->CSP had an amplitude of 0.52 mV. There are other example traces given in
Fig. 7, but the scalebar is not calibrated there. We have these data, it's just a matter of finding/analyzing them.

The point is that we should be able to come up with a range/mean/variance of unitary EPSP size for E->E connections within
L5. And we know that the max unitary connections possible is 100 (for the LSPS mapping conditions). So the constraints would
be min=0, max=100 presynaptic neurons, and min/max unitary EPSP taken from Taro's L5->L5 data (or better would be a different
source for L2/3->L5 data, or at least another study showing that L2/3->L5 unitary connections have a similar strength as
L5->L5 connections, even if in rat).

**** Solution 2: use CSP neuron model, with sCRACM data for syns, to reproduce LSPS (advantages; can reproduce LSPS papers)
A different, strong approach, combining a lot of experimental data and modeling: Recall that I have a dataset mapping out the
subcellular location of synapses on CSP neurons, originating from pyramidal neurons in L2/3 (aka L2/3->CSP sCRACM data
set). These maps are obtained under similar conditions as the Glutamate LSPS maps (room temperature, NMDA-blocked with CPP,
somatic voltage-clamp). So we could take my full CSP model, add in the L2/3 synapses in the appropriate spatial distribution
obtained from sCRACM (I've already done this in NEURON), and then simulate Glutamate LSPS in NEURON, while varying the
probability and strength of unitary L2/3->CSP connections, subject to the max of 100 presynaptic neurons. Then we compare the
simulated somatic responses to the ones obtained experimentally in Glu LSPS maps, which would tell us which combinations of
probability and strength are consistent with the experimental results. If needed, we can constrain the range of unitary
strength based on what is generally known about cortical unitary EPSPs (may require a conversion to 34C and current-clamp in
the model). The output of this effort would be an estimate of the convergence and unitary strength of L2/3->CSP pathway. Note
that this uses the CSP model in two ways: first, to estimate the relative spatial density of L2/3->CSP synapses by simulating
sCRACM and optimizing to experiment; second, to estimate the L2/3->CSP connection probability and unitary strength by
simulating Glu-LSPS and optimizing to experiment.

I think it's clear (based on having tried to do 1/2 of this proposed approach) that this is a very large effort, and not one
that can be accomplished anytime soon. But I'd urge you to keep this in mind for later stages of the U01, for a few reasons:
it demonstrates the usefulness of subcellular models and experiments so fits U01 well; it could generate estimates of
connectivity that would be very difficult / time-consuming to obtain experimentally (if even currently possible); it
represents a real productive use of the CSP membrane model; also, it does not require a full spiking CSP model, because the
CSP are voltage-clamped, NMDAR are blocked, and we're at room temperature, and the inputs are subthreshold. Most importantly:
I've already done a big chunk of this - made a suitable model, reconstructed multiple CSP for which I also have the sCRACM
data, and implemented a NEURON model that distributes synapses according to experimental sCRACM grids and simulates the
sCRACM mapping experiment in silico. The Glu-LSPS simulation would be very similar to the sCRACM simulation, basically
identical. I'd actually be very excited to work on this, since it would pull together a lot of work I've already sunk a *ton*
of time into. Perhaps we can revisit somewhere down the road if/when I have some downtime experimentally, or as a short
sabbatical or such.

**** Solution 3 (current): use unitary conn weights from other studies (Kiritani, 2012; Lefort, 2009)
- can use Kiritani weights for L5
- use Lefort weights for rest; however would need to scale Lefort based on common L5 weights
- scale Lefort based on Kiritani; then used Lefort for non-diagonal values
-- only have single point to scale: L5A->L5A
- scale Lefort to Anderson
-- cannot use diagonals since underestimated in Anderson
-- probably cannot use L2/3 -> L5 cause different in M1 vs S1
- gordon emphasized anything that seems reasonable ok, since data is very sparse anyway

*** Diagonals are underestimated in LSPS data (Weiler+ A&S)
- laser activates glutamate in target cells so generates direct spikes, instead of via synapse -- contaminates data
**** Solution 1a: Use Kiritani's paired recording data for  L5 diagonals
- For nearby neurons (diagonal of the connectivity matrix), a better technique is paired recordings: and for L5, we have those,
courtesy of Taro. So ideally we would use paired recording data for connections along the diagonal (aka intra-laminar), at
least where it's available.  Taro's data has connection probability, and I think we can determine unitary strength even
though it's not reported in his paper.

- Plan to replace connectivity data along the diagonal, from other
sources, in the near future.  2.a For L5->L5, replace the A&S connectivity (diagonals) with Taro's data (pairs), once I/you
have time to extract the unitary strength (Pcon is already available in paper).

- Issues:
-- Kiritani is cell-specific for presyn, but Weiler and A&S is not -- so not all cases comparable
-- Kiritani pre and post cells in same yfrac bin; only applies to diagonals in Weiler and A&S; but specific yfrac not known
-- IT->IT comparable since PT->IT=0
-- PT->PT not comparable since A&S is IT+PT->PT (but can combine Kiritani or split final matrix by presyn type)
-- IT->PT not comparable since A&S is IT+PT->PT (but can combine Kiritani or split final matrix by presyn type)
-- PT->IT = 0


**** Solution 1b: Use Naoki Yamawaki for L6 diagonasl
 2.b. For L6->L6, replace the Weiler connectivity (diagonals) using Naoki's JNeurosci findings (IT/CT) and other sources
 (Thompson; Lefort).
- maybe can use Naoki to scale Anderson
**** Solution 1c: Use literature (eg.Lefort) for L2/3, 4 (use scaling factor if needed)
For other layers, we'll need to turn to the literature, which unfortunately is often
from rat. In that regard, I'd suggest we compare Taro's L5 data to rat L5 data from other labs, and if the results (Pcon,
Wuni) are similar, then good - if not, it may suggest a rat->mouse scaling factor. In any case, Alex Thompson has a review
with useful data for L6 pairs (including putative IT and CT classification). And within L2/3 there should be lots (Lefort,
Feldmeyer, Sakmann, Petersen probably).  Some may be mouse, most in rat. Most will not be in M1.

 2.c. For L2/3, L4, consider replacing A&S connectivity (diagonals) with non-M1 data (pairs) from Lefort (or others).

**** Solution 2: Use other studies (Lefort) to replace all diagonals
- initially assume all weights = 0.5
- convert A&S to scon and pcon
- replace diagonal A&S scon with Kiritani scon


**** Solution 3: Use HBP mouse data
- not in mV but uS (actually uS is units in Neuron!)

**** Solution 4: Increase all diagonals by fixed % eg. 20%
- Gordon suggested not to spend too much time in the details of combining different datasets since anyway all are based on
  very small samples and are likely to have low significance statistically.
- Since we know all diagonals are underestimated can just increase by fix percentage which will overall provide a more
  realistic value.

** Steps
* :MODEL VERSIONS: ...
- Should figure out proper way to keep track of model versions
-- cell types, mod files, connectivity, code
-- and sims -- code, netpyne version, params

** v4 - M1, 6 layers, 5 cell types, Inh Izhi, conn based on excel v4 (not correct)
*** revision 427, 451 [1f15e1782569]
*** notes
- Initial version with connectivity based on gdrive excel connectivity-data-v4'

** v5 - HH reduced for Inh, conn based on 5 papers based on python code (improved, 5 papers)
*** revision 452 [6023633dbe5c]
*** notes
- M1 net
- 6 layers
- 7 cell types
- Inh cells use HH
- NCD-based connectivity from  Weiler et al. 2008; Anderson et al. 2010; Kiritani et al. 2012; Yamawaki & Shepherd 2015;
  Apicella et al. 2012
- Python code to calculate conn matrices

** v6 - Replicate sam's version - modified cell types and parametrized
*** revision 464 [326af26e1629]
*** notes
- Parametrized version based on Sam's code
- Fixed some bugs in conn implementation
- Updated cell models and mod files

** v7 - Added IClamp inputs
*** revision 465 [45ece5166ec1]
*** notes
- Added IClamp inputs to compare IT vs PT (PT not firing for same netstim inputs)
- renamed to addNoise, addSignal and addIClamp
** v8 - Swap geometries
*** revision 466 [ebb41cbe9eef]
*** notes
- added func to swap geometries of reduced models
** v9 - Use correct cell models (local, not central repo)
*** revision 467 [de13f64a03d6]
*** notes
- was using the cell models in /usr/site/nrniv/local/python/ since I didn't specify correctly the path (cells/) for local
  modified version
** v10 - Use 5 synsperconn for 5-comp cells (HH_reduced)
*** revision 468 [439181a2b791]
*** notes
- Separated HH_reduced (5 comp) from HH_simple (1 comp)
- Use 5 synsperconn for 5-comp cells (HH_reduced) and 1 for 1-comp cells (HH_simple)
** v11 - Made channel global h params local to each cell model
*** revision 468 [439181a2b791]
*** notes
- global h params were being modified by each cell model
- Now made specific to each cell model so can use in net

** v12 - Fixed v_init for different cell models
*** revision 470 [7592f2521183]
*** notes
- v_init in netParams.cellParams didn't match that in cell model files -- have to set manually

** v13 - New IT HH_reduced model with same geom as PT
*** revision 473 [405012c30c37]
*** notes
- New IT HH_reduced model with same geom as PT
- replicate IF curve
** v14 - Cleaned cfg and moved noise list to netParams
*** revision 481 [28c394026b8c]
*** notes
Cleaned cfg and moved noise list to netParams
** v15 - Fixed bug in EIGain en IEGain during batch sims
*** revision 484 [ad41b89810dd]
- Moved below lines to netParams since simConfig not executed when loaded as json
cfg.EIGainPV = cfg.EIGain
cfg.EIGainSOM = cfg.EIGain
cfg.PVEGain = cfg.IEGain
cfg.SOMEGain = cfg.IEGain
** v16 - Added secLists for PT full
*** revision 491 [e358f3c72a55]
*** notes
cellRule['secLists']['perisom'] = ['soma']
cellRule['secLists']['perisom'].extend([sec for sec in cellRule.secs if 'dend' in sec])  # soma+basal
cellRule['secLists']['alldend'] = [sec for sec in cellRule.secs if ('dend' in sec or 'apic' in sec)] # basal+api

- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902

** v17 - Fix bug in CT
*** revision 508 [812c6f68fb42]
*** notes
- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py

*** results
159 / 728 match firing rate conditions: ['range']
15 / 728 match firing rate conditions: ['I>E']
455 / 728 match firing rate conditions: ['I>E (L2+6)']
29 / 728 match firing rate conditions: ['L5>L6>L2']
728 / 728 match firing rate conditions: ['L5>L6']
469 / 728 match firing rate conditions: ['L5>L2']
29 / 728 match firing rate conditions: ['L6>L2']
40 / 728 match firing rate conditions: ['PV>LTS']
29 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
17 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
455 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L2']
40 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L2', 'PV>LTS']
29 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
0 / 728 match firing rate conditions: ['range', 'L5>L6>L2']


--> bkgE=1.0 bkg=1 EE=1.0 EI=0.8 IE=1 II=1.2
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161106_153619.png][fig]]
   IT2 : 2.070 Hz
   SOM2 : 12.263 Hz
   PV2 : 7.149 Hz
   IT4 : 0.300 Hz
   IT5A : 1.140 Hz
   IT5B : 6.492 Hz
   PT5B : 29.205 Hz
   SOM5 : 5.450 Hz
   PV5 : 30.363 Hz
   IT6 : 0.195 Hz
   CT6 : 0.181 Hz
   SOM6 : 6.529 Hz
   PV6 : 3.725 Hz

bkgE=1.2 bkg=1.0 EE=1.0 EI=0.8 IE=1 II=1.2
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161106_153905.png][fig]]
   IT2 : 4.292 Hz
   SOM2 : 14.947 Hz
   PV2 : 8.184 Hz
   IT4 : 1.153 Hz
    IT5A : 3.120 Hz
   IT5B : 9.394 Hz
   PT5B : 30.683 Hz
   SOM5 : 10.640 Hz
   PV5 : 23.234 Hz
   IT6 : 0.151 Hz
   CT6 : 0.154 Hz
   SOM6 : 6.580 Hz
   PV6 : 4.203 Hz

bkgE=1.2 bkg=1.0 EE=1.0 EI=0.8 IE=1.2 II=1.0
   IT2 : 5.418 Hz
   SOM2 : 10.158 Hz
   PV2 : 6.482 Hz
   IT4 : 1.163 Hz
   IT5A : 1.685 Hz
   IT5B : 2.211 Hz
   PT5B : 22.980 Hz
   SOM5 : 7.799 Hz
   PV5 : 21.619 Hz
   IT6 : 0.432 Hz
   CT6 : 0.427 Hz
   SOM6 : 5.594 Hz
   PV6 : 2.449 Hz

bkgE=1.2 bkg=1.0 EE=1.2 EI=0.8 IE=1.2 II=0.8
   IT2 : 3.933 Hz
   SOM2 : 11.289 Hz
   PV2 : 5.763 Hz
   IT4 : 0.777 Hz
   IT5A : 1.908 Hz
   IT5B : 5.234 Hz
   PT5B : 22.693 Hz
   SOM5 : 7.683 Hz
   PV5 : 22.302 Hz
   IT6 : 0.176 Hz
   CT6 : 0.170 Hz
   SOM6 : 5.000 Hz
   PV6 : 3.384 Hz

bkgE=1.2 bkg=1.2 EE=1.0 EI=0.8 IE=1.0 II=1.2
   IT2 : 5.559 Hz
   SOM2 : 15.412 Hz
   PV2 : 9.096 Hz
   IT4 : 1.240 Hz
   IT5A : 3.839 Hz
   IT5B : 10.099 Hz
   PT5B : 27.505 Hz
   SOM5 : 12.637 Hz
   PV5 : 22.054 Hz
   IT6 : 0.127 Hz
   CT6 : 0.134 Hz
   SOM6 : 7.464 Hz
   PV6 : 3.891 Hz

bkgE=1.2 bkg=1.2 EE=1.2 EI=0.8 IE=1.0 II=0.8
   IT2 : 1.832 Hz
   SOM2 : 14.956 Hz
   PV2 : 8.754 Hz
   IT4 : 0.421 Hz
   IT5A : 1.071 Hz
   IT5B : 5.507 Hz
   PT5B : 29.381 Hz
   SOM5 : 7.892 Hz
   PV5 : 29.827 Hz
   IT6 : 0.059 Hz
   CT6 : 0.066 Hz
   SOM6 : 7.203 Hz
   PV6 : 5.319 Hz

** v18 - Added subcellular rules to distribute syns
*** revision 513 [365565335f41]
*** notes
- added subConnParam rules
- added 3d morph of reduced cell models
- PT full model soma centered at 0,0,0
- Set cfg seeds here to ensure they get updated

** v19 - Individual gains for SOM and PT (I->E and I->I)
*** revision 520 [319f106b3bf9]
*** notes
## E->I gains
cfg.EPVGain = 1.0
cfg.ESOMGain = 1.0

## I->E gains
cfg.PVEGain = 1.0
cfg.SOMEGain = 1.0

## I->I gains
cfg.PVIGain = 1.0
cfg.SOMIGain = 1.0

** v20 - PT subcellular distribution as a cfg param
*** revision 521 [9e7ecd76c7a9]
*** notes
cfg.IT2_PT_subconn

** v21 - Testing reduced IT cell
*** revision 539 [0a724d597cd4] (branch: cell)
*** notes
- checking if dendrite length modifies soma response to current

** v22 - Long range inputs, cell densities, subcell rules, cylindrical volume,  several other changes
*** revision 550 [a0a514ebdf67] (branch:cell)
*** notes
- Cylindrical volume
- DefaultDelay (for local conns) = 2ms
- Added long range connections based on Yamawaki 2015a,b; Suter 2015; Hooks 2013; Meyer 2011
- Updated cell densities based on Tsai 2009; Lefort 2009; Katz 2011; Wall 2016;
- Separated PV and SOM of L5A vs L5B
- Fixed bugs in local conn (PT/CT, PV5, SOM5, L6)
- Added perisom secList including all sections 50um from soma
- Added subcellular conn rules (both full and reduced models)
** v23 - Testing weight scaling along PT dendrite
*** revision 566 [5c9bf52a22b4] (branch: cell)
*** notes

** v24 - Testing weight scaling with new cell models
*** revision 569[d1a74bd1aa31]-580 (branch: cell)
*** notes
- new PT cell (with ca hot option)
- new IT cells
- added weightNorm

** v25 - Added IT cell with layer-dep length
*** revision 581[b233290f4078]-594 (branch cell)
*** notes
- synWeightFractionSOME - updated to 1/7.5:1.0

** v26 - Testing modified PT cell v2
*** revision 595 [2d1acd24eb29] -643 (branch: cell)

** v27 - Incorporate updated cells to network
*** revision  644 [050f48fe01be]
*** notes
- Improved cell models, including PV and SOM fI curves
- Improved subcell conn rules based on data from Suter15, Hooks13 and others
- reorganized code

** v28 - Fix syn distributions
*** revision
*** notes
- aligned subconn grid properly
- used sqrt(dendL) for smoothing

** v29 - Adpated Bdend L of reduced cell models to layer depth
*** revision 690  [234c41ab6017]
*** notes
- Bdend L was fixed to 288 um which didnt match with apic dend L
- now adapted to Layer depth, same as each Apic sec
- Also now includes L5B cell
- Added weightnorm for PV+SOM

** v30 - Udpatd cell density
*** revision 700 [49442198fe8d]
*** notes
- cell num was 9218 (< 10k) due to fixed layer boundaries (L4 vs L5A)
- updated cell densities to reach 10k
- also updated SOM5A, PV5A -> SOM45A and PV45A - shared between layers - used avg density
** v31 - Long input rates - made a cfg param and lowered to [0,2]
*** revision 712 [cda78b222a3e]
*** notes
- long rates from [0,5] to [0,2]

** v32 - Threshold set to 0.0 mV
*** revision 738  [dbc0663d8322]
*** notes
- before was set to -15 and lead to fake spikes in PT cell

** v33 - Parametrized I->layer weights
*** revision 742  [c0eea532c5c0]
*** notes
weights = cfg.Iweights * 2  # [1.0] * len(preCellTypes)

** v34 - Parametrized IE->layer and II->layer weights
*** revision 744  [76a5df2907c8]
*** notes

** v35 - Added missing subconn rules (IT6->PT; S1,S2,cM1->IT/CT; long->SOM/PV)
*** revision 754 [4496c077cb0e]
*** notes
missing subconn rules lead to missing projections being placed on single segment leading to depol blockade

** v36 - weightNorm threshold (10x for PT) and soma fix (IT5A)
*** revision 761 [943041cf6445]
*** notes
- weightNorm threshold for PT cells set at 10x - affects tuft only
- weightNorm for IT5A soma was missing due to wrong labeling -fixed
** v37 - weightNorm threshold as a cfg param
*** revision 766 [c0ea6864ee50]
*** notes
- weightNorm threshold same for all cells
** v38 - Individual PV<->SOM gains
*** revision 775 [60a3f26a506e]
*** notes
cfg.PVSOMGain = 1.0
cfg.SOMPVGain = 1.0
cfg.PVPVGain = 1.0
cfg.SOMSOMGain = 1.0

** v39 - Further conn adjustments based on gmgs comments
*** revision 795 [e2408430ce3e]
*** notes
reduced IT2->IT4
reduced IT5B->CT6
reduced IT5B+IT6->IT2+IT4+IT5A
reduced IT2,4,5A,6->IT5B
increased CT->PV6+SOM6

** v40 - Parametrized PT ih gbar
*** revision
*** notes
- Parametrized PT ih gbar
** v41 - Added IFullGain parameter: I->E gain for full detailed cell models
*** revision
*** notes
- Added IFullGain parameter: I->E gain for full detailed cell models
** v42 - Replaced PT ih with Migliore 2012
*** revision

*** notes
- use Migliore's hd channel, which includes a leak/shunt current that helps reproduce the reduced cell firing for high ih.
- ihGbar and ihGbarBasal - paramterized in cfg
- dendNa, axonNa, axonRa - parametrized in cfg
- cfg option to removeNa

IMPORTANT: netParams_cell.py and cfg_cell.py parametrized differently to standard (network) version (some will be included in v43)
- apic_upper and apic_lower section lists
- synapse excTau2Factor - parametrized in cfg

** v43 - Replaced cfg param lists with dicts (cleaner for batch)
*** revision
*** notes

** v44 - Parametrized ihLkcBasal and AMPATau2Factor
*** revision
*** notes
- ihLkcBasal - mult factor to modify ihlkc in PT soma+basal
- AMPATau2Factor - mult factor to modify AMPA syn tau2

** v45 - Fixed synMechWeightFactor
*** revision
*** notes
- synWeightFactor wasn't properly implemented so AMPA+NMDA had same weight (same for GABA)
- essentially 2x weight for exc syns
- implemented as synMechWeightFactor

-Parametrized PT ih slope and ihlkcBelowSoma

** v46 - Added disynapticBias to I->E
*** revision
*** notes
- disynapticBias increases prob of I->Ey conns if Ex->I and Ex->Ey exist
- added to NCD 0.31-1.0 (not L2/3)
- based on Yamawaki & Shepherd 2015

- fixed bug E->CT bin 0.9-1.0 was wrong -- but very low smat so not critical
** v47 - Replaced GABAB with exp2syn and adapted synMech ratios
*** revision
*** notes
netParams.synMechParams['GABAB'] = {'mod':'MyExp2SynBB', 'tau1': 3.5, 'tau2': 260.9, 'e': -93}
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio

** v48 - Parametrized somaNa
*** revision
*** notes
- parametrized somaNa (separate from dendNa) as cfg.somaNa

** v49 - Added ynorm condition to NetStims
*** revision
*** notes
made ynorm a parma of netstims so can provide input to subset of cells

** v50 - Added option to play back recorded spikes into long-range inputs
*** revision
*** notes
- can provide in cfg the json filenmae with 2D list with spikes for each cell: e.g.
cfg.ratesLong = {'TPO': [0,0.1], 'TVL': [0,0.1], 'S1': 'cells/ssc-3_spikes.json', 'S2': [0,0.1], 'cM1': [0,0.1], 'M2': [0,0.1], 'OC': [0,0.1]}

** v51 - Fixed Bdend 'y' location and added convertCellShapes
*** revision
*** notes
- Fixed Bdend 'y' location to connect to end of soma
- Added convertCellShapes, so inh cells have 3d points, and all 3d points are fixed
- Fixed VecStim so spike stream independent of duration (in netpyne)
- Switched from NEURON 7.4 to NEURON 7.5 (on Comet; some differences in output)

['CT6_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.006525571237494247,'old_value': 0.006616035423613187},
['IT6_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.0048984211767112125,'old_value': 0.005092788059411614},
['PT5B_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.0022622577631087612,'old_value': 0.002919143427909488},
** v52 - New layer boundaries, cell densities, conn, FS+SOM L4 grouped with L2/3
*** revision
*** notes
- New layer boundaries
L2/3 = [0.1, 0.29] - Yamawaki
L4 = [0.29, 0.37]  - Yamawaki
5A = [0.37, 0.47] - Anderson10/Suter13
L5B = [0.47, 0.8] - Suter13/Anderson10/Oswa13
L6 = [0.8, 1.0] - Suter13/Anderson10/Oswa13

- New cell densities based on those boundaries

- L4 FS/LTS grouped with L2/3 instead of L5A (pops and conns)

- Changes to conn rules:
-- boundaries match better Ande10, eg. L5B
-- interlayer Factor = 0.5
-- low cortical input to L4
-- Kiritani renormalization - slightly lower values
-- L4->L2/3 increased both bins
-- reduced diff of cM1+M2 -> upper vs lower L5B (from 0.8 vs 1.2 to 0.9 vs 1.1)
-- VL -> L5B profile has strong effect - made uniform as suggested by gordon email
-- Increased S2 inputs from 10% to 15% since always have low L23

batch18
-- cfg.L5BrecurrentFactor = 1.0
-- cfg.ITinterFactor = 1.0
-- cfg.strengthFactor = 1.0

batch19
-- diagScaleFactor = 1.0
-- cfg.strengthFactor = 0.8
-- Decrease L2/3->L4 (= 0.25 * L4->L2/3, Yamawaki,15)

** v53 - Increased exc -> L4
*** revision
*** notes
L4 showed practically no firing so increased exc->L4 within based on Yamawaki et al 2015, Fig 5

W_L23_L4 = np.max(smat[('W+AS_norm', 'IT', 'L2/3,4')][2,1:3])  # use max value

YamaScaleFactor = W_L23_L4 / smat['Y'][1]
smat[('W+AS_norm', 'IT', 'L2/3,4')][2,3:] = smat['Y'][3:] * YamaScaleFactor  # set both bins to same low value

** v54 - Moved from NetPyNE v0.7.9 to v0.9.1 / v0.9.3 (dev 66072a0) with py3 
*** revision
*** notes
- No chnanges in netParams but created new version since moved to NetPyNE v0.9.1 with changes in the conn implementation whcih will lead to different sim results
- v54_batch1-6: NetPyNE v0.9.1
- v54_batch7-: NetPyNE v0.93 (dev 66072a0) and py3
- created new branch paper2019_py3 since continued extending model (added VIP and NGF); but want to keep paper version separate
** v55 - Added VIP and NGF cells; and converted to Py3 and git repo
*** revision
*** notes

- added VIP and NGF cells to all layers
- updated inhib cell densities per layer
- separated L2 and L4 inhib cells
- coverted code to Py3
- converted hg repo to git 
** v100 - New version numbering after adding new cell types; dt=0.025; L1 density
*** revision
*** notes
- new numbering to leave room for ongoing simulations without the new cell types (continues from v56)
- set dt=0.025 to prevent reproducibility issues
- fixed density of L1 NGF cells (previous set to 0)
** v101 - Parameterized long-range weights for each pop to use this in batch evol
*** revision
*** notes
- Parameterized long-range weights for each pop to use this in batch evol
- Added VIP and NGF weightNorms
** v102 - Fixed 2 bugs in I->IT and I->VIP conn
*** revision
*** notes
- I->E only for HH_full cell model (missed most ITs)
- I->I only for HH_simple cell model (missed VIPs)
- replaced all _simple cell models with _reduced

** v103 - Changes to inh conn (increased E->NGF/VIP, decreased default I->I)
*** revision
*** notes
- EtoIprobFactorVIP = 1.0  # VIP was actually not spiking in last evol (v102_batch2)
- EtoIprobFactorNGF = 1.0  # not spiking in last single sims (v102_batch3)
- I -> I (default) = 1.0 -> weak (0.35) (NGF -> rest, including NGF)
- after v103_batch1 - increased weightNorm x4

* :SIMS: ...
  (convert to table?)
** M1_v6_tune1 - orig sam params (includes input to L5B!)
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
orig sam params
*** results
IT2 : 0.000 Hz
SOM2 : 1.480 Hz
PV2 : 1.240 Hz
IT4 : 0.000 Hz
IT5A : 0.000 Hz
IT5B : 0.000 Hz
PT5B : 0.341 Hz
SOM5 : 1.403 Hz
PV5 : 1.355 Hz
IT6 : 0.000 Hz
CT6 : 0.000 Hz
SOM6 : 1.258 Hz
PV6 : 1.065 Hz

- raster:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161021_183021.png][fig]]
- connPlot:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161021_182926.png][fig]]

** M1_v6_tune2 - set all bkg weights to 0.0001
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 0.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

** M1_v6_tune3 - set all bkg weights to 0.001, EEGain = 0.2
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 17.234 Hz
   SOM2 : 29.160 Hz
   PV2 : 16.280 Hz
   IT4 : 2.112 Hz
   IT5A : 2.110 Hz
   IT5B : 1.852 Hz
   PT5B : 0.000 Hz
   SOM5 : 75.548 Hz
   PV5 : 11.710 Hz
   IT6 : 31.363 Hz
   CT6 : 32.177 Hz
   SOM6 : 4.032 Hz
   PV6 : 12.806 Hz
** M1_v6_tune4 - set all gains to 1.0, bkg w=0.0002
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 0.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
** M1_v6_tune5 - set all gains to 0.0, bkg w=0.001
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
  Spikes: 37114 (31.35 Hz)
   IT2 : 45.351 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.240 Hz
   IT4 : 45.972 Hz
   IT5A : 45.576 Hz
   IT5B : 46.319 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.290 Hz
   IT6 : 45.484 Hz
   CT6 : 45.129 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.226 Hz

** M1_v6_tune6 - set all gains to 1.0, bkg w=0.001
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
    PV2 : 10.480 Hz
   IT4 : 1.972 Hz
   IT5A : 1.551 Hz
   IT5B : 1.193 Hz
   PT5B : 0.000 Hz
   SOM5 : 33.500 Hz
   PV5 : 2.161 Hz
   IT6 : 7.347 Hz
   CT6 : 7.363 Hz
   SOM6 : 3.548 Hz
   PV6 : 5.097 Hz

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161021_194551.png][fig]]
** M1_v6_tune7 - PT5B bkg ampa w=0.0055, gabaa w=0.00011
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
  Spikes: 8543 (7.22 Hz)
   IT2 : 14.429 Hz
   SOM2 : 17.840 Hz
   PV2 : 9.720 Hz
   IT4 : 1.944 Hz
   IT5A : 1.407 Hz
   IT5B : 1.111 Hz
   PT5B : 0.141 Hz
   SOM5 : 34.339 Hz
   PV5 : 2.161 Hz
   IT6 : 7.218 Hz
   CT6 : 7.484 Hz
   SOM6 : 3.613 Hz
   PV6 : 5.000 Hz
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161021_205740.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161021_205748.png][fig]]

** M1_v6_tune8 - gains to 0.0, removed sig input to PT5B!
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 45.351 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.240 Hz
   IT4 : 45.972 Hz
   IT5A : 45.576 Hz
   IT5B : 46.319 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.290 Hz
   IT6 : 45.484 Hz
   CT6 : 45.129 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.226 Hz
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161024_135748.png][fig]]

** M1_v6_tune9 - set cfg.bkgW_GABAA = 0.000
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 26.000 Hz
   SOM2 : 42.160 Hz
   PV2 : 16.880 Hz
   IT4 : 25.935 Hz
   IT5A : 25.983 Hz
   IT5B : 26.215 Hz
   PT5B : 0.000 Hz
   SOM5 : 41.694 Hz
   PV5 : 16.968 Hz
   IT6 : 26.306 Hz
   CT6 : 26.250 Hz
   SOM6 : 41.710 Hz
   PV6 : 16.903 Hz

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161024_143334.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161024_143346.png][fig]]

** M1_v6_tune10 - set cfg.bkgW_GABAA = 0.0005
*** netpyne version: 0.6.1 + dev
*** netParams version: 6
*** notes
*** results
   IT2 : 14.722 Hz
   SOM2 : 0.080 Hz
   PV2 : 11.000 Hz
   IT4 : 14.879 Hz
   IT5A : 14.763 Hz
   IT5B : 14.815 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.097 Hz
   PV5 : 11.000 Hz
   IT6 : 14.806 Hz
   CT6 : 15.169 Hz
   SOM6 : 0.194 Hz
   PV6 : 10.968 Hz

** M1_v7_tune1 - set IClamp of 300pA to PT and IT to compare
  Cells: 1184
  Connections: 0 (0.00 per cell)
  Spikes: 253 (0.43 Hz)
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 2.000 Hz
   IT5B : 0.000 Hz
   PT5B : 2.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

** M1_v7_tune2 - IClamp 100pA
*** netpyne version: 0.6.1 + dev
*** netParams version: 7
*** notes
*** results
Spikes: 0 (0.00 Hz)
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 0.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

** M1_v7_tune3 - IClamp 200pA
*** netpyne version: 0.6.1 + dev
*** netParams version: 7
*** notes
*** results
  IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 8.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

** M1_v7_tune4 - only E bkg, record AMPA currents
- issue might be in propagation of signal from Adend2 to soma in PT cell
- in IT v in adend and soma almost identical

** M1_v7_tune5 - only IClamp 300pA to Adend2, to compare V in adend vs soma
- signal not propagating from adend2 to soma
- Comparing IT and PT geom:

PT diam:
soma 28.2149102762
Adend1 1.5831889597
Adend2 1.5831889597
Adend3 1.5831889597
axon 1.40966286462
Bdend 2.2799248874

IT diam:
soma 27.1149930518
Adend1 2.86090460606
Adend2 2.86090460606
Adend3 2.86090460606
axon 0.552948640016
Bdend 1.02617341611

PT L:
soma 25.0612875049
Adend1 294.615634554
Adend2 294.615634554
Adend3 294.615634554
axon 598.648623864
Bdend 265.920165144

IT L:
soma 25.0612875049
Adend1 294.615634554
Adend2 294.615634554
Adend3 294.615634554
axon 598.648623864
Bdend 265.920165144

** M1_v7_tune6 - only IClamp 300pA to Adend1
- nice regular spikes in soma, irregular noisy in dedn
** M1_v7_tune7 - only IClamp 300pA to Adend3
- single spike + depol block - in soma+dend
** M1_v7_tune8 - only IClamp 300pA to Bdend
- initial PT spikes but decrease in size and stop (dep block?)  - in soma+dend
** M1_v7_tune9 - only IClamp 500pA to Adend2
- nice spiks in soma; 1 spk + depol block in dend
** M1_v7_tune10 - only IClamp 400pA to Adend2
- nice spiks in soma; 1 spk + depol block in dend
** M1_v8_tune1 - replaced PT geom with IT geom; only IClamp 300pA to Adend2
- nice spks in soma and dend of PT
** M1_v8_tune2 - replaced IT geom with PT geom; only IClamp 300pA to Adend2
- nice spks in soma and dend of PT
huh so mysteriously it seems both IT and PT responses are much nicer if swap the geoms!
** M1_v8_tune3 - replaced PT geom with IT geom; E bkg noise
- a couple spikes more in PT
   IT2 : 25.000 Hz
   IT4 : 24.000 Hz
   IT5A : 28.000 Hz
   IT5B : 24.000 Hz
   PT5B : 4.000 Hz
   IT6 : 28.000 Hz
   CT6 : 28.000 Hz

** M1_v8_tune4 - reduced cfg.bkgW_AMPA = 0.0005
- less spikes
   IT2 : 23.000 Hz
   IT4 : 20.000 Hz
   IT5A : 24.000 Hz
   IT5B : 24.000 Hz
   PT5B : 2.000 Hz
   IT6 : 20.000 Hz
   CT6 : 24.000 Hz

** M1_v8_tune5 - cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.0005
- better
   IT2 : 22.000 Hz
   IT4 : 26.000 Hz
   IT5A : 28.000 Hz
   IT5B : 26.000 Hz
   PT5B : 16.000 Hz
   IT6 : 24.000 Hz
   CT6 : 26.000 Hz

** M1_v9_tune1 - Fixed bug (using wrong cell model files); cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.0005
- IT good; still no PT firing
   IT2 : 48.000 Hz
   IT4 : 48.000 Hz
   IT5A : 48.000 Hz
   IT5B : 46.000 Hz
   PT5B : 0.000 Hz
   IT6 : 48.000 Hz
   CT6 : 48.000 Hz
** M1_v9_tune2 - Fixed bug (using wrong cell model files); IClamp
- IT good; PT fires at beginning
   IT2 : 48.000 Hz
   IT4 : 48.000 Hz
   IT5A : 58.000 Hz
   IT5B : 46.000 Hz
   PT5B : 0.000 Hz
   IT6 : 48.000 Hz
   CT6 : 48.000 Hz
** M1_v9_tune3 - Fixed bug (using wrong cell model files); cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.000
- IT fires at beginning; PT ok in dend but no firing in soma

** M1_v9_tune4 - bkg noise=0,cfg.bkgW_AMPA = 0.0005
- IT regular firing; PT no firing
- nice spks in PT dend, but not in soma
** M1_v9_tune5 - cfg.bkgW_AMPA = 0.0015
** M1_v9_tune6 - synsperconn=5, cfg.bkgW_AMPA = 0.0002
0.0002
** M1_v10_tune1 - HH_reduced=5 synsperconn; HH_simple=1 synperconn; cfg.bkgW_AMPA = 0.001
- depol blockade in all except PT
  Spikes: 91 (22.75 Hz)
   IT2 : 22.000 Hz
   IT4 : 22.000 Hz
   IT5A : 22.000 Hz
   IT5B : 22.000 Hz
   PT5B : 28.000 Hz
   IT6 : 22.000 Hz
   CT6 : 22.000 Hz
** M1_v10_tune2 - bkg rate 1000->100Hz
- IT ok, PT not firing
** M1_v10_tune3 - IClamp 300pA adend2
- PT no spks
** M1_v10_tune4 - IClamp 300pA soma
- IT only spks beginning; PT spikes regular
** M1_v10_tune5 - IClamp 400pA soma
- IT only spks beginning; PT spikes regular

** M1_v11_tune1 - IClamp 300pA soma
- PT ok; IT 2 spikes
** M1_v11_tune2 - IClamp 400pA soma
- PT ok; IT 1 spikes
** M1_v11_tune3 - IClamp 500pA soma
- PT ok; IT 1 spikes
** M1_v11_tune4 - bkg cfg.bkgW_AMPA = 0.001
- IT ok, PT no firing
** M1_v11_tune5 - bkg cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.0005
- IT ok, PT no firing
** M1_v11_tune5 - bkg cfg.bkgW_AMPA = 0.002, cfg.bkgW_GABAA = 0.0005
- IT ok, PT no firing
** M1_v11_tune6 - bkg cfg.bkgW_AMPA = 0.003, cfg.bkgW_GABAA = 0.0005
- IT ok, PT no firing
** M1_v11_tune7 - bkg cfg.bkgW_AMPA = 0.004, cfg.bkgW_GABAA = 0.0005
- IT ok, PT no firing
** M1_v11_tune8 - bkg cfg.bkgW_AMPA = 0.005, cfg.bkgW_GABAA = 0.0005
- IT ok, PT no firing
** M1_v11_tune9 - bkg cfg.bkgW_AMPA = 0.005, cfg.bkgW_GABAA = 0.0005, PT HH_full, bkg on soma
- IT ok, PT firing but weird spikes
** M1_v11_tune10 - bkg cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.0005, wiring on, all gains=1.0, 100x100um
- IT ok, PT firing
-reasonable rates given that no tuning

  Done; run time = 277.11 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 20.09 s.

Analyzing...
  Cells: 1184
  Connections: 526478 (444.66 per cell)
  Spikes: 6074 (10.26 Hz)
   IT2 : 24.537 Hz
   SOM2 : 26.400 Hz
   PV2 : 13.520 Hz
   IT4 : 5.850 Hz
   IT5A : 5.864 Hz
   IT5B : 3.822 Hz
   PT5B : 4.163 Hz
   SOM5 : 45.452 Hz
   PV5 : 2.452 Hz
   IT6 : 2.000 Hz
   CT6 : 2.000 Hz
   SOM6 : 5.032 Hz
   PV6 : 3.290 Hz
  Simulated time: 0.5 s; 1 workers
  Run time: 277.11 s
Copying cfg file M1_v11_tune10 ...
 Removing prior cfg file backupcfg//M1_v11_tune10_cfg.py
Saving output as ../data/v11_manualTune/M1_v11_tune10.json  ...
Finished saving!
  Done; saving time = 0.18 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.65 s

Total time = 352.20 s
** M1_v11_tune11 - HH_reduced synsPerConn from 5 --> 1
  Done; run time = 204.13 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 6.47 s.

Analyzing...
  Cells: 1184
  Connections: 137894 (116.46 per cell)
  Spikes: 3948 (6.67 Hz)
   IT2 : 13.873 Hz
   SOM2 : 17.200 Hz
   PV2 : 10.880 Hz
   IT4 : 4.486 Hz
   IT5A : 4.254 Hz
   IT5B : 3.822 Hz
   PT5B : 0.978 Hz
   SOM5 : 30.129 Hz
   PV5 : 2.839 Hz
   IT6 : 2.000 Hz
   CT6 : 2.000 Hz
   SOM6 : 3.226 Hz
   PV6 : 2.581 Hz
  Simulated time: 0.5 s; 1 workers
  Run time: 204.13 s
Copying cfg file M1_v11_tune11 ...
Saving output as ../data/v11_manualTune/M1_v11_tune11.json  ...
Finished saving!
  Done; saving time = 0.18 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.56 s

Total time = 236.67 s

** M1_v11_tune12 - testing commandline inputs
** M1_v11_tune13 - checking 300pA
** M1_v12_tune1 - checking 300pA with fixed v_init

** M1_v12_tune2 - NEW NETPYNE VERSION (0.6.2) - bugs importing cells
- now both IT and PT fire
** M1_v13_tune1 - new IT HH_reduced; 300pA soma
- IT weird output -depol blockade
** M1_v12_tune3 - 500pA soma
   IT5A : 45.000 Hz
   IT5B : 0.000 Hz
   PT5B : 30.000 Hz
** M1_v12_tune4 - 300pA Adend2
- PT subthres osc
** M1_v12_tune5 - 300pA Adend1
- PT subthres osc
** M1_v12_tune6 - 500pA Adend1
- good
   IT5A : 60.000 Hz
   IT5B : 0.000 Hz
   PT5B : 22.000 Hz
** M1_v12_tune7 - 500pA Adend2
   IT5A : 22.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
** M1_v12_tune8 - 700pA Adend2

  IT5A : 23.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   IT6 : 0.000 Hz
** M1_v12_tune9 - 700pA Adend3
   IT2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 15.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz

** M1_v12_tune10 - cfg.bkgW_AMPA = 0.001
   IT2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 0.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
** M1_v12_tune11 - cfg.bkgW_AMPA = 0.001, cfg.bkgW_GABAA = 0.0005
0.0
** M1_v12_tune12 - cfg.bkgW_AMPA = 0.01
   IT2 : 20.000 Hz
   IT4 : 20.000 Hz
   IT5A : 20.000 Hz
   IT5B : 20.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 45.000 Hz
   PV5 : 15.000 Hz
   IT6 : 20.000 Hz
   CT6 : 20.000 Hz

** M1_v12_tune13 - cfg.bkgW_AMPA = 0.01,cfg.bkgW_GABAA = 0.005
   IT2 : 11.000 Hz
   IT4 : 11.000 Hz
   IT5A : 11.000 Hz
   IT5B : 11.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 10.000 Hz
   IT6 : 11.000 Hz
   CT6 : 11.000 Hz

** M1_v12_tune14 - cfg.bkgW_AMPA = 0.01,cfg.bkgW_GABAA = 0.005, synsperconn HHreduced=5
  IT2 : 5.000 Hz
   IT4 : 5.000 Hz
   IT5A : 5.000 Hz
   IT5B : 5.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 0.000 Hz
   PV5 : 10.000 Hz
   IT6 : 5.000 Hz
   CT6 : 1.000 Hz

** M1_v12_tune15 - wire=1

   IT2 : 10.250 Hz
   IT4 : 10.000 Hz
   IT5A : 8.500 Hz
   IT5B : 4.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 17.000 Hz
   PV5 : 11.000 Hz
   IT6 : 5.000 Hz
   CT6 : 1.000 Hz

** M1_v12_tune16 - wire=1, cfg.bkgPTGain = 2.0
   IT2 : 10.250 Hz
   IT4 : 10.000 Hz
   IT5A : 8.500 Hz
   IT5B : 4.000 Hz
   PT5B : 0.000 Hz
   SOM5 : 17.000 Hz
   PV5 : 11.000 Hz
   IT6 : 5.000 Hz
   CT6 : 1.000 H

** M1_v12_tune17 - wire=1, cfg.bkgPTGain = 3.0
  Connections: 342 (17.10 per cell)
  Spikes: 153 (7.65 Hz)
   IT2 : 10.250 Hz
   IT4 : 10.000 Hz
   IT5A : 8.500 Hz
   IT5B : 4.000 Hz
   PT5B : 7.667 Hz
   SOM5 : 17.000 Hz
   PV5 : 11.000 Hz
   IT6 : 5.000 Hz
   CT6 : 1.000 Hz

** M1_v12_tune18 - wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0
  Connections: 342 (17.10 per cell)
  Spikes: 363 (18.15 Hz)
   IT2 : 18.500 Hz
   IT4 : 21.500 Hz
   IT5A : 19.000 Hz
   IT5B : 9.000 Hz
   PT5B : 23.000 Hz
   SOM5 : 30.000 Hz
   PV5 : 16.000 Hz
   IT6 : 15.500 Hz
   CT6 : 17.500 Hz

** M1_v12_tune18 - wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0, x=z=100um
** M1_v13_tune2 -  wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0
   IT2 : 13.250 Hz
   IT4 : 12.000 Hz
   IT5A : 14.000 Hz
   IT5B : 4.667 Hz
   PT5B : 21.667 Hz
   SOM5 : 26.000 Hz
   PV5 : 14.000 Hz
   IT6 : 12.000 Hz
   CT6 : 17.500 Hz
** M1_v13_tune3 -  wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0, x=z=100um
  Cells: 1184
  Connections: 526478 (444.66 per cell)
  Spikes: 2690 (2.27 Hz)
   IT2 : 1.288 Hz
   SOM2 : 3.880 Hz
   PV2 : 8.000 Hz
   IT4 : 0.262 Hz
   IT5A : 0.153 Hz
   IT5B : 0.422 Hz
   PT5B : 1.970 Hz
   SOM5 : 5.903 Hz
   PV5 : 8.387 Hz
   IT6 : 0.323 Hz
   CT6 : 4.121 Hz
   SOM6 : 2.871 Hz
   PV6 : 7.548 Hz

** M1_v13_tune4 - wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0, x=z=200um, 0.1s
- 260 sec setup time


Creating network of 39 cell populations on 4 hosts...
  Number of cells on node 1: 1188
  Number of cells on node 2: 1186
  Number of cells on node 3: 1184
  Number of cells on node 0: 1188
  Done; cell creation time = 2.00 s.
Making connections...
  Number of connections on node 3: 1878799
  Number of connections on node 0: 1883969
  Number of connections on node 1: 1896134
  Number of connections on node 2: 1891641
  Done; cell connection time = 246.13 s.
  Number of stims on node 2: 9972
  Number of stims on node 0: 9976
  Number of stims on node 3: 9952
  Number of stims on node 1: 9976
  Done; cell stims creation time = 0.00 s.

Running...
  Done; run time = 72.15 s; real-time ratio: 0.00.

Gathering data...
libc++abi.dylib: terminating with uncaught exception of type std::bad_alloc: std::bad_alloc
[Salvador-Duras-MacBook-Pro:18479] *** Process received signal ***
[Salvador-Duras-MacBook-Pro:18479] Signal: Abort trap: 6 (6)

** M1_v13_tune5 -  wire=1, cfg.bkgPTGain = 3.0 cfg.bkgNoise = 1.0, x=z=150um, 0.1s
Creating network of 39 cell populations on 4 hosts...
  Number of cells on node 0: 672
  Number of cells on node 1: 667
  Number of cells on node 2: 666
  Number of cells on node 3: 659
  Done; cell creation time = 1.03 s.
Making connections...
  Number of connections on node 1: 626750
  Number of connections on node 3: 625609
  Number of connections on node 0: 643539
  Number of connections on node 2: 626580
  Done; cell connection time = 77.33 s.
  Number of stims on node 2: 5604
  Number of stims on node 0: 5632
  Number of stims on node 3: 5550
  Number of stims on node 1: 5614
  Done; cell stims creation time = 0.00 s.

Running...
0.1 s
0.2 s
0.3 s
0.4 s
0.5 s
0.6 s
0.7 s
0.8 s
0.9 s
  Done; run time = 1605.26 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 147.32 s.

Analyzing...
  Cells: 2664
  Connections: 2522478 (946.88 per cell)
  Spikes: 3563 (1.34 Hz)
   IT2 : 0.293 Hz
   SOM2 : 1.596 Hz
   PV2 : 6.526 Hz
   IT4 : 0.033 Hz
   IT5A : 0.082 Hz
   IT5B : 0.347 Hz
   PT5B : 0.683 Hz
   SOM5 : 1.374 Hz
   PV5 : 9.036 Hz
   IT6 : 0.068 Hz
   CT6 : 2.251 Hz
   SOM6 : 1.333 Hz
   PV6 : 6.333 Hz
  Simulated time: 1.0 s; 4 workers
  Run time: 1605.26 s
Saving output as ../data/v13_manualTune/M1_v13_tune5.json  ...
>>>
>>>
Finished saving!
  Done; saving time = 0.20 s.
Plotting raster...
>>>
  Done; plotting time = 0.91 s

Total time = 1833.29 s
>>> [Salvador-Duras-MacBook-Pro:18891] *** Process received signal ***
[Salvador-Duras-MacBook-Pro:18891] Signal: Segmentation fault: 11 (11)

** M1_v15_tune1 - full PT cell IClamp 300 pA
not working
** M1_v15_tune2 - full PT cell IClamp 300pA - after fixing netpyne bug for importing 3d geoms
** M1_v15_tune3 - testing 5 PT cells to check shapePlot visualization
Creating network of 13 cell populations on 1 hosts...
  Number of cells on node 0: 10684
  Done; cell creation time = 1192.98 s
** M1_v15_tune4 - full PT cell IClamp 300pA - apic_42
EPSPs but no spikes
** M1_v15_tune5 - full PT cell with bkg; cfg.bkgPTGain = 3.0
- ACTUALLY v16!!

   IT4 : 5.000 Hz
   IT5A : 8.000 Hz
   IT5B : 7.333 Hz
   PT5B : 28.000 Hz
   SOM5 : 16.000 Hz
   PV5 : 14.000 Hz
   IT6 : 12.000 Hz
   CT6 : 15.000 Hz

  Simulated time: 0.5 s; 4 workers
  Run time: 95.43 s
Saving output as ../data/v15_manualTune/M1_v15_tune5.json  ...
Finished saving!
  Done; saving time = 0.39 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.41 s

Total time = 97.75 s

** M1_v15_tune6 - full PT cell with bkg; cfg.bkgPTGain = 1.0
- ACTUALLY v16!!

Analyzing...
  Cells: 18
  Connections: 164 (9.11 per cell)
  Spikes: 95 (10.56 Hz)
>>> >>>

   IT2 : 11.000 Hz
   IT4 : 5.000 Hz
>>>
   IT5A : 8.000 Hz
   IT5B : 7.333 Hz
   PT5B : 14.000 Hz
   SOM5 : 16.000 Hz
   PV5 : 14.000 Hz
   IT6 : 12.000 Hz
   CT6 : 15.000 Hz
  Simulated time: 0.5 s; 4 workers
  Run time: 91.21 s
Saving output as ../data/v15_manualTune/M1_v15_tune6.json  ...
Finished saving!
  Done; saving time = 0.38 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.34 s

Total time = 93.43 s

** M1_v15_tune7 - full PT cell with bkg; cfg.bkgPTGain = 1.0; wire; 15um
- ACTUALLY v16!!

Analyzing...
  Cells: 20
  Connections: 387 (19.35 per cell)
  Spikes: 107 (10.70 Hz)
>>>    IT2 : 11.500 Hz

   IT4 : 7.000 Hz
   IT5A : 7.000 Hz
   IT5B : 1.333 Hz
   PT5B : 12.000 Hz
   SOM5 : 22.000 Hz
   PV5 : 14.000 Hz
   IT6 : 11.000 Hz
   CT6 : 21.000 Hz
  Simulated time: 0.5 s; 4 workers
  Run time: 118.39 s
>>>
>>>
Saving output as ../data/v15_manualTune/M1_v15_tune7.json  ...
Finished saving!
  Done; saving time = 0.48 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.24 s

Total time = 120.99 s

** v14_batch1 - Explore EEGain,EIGain,IEGainIIGain in reduced net, 100um (bug EIGain, IEGain)
- EIGain and IEGain - fixed at 0.1 since EIPVGain and EISOMGain not set

b.params.append({'label': 'EEGain',  'values': [0.8, 0.9, 1.0, 1.1, 1.2]})
b.params.append({'label': 'EIGain',  'values': [0.8, 0.9, 1.0, 1.1, 1.2]})
b.params.append({'label': 'IEGain',  'values': [0.8, 0.9, 1.0, 1.1, 1.2]})
b.params.append({'label': 'IIGain',  'values': [0.8, 0.9, 1.0, 1.1, 1.2]})

# Setup
b.batchLabel = 'v14_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
 'script': 'init.py',
'numproc': 4,
'walltime': "00:20:00",
'queueName': 'longerq',
'sleepInterval': 5}

- 67 jobs running simult
- each job takes ~570 secs
- total jobs = 5^4 = 625
- should be done in ~2 hours ?

** v15_batch1 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in reduced cell net, 100um (bug)

- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py

b.params.append({'label': 'bkgEGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'bkgIGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EEGain',  'values': [0.6, 0.8, 1.0, 1.2, 1.4]})
b.params.append({'label': 'EIGain',  'values': [0.6, 0.8, 1.0, 1.2, 1.4]})
b.params.append({'label': 'IEGain',  'values': [0.6, 0.8, 1.0, 1.2, 1.4]})
b.params.append({'label': 'IIGain',  'values': [0.6, 0.8, 1.0, 1.2, 1.4]})


# Setup
b.batchLabel = 'v15_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque', 'script': 'init.py', 'numproc': 4, 'walltime': "00:20:00", 'queueName': 'longerq',
'sleepInterval': 5}

*** results
0 / 5625 match firing rate conditions: ['range']
3548 / 5625 match firing rate conditions: ['I>E']
105 / 5625 match firing rate conditions: ['L5>L6>L2']
1259 / 5625 match firing rate conditions: ['L5>L6']
2388 / 5625 match firing rate conditions: ['L5>L2']
4036 / 5625 match firing rate conditions: ['L6>L2']
3347 / 5625 match firing rate conditions: ['PV>LTS']
103 / 5625 match firing rate conditions: ['I>E', 'L5>L6>L2']
66 / 5625 match firing rate conditions: ['I>E', 'L5>L6>L2', 'PV>LTS']
0 / 5625 match firing rate conditions: ['range', 'I>E', 'L5>L6>L2', 'PV>LTS']
103 / 5625 match firing rate conditions: ['I>E', 'L5>L6>L2']
0 / 5625 match firing rate conditions: ['range', 'L5>L6>L2']

** v15_batch2 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in reduced cell net, 200um (bug)
- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py

# Add params
b.params.append({'label': 'bkgEGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'bkgIGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EIGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IIGain',  'values': [0.8, 1.0, 1.2]})


# Setup
b.batchLabel = 'v15_batch2'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 1,
			'walltime': "06:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5}


- Memory errors during gathering:

Gathering data...

=====================================================================================
=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES
=   EXIT CODE: 6
=   CLEANING UP REMAINING PROCESSES
=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES
=====================================================================================

terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc

** v15_batch3 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in reduced cell net, 150um (bug)
- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py

b.params.append({'label': 'bkgEGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'bkgIGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EIGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IIGain',  'values': [0.8, 1.0, 1.2]})


# Setup
b.batchLabel = 'v15_batch3'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 4,
			'walltime': "03:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5}

- 2664 cells
- ~1400 sec / sim
- 4 cores

- 729 sims
- 246 mins = 4 hr

*** results
0 / 729 match firing rate conditions: ['range']
544 / 729 match firing rate conditions: ['I>E']
5 / 729 match firing rate conditions: ['L5>L6>L2']
157 / 729 match firing rate conditions: ['L5>L6']
349 / 729 match firing rate conditions: ['L5>L2']
506 / 729 match firing rate conditions: ['L6>L2']
513 / 729 match firing rate conditions: ['PV>LTS']
0 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['range', 'I>E', 'L5>L6>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['range', 'L5>L6>L2']

** v16_batch1 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in net with full HH, 100um (bug)
- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py


# Add params
b.params.append({'label': 'bkgEGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'bkgIGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EIGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IIGain',  'values': [0.8, 1.0, 1.2]})


# Setup
b.batchLabel = 'v16_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 4,
			'walltime': "06:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5}

# run batch
b.run()

*** Error if try to use 8 cores:

Creating network of 39 cell populations on 8 hosts...
  Number of cells on node 0: 153
  Done; cell creation time = 5.07 s.
Making connections...
  Number of cells on node 1: 151
  Number of cells on node 2: 151
  Number of cells on node 3: 150
  Number of cells on node 4: 148
  Number of cells on node 5: 147
  Number of cells on node 6: 144
  Number of cells on node 7: 140
  Number of connections on node 7: 62917
  Number of connections on node 1: 63631
  Number of connections on node 4: 63619
  Number of connections on node 6: 65835
  Number of connections on node 0: 67407
  Number of connections on node 3: 67499
  Number of connections on node 2: 70118
  Number of connections on node 5: 64327
  Done; cell connection time = 30.75 s.
  Number of stims on node 6: 1216
  Number of stims on node 0: 1274
  Number of stims on node 1: 1270   Number of stims on node 7: 1192
  Number of stims on node 4: 1240

  Number of stims on node 5: 1230
  Number of stims on node 2: 1270
  Number of stims on node 3: 1260
  Done; cell stims creation time = 0.01 s.

Running...
nrn_timeout t=5.00433
ma% cat ../data/v16_batch1/v16_batch1_0_0_0_0_0_0.err
NEURON -- VERSION 7.5 (1451+:0ed21742d9f6+) 2016-07-17
Duke, Yale, and the BlueBrain Project -- Copyright 1984-2016
See http://neuron.yale.edu/neuron/credits

Additional mechanisms from files
 misc.mod stats.mod infot.mod vecst.mod nstim.mod samnutils.mod MyExp2SynBB.mod MyExp2SynNMDABB.mod izhi2007a.mod izhi2007b.mod h_BS.mod kap_BS.mod kdmc_BS.mod kdr_BS.mod nax_BS.mod naz.mod km.mod kv.mod kca.mod Nca.mod cadad.mod cat_mig.mod can_mig.mod cal_mig.mod cagk.mod IC.mod savedist.mod h_harnett.mod h_kole.mod kBK.mod HCN1.mod na2_mh.mod ar_traub.mod cat_traub.mod cal_mh.mod nap_sidi.mod ican_sidi.mod gabab.mod hsyn.mod
application called MPI_Abort(MPI_COMM_WORLD, 0) - process 0


*** trying with 4 cores -ok
*** still 43 files missing -ok rerun

*** results
0 / 728 match firing rate conditions: ['range']
114 / 728 match firing rate conditions: ['I>E']
288 / 728 match firing rate conditions: ['L5>L6>L2']
678 / 728 match firing rate conditions: ['L5>L6']
602 / 728 match firing rate conditions: ['L5>L2']
338 / 728 match firing rate conditions: ['L6>L2']
301 / 728 match firing rate conditions: ['PV>LTS']
111 / 728 match firing rate conditions: ['I>E', 'L5>L2']
66 / 728 match firing rate conditions: ['I>E', 'L5>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E', 'L5>L6>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E', 'L5>L2', 'PV>LTS']
33 / 728 match firing rate conditions: ['I>E', 'L5>L6>L2']
0 / 728 match firing rate conditions: ['range', 'L5>L6>L2']

** v16_batch2 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in net with full HH, 150um (bug)
- bug, CT sec['vinit'] = -75.0413649414 instead of -92.8364820902; and using CSTR.py instead of CSTR_new.py

b.params.append({'label': 'bkgEGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'bkgIGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EIGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IEGain',  'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'IIGain',  'values': [0.8, 1.0, 1.2]})


# Setup
b.batchLabel = 'v16_batch2'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 4,
			'walltime': "40:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5,
			'skip': True}

- with 4 cores get nrn_timeout error
- trying with 8 cores and cache_efficient - ok

*** results
0 / 729 match firing rate conditions: ['range']
10 / 729 match firing rate conditions: ['I>E']
163 / 729 match firing rate conditions: ['L5>L6>L2']
723 / 729 match firing rate conditions: ['L5>L6']
572 / 729 match firing rate conditions: ['L5>L2']
169 / 729 match firing rate conditions: ['L6>L2']
37 / 729 match firing rate conditions: ['PV>LTS']
7 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2']
7 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2', 'PV>LTS']
10 / 729 match firing rate conditions: ['I>E', 'L5>L2']
8 / 729 match firing rate conditions: ['I>E', 'L5>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['range', 'I>E', 'L5>L6>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['range', 'I>E', 'L5>L2', 'PV>LTS']
7 / 729 match firing rate conditions: ['I>E', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['range', 'L5>L6>L2']


- IT reduced low compared to PT full -- maybe include PT strength param
- check if can keep wiring gains constant, and just play with bkgInput -- maybe with AMPA and GABA params too
- nope -- not balanced
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161102_180621.png][fig]]

- check if fix EIGain =1.2

cfg.bkgW_AMPA = 0.01
cfg.bkgW_GABAA = 0.005
cfg.bkgEGain = 1.0
cfg.bkgIGain = 1.0
cfg.bkgPTGain = 1.0

- check if fix EIGain = 0.8

** v17_batch1 - Explore bkgEGain, bkgIGain, EEGain,EIGain,IEGainIIGain in net with full HH, 150um
- CT bug fixed
- Set to 2 sec

- example run time
  Done; run time = 7805.98 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 254.17 s.

Analyzing...
  Cells: 2664
  Connections: 2523313 (947.19 per cell)
  Spikes: 66400 (12.46 Hz)
   IT2 : 0.201 Hz
   SOM2 : 36.342 Hz
   PV2 : 20.132 Hz
   IT4 : 2.390 Hz
   IT5A : 17.082 Hz
   IT5B : 41.611 Hz
   PT5B : 21.706 Hz
   SOM5 : 21.853 Hz
   PV5 : 5.565 Hz
   IT6 : 0.002 Hz
   CT6 : 0.108 Hz
   SOM6 : 16.014 Hz
   PV6 : 8.949 Hz
  Simulated time: 2.0 s; 8 workers
  Run time: 7805.98 s
Saving output as ../data/v17_batch1/v17_batch1_0_0_0_0_0_0.json  ...
Finished saving!
  Done; saving time = 0.97 s.
  Done; plotting time = 0.00 s

Total time = 8166.40 s

*** results
*** results
159 / 728 match firing rate conditions: ['range']
15 / 728 match firing rate conditions: ['I>E']
455 / 728 match firing rate conditions: ['I>E (L2+6)']
29 / 728 match firing rate conditions: ['L5>L6>L2']
728 / 728 match firing rate conditions: ['L5>L6']
469 / 728 match firing rate conditions: ['L5>L2']
29 / 728 match firing rate conditions: ['L6>L2']
40 / 728 match firing rate conditions: ['PV>LTS']
29 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
17 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
455 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L2']
40 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
0 / 728 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L2', 'PV>LTS']
29 / 728 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
0 / 728 match firing rate conditions: ['range', 'L5>L6>L2']


--> bkgE=1.0 bkg=1 EE=1.0 EI=0.8 IE=1 II=1.2
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161106_153619.png][fig]]
   IT2 : 2.070 Hz
   SOM2 : 12.263 Hz
   PV2 : 7.149 Hz
   IT4 : 0.300 Hz
   IT5A : 1.140 Hz
   IT5B : 6.492 Hz
   PT5B : 29.205 Hz
   SOM5 : 5.450 Hz
   PV5 : 30.363 Hz
   IT6 : 0.195 Hz
   CT6 : 0.181 Hz
   SOM6 : 6.529 Hz
   PV6 : 3.725 Hz

--> bkgE=1.2 bkg=1.0 EE=1.0 EI=0.8 IE=1 II=1.2
   IT2 : 4.292 Hz
   SOM2 : 14.947 Hz
   PV2 : 8.184 Hz
   IT4 : 1.153 Hz
    IT5A : 3.120 Hz
   IT5B : 9.394 Hz
   PT5B : 30.683 Hz
   SOM5 : 10.640 Hz
   PV5 : 23.234 Hz
   IT6 : 0.151 Hz
   CT6 : 0.154 Hz
   SOM6 : 6.580 Hz
   PV6 : 4.203 Hz

bkgE=1.2 bkg=1.0 EE=1.0 EI=0.8 IE=1.2 II=1.0
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161106_153905.png][fig]]
   IT2 : 5.418 Hz
   SOM2 : 10.158 Hz
   PV2 : 6.482 Hz
   IT4 : 1.163 Hz
   IT5A : 1.685 Hz
   IT5B : 2.211 Hz
   PT5B : 22.980 Hz
   SOM5 : 7.799 Hz
   PV5 : 21.619 Hz
   IT6 : 0.432 Hz
   CT6 : 0.427 Hz
   SOM6 : 5.594 Hz
   PV6 : 2.449 Hz

bkgE=1.2 bkg=1.0 EE=1.2 EI=0.8 IE=1.2 II=0.8
   IT2 : 3.933 Hz
   SOM2 : 11.289 Hz
   PV2 : 5.763 Hz
   IT4 : 0.777 Hz
   IT5A : 1.908 Hz
   IT5B : 5.234 Hz
   PT5B : 22.693 Hz
   SOM5 : 7.683 Hz
   PV5 : 22.302 Hz
   IT6 : 0.176 Hz
   CT6 : 0.170 Hz
   SOM6 : 5.000 Hz
   PV6 : 3.384 Hz

bkgE=1.2 bkg=1.2 EE=1.0 EI=0.8 IE=1.0 II=1.2
   IT2 : 5.559 Hz
   SOM2 : 15.412 Hz
   PV2 : 9.096 Hz
   IT4 : 1.240 Hz
   IT5A : 3.839 Hz
   IT5B : 10.099 Hz
   PT5B : 27.505 Hz
   SOM5 : 12.637 Hz
   PV5 : 22.054 Hz
   IT6 : 0.127 Hz
   CT6 : 0.134 Hz
   SOM6 : 7.464 Hz
   PV6 : 3.891 Hz

--> bkgE=1.2 bkg=1.2 EE=1.2 EI=0.8 IE=1.0 II=0.8
   IT2 : 1.832 Hz
   SOM2 : 14.956 Hz
   PV2 : 8.754 Hz
   IT4 : 0.421 Hz
   IT5A : 1.071 Hz
   IT5B : 5.507 Hz
   PT5B : 29.381 Hz
   SOM5 : 7.892 Hz
   PV5 : 29.827 Hz
   IT6 : 0.059 Hz
   CT6 : 0.066 Hz
   SOM6 : 7.203 Hz
   PV6 : 5.319 Hz

** v18_batch1 - 5 iseeds x 5 wseeds 5 sec, uniform syn distribution full HH, 150um, 5 secs
- use: bkgE=1.0 bkg=1 EE=1.0 EI=0.8 IE=1 II=1.2 (from v17_batch1)
- 5 iseeds x 5 wseeds
- no need for 5 subcell seeds (since different wiring will lead to diff syn dist)
- 5 secs

** v18_batch2 - 5 iseeds x 5 wseeds 5 sec, uniform syn distribution full HH, 150um, 5 secs
bkgE=1.2 bkg=1.2 EE=1.2 EI=0.8 IE=1.0 II=0.8


*** results
total conns: 2523313
syns per PT cell: 1180
syns per PT cell from L2/3: 100

** v18_batch3 - 5 iseeds x 5 wseeds 5 sec, uniform syn distribution full HH, 150um, 5 secs
bkgE=1.2 bkg=1.0 EE=1.0 EI=0.8 IE=1 II=1.2
** v19_batch1 - Explore EPGain,IEGain, IIGain in reduced net, 150um, 2 sec

# Add params
b.params.append({'label': 'ESOMGain',   'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'EPVGain',    'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'SOMEGain',  	'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'PVEGain',  	'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'SOMIGain',  	'values': [0.8, 1.0, 1.2]})
b.params.append({'label': 'PVIGain',  	'values': [0.8, 1.0, 1.2]})



# Setup
b.batchLabel = 'v19_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 4,
			'walltime': "40:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5,
			'skip': True}

581 / 729 match firing rate conditions: ['range']
390 / 729 match firing rate conditions: ['I>E']
396 / 729 match firing rate conditions: ['I>E (L2+6)']
0 / 729 match firing rate conditions: ['L5>L6>L2']
600 / 729 match firing rate conditions: ['L5>L6']
0 / 729 match firing rate conditions: ['L5>L2']
0 / 729 match firing rate conditions: ['L6>L2']
15 / 729 match firing rate conditions: ['PV>LTS']
0 / 729 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['I>E (L2+6)', 'L5>L2']
0 / 729 match firing rate conditions: ['I>E (L2+6)', 'L5>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L6>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L2', 'PV>LTS']
0 / 729 match firing rate conditions: ['I>E (L2+6)', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['range', 'L5>L6>L2']
0 / 729 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L2']
0 / 729 match firing rate conditions: ['range', 'I>E (L2+6)', 'L5>L2']

** v20_batch1 - 5 iseeds x 5 wseeds 5 sec, uniform syn distribution full HH, 150um, 5 secs
## E->I gains
cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8

## I->E gains
cfg.PVEGain = 1.0
cfg.SOMEGain = 1.0

## I->I gains
cfg.PVIGain = 1.0
cfg.SOMIGain = 1.0

# Add params
b.params.append({'label': 'wseed',   'values': [4321, 4321+17*1, 4321+17*2, 4321+17*3, 4321+17*4]})
b.params.append({'label': 'iseed',   'values': [1234, 1234+17*1, 1234+17*2, 1234+17*3, 1234+17*5]})


# Setup
b.batchLabel = 'v20_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_torque',
			'script': 'init.py',
			'numproc': 12,
			'walltime': "40:00:00",
			'queueName': 'longerq',
			'sleepInterval': 5,
			'skip': True}

# run batch
b.run()


- results don't match v19_batch1 with same params; possible differences:
-- PT full vs reduced - shouldn't affect
-- subcellular rules
-- netpyne implementation of subcellular

- checking by running individual sim with reduced and no subcell rules (looks ok - v20_manualTune_1)
- fixed netpyne to so syns distributed properly even in 'sec' (spiny) doesn't exist (looks ok - v20_manualTune_2)
- added 'spiny' to reduced model (looks ok - v20_manualTune_3)

- lower firing of IT2, IT4 and IT5A when include subcellular for PT5B reduced -- why??
-- lower PT5B (no subcellular) leads to lower Inh -> higher IT ? interlaminar effects of I?
-- yes, placed only 1 PT5B cell and that increased ITs rate -- must be some effect E (PT) -> I (L2) (v20_manualTune_4)

- why no difference betweeen distribute over spiny vs non-spiny?
-- wasn't adding properly spiny!

- testing 2dmap and 1dmap distributions

- big effect on dynamics of IT2 if use 2Dmap instead of uniform = lower PT rate (v20_manualTune_5)
- same for 1D map (v20_manualTune_6) -- effect mediated via E5->I2

** v20_batch2 - 5 iseeds x 5 wseeds 5 sec, [uniform,1d,2d] syn distribution, PT full HH, 150um, 5 secs (bug)
- full PT position at >900um instead of 735 (affects 1d and 2d dist)

## E->I gains
cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8

## I->E gains
cfg.PVEGain = 1.0
cfg.SOMEGain = 1.0

## I->I gains
cfg.PVIGain = 1.0
cfg.SOMIGain = 1.0

- prev sims showed bkgPTGain x3 in PT showed good results -- maybe next sim repeat with x2 ?!

** v20_batch3 - 5 iseeds x 5 wseeds 5 sec, [uniform,1d,2d] syn distribution, PT full HH, 150um, 5 secs (bug)
- full PT position at >900um instead of 735 (affects 1d and 2d dist)

repeat with: cfg.bkgEGain = 1.5

shows higher activity of L2/3+5A (v20_tune7)

- didn't increase L4, L5A and L5B

** v20_batch4 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

cfg.bkgEGain = 1.5
cfg.EPVGain = 1.0
cfg.ESOMGain = 0.6

** v20_batch5 - 5 iseeds x 5 wseeds 5 sec, [uniform,1d,2d] syn distribution, PT full HH, 150um, 5 secs
cfg.bkgEGain = 1.5
cfg.EPVGain = 1.0
cfg.ESOMGain = 0.6

** v20_batch6 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

cfg.bkgEGain = 1.2
cfg.EPVGain = 1.0
cfg.ESOMGain = 0.6

- many good examples of L5A firing for ~50% of time

** v20_batch7 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

- repeat v20_batch2 without ypos bug

cfg.bkgEGain = 1.2
cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8

- mostly very low firing L5A

** v20_batch8 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

- another good solution from v19_batch1:

cfg.bkgEGain = 1.2

cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8
cfg.SOMIGain = 1.2
cfg.PVIGain = 0.8

- low L5 IT firing, or hyperexc during last 500 ms

** v20_batch9 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

- another good solution from v19_batch1:

cfg.bkgEGain = 1.2

cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8
cfg.SOMIGain = 1.2
cfg.PVIGain = 1.2

- low L5 IT firing, or hyperexc during last 500 ms

** v20_batch10 - 2 iseeds x 2 wseeds 5 sec, [uniform] syn distribution, PT full HH, 150um, 5 secs

- another good solution from v19_batch1:

cfg.bkgEGain = 1.2

cfg.EPVGain = 1.0
cfg.ESOMGain = 0.8
cfg.SOMIGain = 1.0
cfg.PVIGain = 1.0

- mostly very low L5 IT firing

** v21_batch1 - IT cell Adend length vs f-I curve
- similar f-I curves
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161215_123347.png][fig]]

** v22_manualTune2 - testing num cells and conns
Creating network of 22 cell populations on 4 hosts...
  Number of cells on node 3: 4268
  Number of cells on node 0: 4275
  Done; cell creation time = 5.28 s.
  Number of cells on node 1: 4271
  Number of cells on node 2: 4270
Making connections...
  Number of connections on node 0: 788462
  Number of connections on node 1: 800902
  Number of connections on node 3: 786634
  Number of connections on node 2: 789049
  Done; cell connection time = 110.29 s.
  Number of stims on node 2: 0
  Number of stims on node 3: 0
  Number of stims on node 0: 0
  Number of stims on node 1: 0
  Done; cell stims creation time = 0.00 s.

Running...
  Done; run time = 77.05 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 263.71 s.

Analyzing...
  Cells: 17084
  Connections: 3165047 (185.26 per cell)
  Spikes: 0 (0.00 Hz)
   IT2 : 0.000 Hz
   SOM2 : 0.000 Hz
   PV2 : 0.000 Hz
   IT4 : 0.000 Hz
   IT5A : 0.000 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 0.000 Hz
   PT5B : 0.000 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.000 Hz
   IT6 : 0.000 Hz
   CT6 : 0.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz
   TPO : 0.000 Hz
   TVL : 0.000 Hz
   S1 : 0.000 Hz
   S2 : 0.000 Hz
   cM1 : 0.000 Hz
   M2 : 0.000 Hz
   OC : 0.000 Hz
  Simulated time: 0.1 s; 4 workers
  Run time: 77.05 s
>>>
>>>
>>>
Saving output as ../data/v22_manualTune/M1_v22_tune2.json  ...
Finished saving!
  Done; saving time = 333.26 s.
Plotting raster...
No spikes available to plot raster
  Done; plotting time = 6.37 s

Total time = 800.84 s
** v22_manualTune3 - 10k cells, E 5 syns/conn, all 60M conns
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17084
  Done; cell creation time = 5.38 s.
Making connections...
  Number of connections on node 0: 59257660
  Done; cell connection time = 5337.61 s.

Gathering data...
  Done; gather time = 0.03 s.

Analyzing...
  Cells: 17084
  Connections: 59257660 (3468.61 per cell)
Saving output as ../data/v22_manualTune/M1_v22_tune3.json  ...
Finished saving!
  Done; saving time = 3062.22 s.

- only python objects
- fixed num syns for all cell types in long range: 8234
- num syns/cell ~= 60M/10k = 6000; E cells ~=7200 syns (5 syns/conn); I cells ~= 1800 (1 syn/conn)
- note E syns include AMPA+NMDA, and SOM syns include GABAASlow and GABAB
- output file: ~8GB
- ram memory: 10GB
- time: conns, 1h50 ; saving, 30min
- 1803 conn rules

** v22_manualTune4 - 10k cells, 1 syn/conn, local+long, fixedNumSyns=0
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17084
  Done; cell creation time = 5.01 s.
Making connections...
  Number of connections on node 0: 7620529
  Number of synaptic contacts on node 0: 15092565
  Done; cell connection time = 1722.65 s.

Gathering data...
  Done; gather time = 0.01 s.

Analyzing...
  Cells: 17084
  Connections: 7620529 (446.06 per cell)
  Synaptic contacts: 15092565 (883.43 per cell)
Saving output as ../data/v22_manualTune/M1_v22_tune4.json  ...
Finished saving!
  Done; saving time = 676.56 s.

- len(cell[100].conns) = 1354

** v22_manualTune5 - 10k cells, 1 syn/conn, only local, fixedNumSyns=0
Creating network of 15 cell populations on 1 hosts...
  Number of cells on node 0: 10084
  Done; cell creation time = 5.02 s.
Making connections...
	  Number of connections on node 0: 3723464
  Number of synaptic contacts on node 0: 7209195
  Done; cell connection time = 1114.37 s.

Gathering data...
  Done; gather time = 0.01 s.

Analyzing...
  Cells: 10084
  Connections: 3723464 (369.24 per cell)
  Synaptic contacts: 7209195 (714.91 per cell)
Saving output as ../data/v22_manualTune/M1_v22_tune5.json  ...
Finished saving!
  Done; saving time = 358.86 s.

- len(cell[100].conns) = 1354

- local+long = 7620529/10084 = 776 input cells ~= 3880 syns
- local = 3723464 /10084 = 370 input cells ~= 1850
- 1850 / 0.3 = 6166 (which fits well with the initial assumption of ~8k inputs)

** v22_manualTune6 - 10k cells, 1 syn/conn, local+long, fixedNumSyns=1
** v22_manualTune7 - 10k cells, 1 syn/conn, only local, fixedNumSyns=1
** v22_manualTune8 - 10k cells, 1 syn/conn, local+long, fixedNumSyns=1, fixed conn bugs
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17084
  Done; cell creation time = 5.30 s.
Making connections...
  Number of connections on node 0: 7722032
  Number of synaptic contacts on node 0: 14823720
  Done; cell connection time = 1871.54 s.

Gathering data...
  Done; gather time = 0.02 s.

Analyzing...
  Cells: 17084
  Connections: 7722032 (452.00 per cell)
  Synaptic contacts: 14823720 (867.70 per cell)
Saving output as ../data/v22_manualTune/M1_v22_tune8.json  ...
Finished saving!
  Done; saving time = 664.59 s.

** v22_manualTune9 - 10k cells, 1 syn/conn, only local, fixedNumSyns=1, fixed conn bugs
Creating network of 15 cell populations on 1 hosts...
  Number of cells on node 0: 10084
  Done; cell creation time = 4.65 s.
Making connections...
  Number of connections on node 0: 3983965
  Number of synaptic contacts on node 0: 7280527
  Done; cell connection time = 1244.35 s.

Gathering data...
  Done; gather time = 0.01 s.

Analyzing...
  Cells: 10084
  Connections: 3983965 (395.08 per cell)
  Synaptic contacts: 7280527 (721.99 per cell)
Saving output as ../data/v22_manualTune/M1_v22_tune9.json  ...
Finished saving!
  Done; saving time = 361.50 s.

** v23_batch1 - PT EPSP amp for 1 netstim spike at 2 secs (soma, tuft)
** v23_batch2 - PT EPSP amp for 1 netstim spike at 5 secs (soma,basal, trunk, upper, tuft)
** v23_batch3 - PT EPSP amp for 1 netstim spike at 4 tuft secs
** v23_batch4 - PT EPSP amp for 1 netstim spike at 4 non-tuft secs
- test if scaling weight by EPSP ratio is enough to reproduce EPSP
- yes, enough
** v24_manualTune - testing tuft spikes
- tune3: weight= 0.0008 -> no tuft spike
- tune2: weight= 0.001 -> tuft spike
- tune5: checking if multiple syns add up -- no linear summation!
- tune6: testing effect of nax in IT cell apic_25 - w=0.005-> -57mV
- tune7: w=0.01 -> 5mv - spk
- tune8: w=0.01, gbar/4 ->
- tune9, 10, 11: IClamp 0.4nA, with na, na/4, na/10 -- very similar firing rate (ah but only changed 1 section!!)

** v24_batch1 - EPSP vs weight for new CSTR6 BS1578 cell
no dend spikes
Ratio soma: 1.000
Ratio Adend1: 1.456
Ratio Adend2: 1.728
Ratio Adend3: 1.834
Ratio axon: 2.140
Ratio Bdend: 1.102

** v24_batch2 - EPSP vs weight for new CSTR6 BS1579 cell
Loading single file with all data...
Ratio soma: 1.000
Ratio Adend1: 1.736
Ratio Adend2: 2.216
Ratio Adend3: 2.408
Ratio axon: 3.999
Ratio Bdend: 1.171

** v24_batch3 - EPSP vs weight for new SPI6 cell
Ratio soma: 1.000
Ratio Adend1: 2.182
Ratio Adend2: 4.537
Ratio Adend3: 6.920
Ratio axon: 3.234
Ratio Bdend: 1.155

** v24_batch4 - EPSP vs weight (+weightNorm) for IT BS1579 cell
- calculated by interpolating line to obtain weight that generates 0.5 mV EPSP for single syn input
- store in 'weightNorm' -- values around 0.00036 (uohm)
** v24_batch5 - Testing IT BS1579 after adding weightNorm
- all sections now show 0.5 mV epsp +- 0.0003
** v24_batch6 - Testing IT BS1579 after adding weightNorm and loc=1.0 (segment)
- set segment to 1.0
- all sections now range of epsp = [0.45, 0.5] (1 outlier at 0.41) (max factor = 1.077)
** v24_batch7 - Testing IT BS1579 after adding weightNorm and loc=0.0 (segment)
- all sections range of epsp = [0.50, 0.55] (3 outliers at ~0.57, and 0.67) (min factor = 0.884)
** v24_batch8 - EPSP vs weight (+weightNorm) for IT BS1579 cell for all segments
- all segments
- AMPA+NMDA
- bug placing synapse at wrong locations (1.0 -- cant place pointprocess) -- rerun
** v24_batch9 - Testing IT BS1579 after weightNorm for all segments
- good: 0.1 in range ~[0.09, 0.11]
- 0.5 in range ~[0.47, 0.51]

** v25_batch1 - fI curve of all reduced E cell models
- getting different results for IT5A and IT5B even though should be identical cells -- plus weirdly high peaks
- netpyne bug: gid increases but gid2lid not updated when cell with no properties is added

- if set IT5A cellParams only different than in load IT5A and CT6
- cvode active also changed results - but still different if load IT4 before or not
- related to atol -- rounding errors
- fixed by adding in init.py: from neuron import h; h.cvode.atol(1e-6)

** v25_batch2 - fI curve of all reduced E cell models (after fixing mod/atol issue)
ok

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170120_131046.png][fig]]

** v25_batch3 - fI curve of all reduced+full E cell models
ok

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170120_154847.png][fig]]

** v25_batch4 - Generate weightNorm for all cells in same batch
- set batch param: cellType, somaLabel
- assume excitatory inputs to [AMPA, NMDA]
** v25_batch5 - Test all reduced cells with weightNorm
- all ok;
eg. PT5B:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170123_161912.png][fig]]

** v25_batch6 - Test if still works for SOME syn inputs
- SOMESynMech = ['GABAASlow','GABAB']
- if different weightNorm, need to rerun

- not possible to quantify properly since ipsp will depend on RMP syn erev and driving force, ie. at -80 effect of inh syn is
  negligible

- PV (GABAA) stronger effect

- if increase rmp to ~-60 with current input, then effect more clear, and cancels out epsp effect

** v25_batch7 - fI curve for PV2 and SOM2
** v25_batch8 - Test a bunch of PV and SOM cells
b = IFcurve(pops=['PV1', 'PV3', 'PV16', 'SOM3', 'SOM16'])
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170129_200913.png][fig]]
** v25_manualTune - variety of single cell tests
- _tune35: PV16 and SOM16 speed

  Done; run time = 49.62 s; real-time ratio: 0.02.

Gathering data...
  Done; gather time = 1.06 s.
Analyzing...
  Cells: 200
  Connections: 7951 (39.76 per cell)
  Synaptic contacts: 15902 (79.51 per cell)
  Spikes: 8908 (44.54 Hz)
   PV16 : 3.450 Hz
   SOM16 : 85.630 Hz
  Simulated time: 1.0 s; 1 workers
  Run time: 49.62 s
Saving output as ../data/v25_manualTune/M1_v25_tune35.json  ...
Finished saving!
  Done; saving time = 2.23 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 0.90 s

Total time = 56.16 s


- _tune38:
  Done; run time = 48.39 s; real-time ratio: 0.02.

Gathering data...
  Done; gather time = 0.64 s.

Analyzing...
  Cells: 200
  Connections: 0 (0.00 per cell)
  Spikes: 6400 (32.00 Hz)
  PV16 : 0.000 Hz
   SOM16 : 64.000 Hz
  Simulated time: 1.0 s; 1 workers
  Run time: 48.39 s
Saving output as ../data/v25_manualTune/M1_v25_tune38.json  ...
Finished saving!
  Done; saving time = 1.39 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 0.74 s

Total time = 51.73 s



- _tune36: PV3 and SOM3

  Done; run time = 7.54 s; real-time ratio: 0.13.

Gathering data...
  Done; gather time = 0.52 s.

Analyzing...
  Cells: 200
  Connections: 7951 (39.76 per cell)
  Synaptic contacts: 15902 (79.51 per cell)
  Spikes: 2639 (13.20 Hz)
   PV3 : 12.400 Hz
   SOM3 : 13.990 Hz
  Simulated time: 1.0 s; 1 workers
  Run time: 7.54 s
Saving output as ../data/v25_manualTune/M1_v25_tune36.json  ...
Finished saving!
  Done; saving time = 1.17 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 0.52 s

Total time = 11.39 s

- _tune37: PV3 SOM3
  Done; run time = 8.14 s; real-time ratio: 0.12.

Gathering data...
  Done; gather time = 0.55 s.

Analyzing...
  Cells: 200
  Connections: 7951 (39.76 per cell)
  Synaptic contacts: 15902 (79.51 per cell)
  Spikes: 20146 (100.73 Hz)
   PV3 : 22.230 Hz
   SOM3 : 179.230 Hz
  Simulated time: 1.0 s; 1 workers
  Run time: 8.14 s
Saving output as ../data/v25_manualTune/M1_v25_tune37.json  ...
Finished saving!
  Done; saving time = 1.30 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 1.28 s

Total time = 12.94 s

** v25_batch9 - Test PV3 and SOM3 with dend L [1.25:2.0]
- PV decreases faster than SOM

** v25_batch10 - Test PV3 and SOM3 with dend L [2.0:10.0]
2.0 for PV
8.0 for SOM

** v25_batch11 - Final set of fI curves for reduced models
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170130_144050.png][fig]]

** v25_batch12 - detailed PT fI curve for reduced dend Na

** v26_manualTune - testing PT cell reduced Na
modified PT v1:
1 - original (dend = 1, axon = 5): 8 spks
2 - dend=0.5, axon 5: 0 spks (subthresh, osc)
3 - dend=0.5, axon=25: 0 spks (10 spks but subthresh)
4 - dend 0.5, axon 50: 0 spks (spks decreased, V increased)
5 - dend 0.5, axon 100: 0 spks (spks decreased, V increased)
6 - dend 0.5, axon 200: 0 spks (spks decreased, V increased)
7 - dend 0.5, axon 500: 0 spks (1 spk, saturated?)
8 - dend 0.5, axon 300: 0 spks (spks increased, V same)
9 - dend 0.5, axon 400: 0 spk (spks increased, V same)
10 - dend 0.5, axon 200, Ra 0.5: 7 spks!!
11 - dend 0.5, axon 5, Ra 0.5: 0 spks (13 spk subthresh)
12 - dend 0.5, axon 5, Ra 0.05: 0 spks (9 spk subthresh)
13 - dend 0.5, axon 5, Ra 0.01: 0 spks (9 spk subthresh, higher V)
14 - dend 0.5, axon 5, Ra 0.001: 9 spk!!
15 - dend 0.5, axon 5, Ra 0.0001: 9 spk!! (inc V, reduced spk)
16 - dend 0.5, axon 5, Ra 0.00005: 9 spk!! (~same)
17 - dend 0.5, axon 5, Ra 0.000001: 9 spk!! (~same)
18 - dend 0.5, axon 50, Ra 0.0001: 6 spk (very low baseline)
19 - dend 0.5, axon 10, Ra 0.0001: 7 spk (ok baseline; higher peak)
20 - dend 0.5, axon 10, Ra 0.001: 7 spk (closer to orig)
21 - dend 0.5, axon 10, Ra 0.01: 6 spk (very low baseline)
22 - dend 0.5, axon 9, Ra 0.01: 6 spk (very low baseline)

27 - Still have dend Na spikes with dend Na at 0.5 (apic_28)
28 - If reduce dend NA to 0.25 then no spks - now need to retune fI curve!

modified PT v2:
29 - Check fI curve:  dend 0.2, axon 8, Ra 0.01: 0 spk (8 spk subthresh)
30 - dend 0.2, axon 10, Ra 0.01: 8 spk (still V a bit lower)
31 - dend 0.2, axon 11, Ra 0.01: 8 spk (slightly higher V amp, baseline lower)
32 - dend 0.2, axon 12, Ra 0.01: 8 spk (slightly higher V amp, but also baseline lower)
33 - dend 0.2, axon 10, Ra 0.002: 8 spk (amp too high; base too low; but better)
34 - dend 0.2, axon 8, Ra 0.002: 8 spk (amp too high; base too low; but better)
35 - dend 0.2, axon 9, Ra 0.002: 8 spk (baseline lower; freq better)
36 - dend 0.2, axon 8, Ra 0.001: 8 spk (baseline lower; freq worse)
37 - dend 0.2, axon 8, Ra 0.004: 8 spk (Ra modifies peak; axon na modifes freq ¿)
38 - dend 0.2, axon 7, Ra 0.002: 9 spk (freq too high)
39 - dend 0.2, axon 10, Ra 0.004: 8 spk
40 - dend 0.2, axon 11, Ra 0.005: 8 spk
41 - dend 0.2, axon 11.5, Ra 0.005: 8 spk (baseline too low)
42 - dend 0.2, axon 11.5, Ra 0.008: 8 spk (baseline better but peak low)
43 - dend 0.2, axon 11, Ra 0.008: 8 spk
44 - dend 0.2, axon 11, Ra 0.01: 8 spk
45 - dend 0.2, axon 11, Ra 0.005: 8 spk


modified PT v2 with ca hotspots - was using PTcell.hoc from central repo!!
58 - current soma - very similar (slightly lower freq)
51 - syn input with ca apic tuft
52 - syn input w/o ca apict tuft - time shift
53 - syn input with ca upper trunk
54 - syn input w/o ca upper trunk - time shift
55 - syn with ca upper trunk, V dend
56 - syn w/o ca upper trunk, V dend

** v26_batch1 - detailed PT fI curve with axon Ra*0.01, Na*[7:10]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170206_200028.png][fig]]
best = axon Na dend = 8

** v26_batch2 - calculate weightNorm for modified PT cell v1 (reduced NA etc)
still seems like some nonlinear dend effects (maybe spks?)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_111641.png][fig]]

confirmed still getting spike-like activity in dends (eg. apic_28):
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_113143.png][fig]]

reduced Na to 0.25
** v26_batch3 - check modified PT v2 has no dend spks via weightNorm on 4 main segs
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_142031.png][fig]] - ok

** v26_bathch4 - fI curve of modified PT v2
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_142116.png][fig]]

** v26_bathch5 - fI curve of original PT
** v26_batch6 - calculate weightNorm for modified PT cell v2 for all segs
~10% of syns show very small slope so require very high weights to reach 0.5mV
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170209_135808.png][fig]]
histogram: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170209_135826.png][fig]]

** v26_batch7 - test PT cell with weightNorm
- not so good! - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170209_184207.png][fig]]
- 0.1 mV = 0.0813 - 0.294 mV  (overestimate)
- 0.5 mV = 0.19 - 0.54 mV (underestimate)

- 0.1 hist: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170209_184705.png][fig]]
- 0.5 hist: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170209_184914.png][fig]]

- actually most of them ok
- probably same segments are causing high 0.1 and low 0.5 -- low sensitivity / dynamic range; not scaling linearly

** v26_batch8 - fI curve of modified PT v2 with cahotspot
ok - quite similar
[[file:/u/salvadord/Documents/ISB/Models/m1/data/v26_batch8/v26_batch8_fI.png][fI curve]]
** v26_batch9 - calculate weightNorm for modified PT v2 with cahotspot

zn% screen -L mpiexec -np 32 nrniv -python -mpi batch.py -nogui

** v26_batch10 -  modified PT v2 with cahotspot with weightNorm
reasonable
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170222_195012.png][fig]]

- some segments have high 0.1 and low 0.5 due low sensitivity / dynamic range; not scaling linearly

** v27_manualTune - checking network model after fixing all cells, syn dend PT
*** 1 - check IClamp of 0.4nA matches with fI curves for each cell type
- SOM2 - 93Hz ok
- PV2 - 114Hz ok
- IT2 - 0Hz ?? - ~15Hz - fixed cellType was 'IT2' instead of 'IT' - 13Hz ok
- IT4 - 11Hz - ok
- IT5A reduced - 28Hz - ~10Hz - was using 1579 - ok
- IT5A full - 30 Hz - ok
- IT5B - 28Hz - ~10Hz - ok
- PT5B reduced - 10Hz - ~20Hz ?? - PT full rule wrong conds - 20Hz ok
- PT5B full - 21Hz ok
- IT6 - 30 Hz - ok
- CT6 - 9Hz - ok

*** 2- Testing bkg long range inputs to all pops -- not bad for 1st untuned attempt!
  Cells: 7015
  Connections: 5713 (0.81 per cell)
  Synaptic contacts: 11527 (1.64 per cell)
  Spikes: 15615 (2.23 Hz)
   IT2 : 19.000 Hz
   SOM2 : 1.000 Hz
   PV2 : 1.000 Hz
   IT4 : 50.000 Hz
   IT5A : 45.000 Hz
   SOM5A : 1.000 Hz
   PV5A : 1.000 Hz
   IT5B : 42.000 Hz
   PT5B : 21.000 Hz
   SOM5B : 1.000 Hz
   PV5B : 1.000 Hz
   IT6 : 27.000 Hz
   CT6 : 16.000 Hz
   SOM6 : 1.000 Hz
   PV6 : 1.000 Hz
   TPO : 2.266 Hz
   TVL : 2.254 Hz
   S1 : 2.170 Hz
   S2 : 2.189 Hz
   cM1 : 2.093 Hz
   M2 : 2.229 Hz
   OC : 2.186 Hz

*** 3. Conn, longConn, 100x100 um; no subcellConn
Running...
0.1 s
0.2 s
0.3 s
0.4 s
0.5 s
0.6 s
0.7 s
0.8 s
0.9 s
  Done; run time = 63.67 s; real-time ratio: 0.02.

Gathering data...
  Done; gather time = 48.02 s.

Analyzing...
>>>
>>>
>>>
  Cells: 8097
  Connections: 460525 (56.88 per cell)
  Synaptic contacts: 915538 (113.07 per cell)
  Spikes: 41908 (5.18 Hz)
   IT2 : 5.433 Hz
   SOM2 : 5.091 Hz
   PV2 : 5.522 Hz
   IT4 : 16.236 Hz
   IT5A : 50.286 Hz
   SOM5A : 3.500 Hz
   PV5A : 6.750 Hz
   IT5B : 48.817 Hz
   PT5B : 39.992 Hz
   SOM5B : 3.500 Hz
   PV5B : 7.022 Hz
   IT6 : 29.843 Hz
   CT6 : 20.780 Hz
   SOM6 : 5.000 Hz
   PV6 : 7.478 Hz
   TPO : 2.303 Hz
   TVL : 2.121 Hz
   S1 : 2.170 Hz
   S2 : 2.116 Hz
   cM1 : 2.219 Hz
   M2 : 2.199 Hz
   OC : 2.276 Hz
  Simulated time: 1.0 s; 4 workers
  Run time: 63.67 s
Saving output as ../data/v27_manualTune/M1_v27_tune3.json  ...
Finished saving!
  Done; saving time = 66.09 s.
Plotting raster...
  Done; plotting time = 6.76 s

Total time = 244.95 s

4.
*** 4. Conn, longConn, subcellConn, 50x50 um
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 7300
  Done; cell creation time = 1.81 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 0: 119052
  Number of synaptic contacts on node 0: 238727
  Done; cell connection time = 36.16 s.
  Number of stims on node 0: 0
  Done; cell stims creation time = 0.00 s.

Warning: global variable celsius=34, but cellParams rule PV_simple requires celsius=23.0

Warning: global variable celsius=34, but cellParams rule SOM_simple requires celsius=23.0

Running...
0.1 s
0.2 s
0.3 s
0.4 s
0.5 s
0.6 s
0.7 s
0.8 s
0.9 s
  Done; run time = 60.83 s; real-time ratio: 0.02.

Gathering data...
  Done; gather time = 6.46 s.

Analyzing...
  Cells: 7300
  Connections: 119052 (16.31 per cell)
  Synaptic contacts: 238727 (32.70 per cell)
  Spikes: 22885 (3.13 Hz)
   IT2 : 27.553 Hz
   SOM2 : 4.250 Hz
   PV2 : 3.444 Hz
   IT4 : 30.963 Hz
   IT5A : 44.353 Hz
   SOM5A : 3.000 Hz
   PV5A : 3.333 Hz
   IT5B : 46.581 Hz
   PT5B : 27.032 Hz
   SOM5B : 3.400 Hz
   PV5B : 3.455 Hz
   IT6 : 23.974 Hz
   CT6 : 12.256 Hz
   SOM6 : 3.000 Hz
   PV6 : 2.000 Hz
   TPO : 2.223 Hz
   TVL : 2.266 Hz
   S1 : 2.165 Hz
   S2 : 2.155 Hz
   cM1 : 2.113 Hz
   M2 : 2.215 Hz
   OC : 2.237 Hz
  Simulated time: 1.0 s; 1 workers
  Run time: 60.83 s
Saving output as ../data/v27_manualTune/M1_v27_tune4.json  ...
Finished saving!
  Done; saving time = 14.29 s.
Plotting raster...
  Done; plotting time = 3.23 s

*** 5. Conn, longConn, subcellConn, 300x300 um, 1syn/conn, all reduced
Creating network of 22 cell populations on 16 hosts...
  Number of cells on node 0: 1145
  Done; cell creation time = 1.38 s.
  Number of cells on node 1: 1143
  Number of cells on node 2: 1143
  Number of cells on node 3: 1142
  Number of cells on node 4: 1140
  Number of cells on node 5: 1139
  Number of cells on node 6: 1138
  Number of cells on node 7: 1137
  Number of cells on node 8: 1127
  Number of cells on node 9: 1125
  Number of cells on node 10: 1125
  Number of cells on node 11: 1124
  Number of cells on node 12: 1124
  Number of cells on node 13: 1124
  Number of cells on node 14: 1124
  Number of cells on node 15: 1124
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 10: 579446
  Number of synaptic contacts on node 10: 1116665
  Number of connections on node 12: 583470
  Number of synaptic contacts on node 12: 1124786
  Number of connections on node 13: 586035
  Number of synaptic contacts on node 13: 1129876
  Number of connections on node 15: 584395
  Number of synaptic contacts on node 15: 1127697
  Number of connections on node 14: 582620
  Number of synaptic contacts on node 14: 1123198
  Number of connections on node 6: 589544
  Number of synaptic contacts on node 6: 1137286
  Number of connections on node 11: 593884
  Number of synaptic contacts on node 11: 1144936
  Number of connections on node 9: 582518
  Number of synaptic contacts on node 9: 1122805
  Number of connections on node 7: 590838
  Number of synaptic contacts on node 7: 1139710
  Number of connections on node 8: 583015
  Number of synaptic contacts on node 8: 1124589
  Number of connections on node 0: 605629
  Number of synaptic contacts on node 0: 1167845
  Number of connections on node 1: 598997
  Number of synaptic contacts on node 1: 1154480
  Number of connections on node 3: 598851
  Number of synaptic contacts on node 3: 1155413
  Number of connections on node 5: 594149
  Number of synaptic contacts on node 5: 1145557
  Number of connections on node 2: 600593
  Number of synaptic contacts on node 2: 1158568
  Number of connections on node 4: 597059
  Number of synaptic contacts on node 4: 1151778
  Done; cell connection time = 641.16 s.

Warning: global variable celsius=34, but cellParams rule SOM_simple requires celsius=23.0

Running...
0.1 s
0.2 s
0.3 s
0.4 s
0.5 s
0.6 s
0.7 s
0.8 s
0.9 s
  Done; run time = 3248.00 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 5.16 s.

Analyzing...
>>>

  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 69971 (3.86 Hz)
   IT2 : 1.661 Hz
   SOM2 : 3.123 Hz
   PV2 : 2.571 Hz
   IT4 : 2.015 Hz
   IT5A : 5.047 Hz
   SOM5A : 3.327 Hz
   PV5A : 2.455 Hz
   IT5B : 8.260 Hz
   PT5B : 3.014 Hz --> too low
   SOM5B : 3.285 Hz
   PV5B : 2.567 Hz
   IT6 : 12.760 Hz --> too high
   CT6 : 6.682 Hz --> too high
   SOM6 : 3.638 Hz
   PV6 : 2.455 Hz
   TPO : 2.085 Hz
   TVL : 2.229 Hz
   S1 : 2.185 Hz
   S2 : 2.144 Hz
   cM1 : 2.210 Hz
   M2 : 2.152 Hz
   OC : 2.058 Hz
  Simulated time: 1.0 s; 16 workers
  Run time: 3248.00 s
Saving output as ../data/v27_manualTune/M1_v27_tune5.json  ...
Finished saving!
  Done; saving time = 5.08 s.

*** 6. Conn, longConn, subcellConn, 300x300 um, 5 syns/conn, full IT5A, PT5B, all reduced
  Done; cell creation time = 12.64 s.
  Done; cell connection time = 873.17 s.
  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 81554 (4.50 Hz)
   IT2 : 1.728 Hz
   SOM2 : 3.135 Hz
   PV2 : 2.631 Hz
   IT4 : 1.994 Hz
   IT5A : 10.510 Hz
   SOM5A : 3.327 Hz
   PV5A : 1.750 Hz
   IT5B : 8.113 Hz
   PT5B : 10.133 Hz
   SOM5B : 3.275 Hz
   PV5B : 1.899 Hz
   IT6 : 12.802 Hz
   CT6 : 6.966 Hz
   SOM6 : 3.657 Hz
   PV6 : 1.845 Hz
   TPO : 2.085 Hz
   TVL : 2.229 Hz
   S1 : 2.185 Hz
   S2 : 2.144 Hz
   cM1 : 2.210 Hz
   M2 : 2.152 Hz
   OC : 2.058 Hz
  Simulated time: 1.0 s; 32 workers
  Run time: 7257.56 s
Saving output as ../data/v27_manualTune/M1_v27_tune6.json  ...
Finished saving!
  Done; saving time = 7.06 s.

15 min setup
2h to run 10k cells (IT5A and PT5B HH_full) for 1 sec with 32 workers

*** 7. test
*** 8. 6. on comet
  Done; run time = 2512.52 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 12.93 s.

Analyzing...
  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 81950 (4.52 Hz)
   IT2 : 1.728 Hz
   SOM2 : 3.135 Hz
   PV2 : 2.631 Hz
   IT4 : 1.994 Hz
   IT5A : 10.727 Hz
   SOM5A : 3.327 Hz
   PV5A : 1.750 Hz
   IT5B : 8.114 Hz
   PT5B : 10.217 Hz
   SOM5B : 3.275 Hz
   PV5B : 1.901 Hz
   IT6 : 12.941 Hz
   CT6 : 6.941 Hz
   SOM6 : 3.657 Hz
   PV6 : 1.845 Hz
   TPO : 2.085 Hz
   TVL : 2.229 Hz
   S1 : 2.185 Hz
   S2 : 2.144 Hz
   cM1 : 2.210 Hz
   M2 : 2.152 Hz
   OC : 2.058 Hz
  Simulated time: 1.0 s; 48 workers
  Run time: 2512.52 s
Saving output as ../data/v27_manualTune/M1_v27_tune8.json  ...
Finished saving!
  Done; saving time = 2.12 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 26.84 s

Total time = 2904.22 s

*** 9. 6. but 10 secs
  Done; run time = 16269.44 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 4.48 s.

Analyzing...
  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 546883 (3.02 Hz)
   IT2 : 0.175 Hz
   SOM2 : 0.311 Hz
   PV2 : 0.246 Hz
   IT4 : 0.198 Hz
   IT5A : 17.636 Hz
   SOM5A : 0.327 Hz
   PV5A : 0.179 Hz
   IT5B : 4.901 Hz
   PT5B : 2.674 Hz
   SOM5B : 0.327 Hz
   PV5B : 0.193 Hz
   IT6 : 8.298 Hz
   CT6 : 3.248 Hz
   SOM6 : 0.367 Hz
   PV6 : 0.185 Hz
   TPO : 2.417 Hz
   TVL : 2.550 Hz
   S1 : 2.453 Hz
   S2 : 2.463 Hz
   cM1 : 2.570 Hz
   M2 : 2.424 Hz
   OC : 2.407 Hz
  Simulated time: 10.0 s; 96 workers
  Run time: 16269.44 s
Saving output as ../data/v27_manualTune/M1_v27_tune9.json  ...
Finished saving!
  Done; saving time = 4.88 s.
Plotting raster...
Plotting recorded cell traces ...
  Done; plotting time = 171.11 s

Total time = 16740.85 s

4.5 hours using 96 cores

*** shapePlots of syn dendritic distribution long -> PT
** V28_manualTune - check reproduce laptop, nsim, comet
*** Tune1 - 100x100 um, longconn, dendconn, no local
**** laptop
  Cells: 8230
  Connections: 0 (0.00 per cell)
  Spikes: 41494 (5.04 Hz)
   IT2 : 18.837 Hz
   SOM2 : 1.000 Hz
   PV2 : 0.917 Hz
   IT4 : 33.518 Hz
   IT5A : 44.814 Hz
   SOM5A : 1.000 Hz
   PV5A : 0.917 Hz
   IT5B : 44.429 Hz
   PT5B : 1.413 Hz
   SOM5B : 0.955 Hz
   PV5B : 0.933 Hz
   IT6 : 29.604 Hz
   CT6 : 17.648 Hz
   SOM6 : 1.000 Hz
   PV6 : 0.913 Hz
   TPO : 2.286 Hz
   TVL : 2.171 Hz
   S1 : 2.124 Hz
   S2 : 2.126 Hz
   cM1 : 2.223 Hz
   M2 : 2.243 Hz
   OC : 2.262 Hz
  Simulated time: 1.0 s; 4 workers
  Run time: 1125.02 s
**** zn
  Cells: 8230
  Connections: 0 (0.00 per cell)
  Spikes: 41494 (5.04 Hz)
   IT2 : 18.837 Hz
   SOM2 : 1.000 Hz
   PV2 : 0.917 Hz
   IT4 : 33.527 Hz
   IT5A : 44.814 Hz
   SOM5A : 1.000 Hz
   PV5A : 0.917 Hz
   IT5B : 44.421 Hz
   PT5B : 1.413 Hz
   SOM5B : 0.955 Hz
   PV5B : 0.933 Hz
   IT6 : 29.604 Hz
   CT6 : 17.648 Hz
   SOM6 : 1.000 Hz
   PV6 : 0.913 Hz
   TPO : 2.286 Hz
   TVL : 2.171 Hz
   S1 : 2.124 Hz
   S2 : 2.126 Hz
   cM1 : 2.223 Hz
   M2 : 2.243 Hz
   OC : 2.262 Hz
  Simulated time: 1.0 s; 32 workers
  Run time: 325.00 s
Saving output as ../data/v28_manualTune/M1_v28_tune1.json  ...
Finished saving!
  Done; saving time = 2.38 s.
**** comet
  Done; run time = 87.24 s; real-time ratio: 0.01.

Gathering data...
  Done; gather time = 0.78 s.

Analyzing...
  Cells: 8230
  Connections: 0 (0.00 per cell)
  Spikes: 41494 (5.04 Hz)
   IT2 : 18.840 Hz
   SOM2 : 1.000 Hz
   PV2 : 0.917 Hz
   IT4 : 33.518 Hz
   IT5A : 44.814 Hz
   SOM5A : 1.000 Hz
   PV5A : 0.917 Hz
   IT5B : 44.421 Hz
   PT5B : 1.413 Hz
   SOM5B : 0.955 Hz
   PV5B : 0.933 Hz
   IT6 : 29.604 Hz
   CT6 : 17.648 Hz
   SOM6 : 1.000 Hz
   PV6 : 0.913 Hz
   TPO : 2.286 Hz
   TVL : 2.171 Hz
   S1 : 2.124 Hz
   S2 : 2.126 Hz
   cM1 : 2.223 Hz
   M2 : 2.243 Hz
   OC : 2.262 Hz
  Simulated time: 1.0 s; 96 workers
  Run time: 87.24 s
Saving output as ../data/v28_manualTune/M1_v28_tune1.json  ...
Finished saving!
  Done; saving time = 1.25 s.
*** Tune2 - 300x300 um, longconn, dendconn, no local
**** laptop
**** zn
  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 78582 (4.34 Hz)
   IT2 : 1.524 Hz
   SOM2 : 3.000 Hz
   PV2 : 3.239 Hz
   IT4 : 2.007 Hz
   IT5A : 4.551 Hz
   SOM5A : 3.236 Hz
   PV5A : 3.402 Hz
   IT5B : 8.187 Hz
   PT5B : 6.761 Hz
   SOM5B : 3.245 Hz
   PV5B : 3.143 Hz
   IT6 : 16.399 Hz
   CT6 : 6.351 Hz
   SOM6 : 3.590 Hz
   PV6 : 1.812 Hz
   TPO : 2.085 Hz
   TVL : 2.229 Hz
   S1 : 2.185 Hz
   S2 : 2.144 Hz
   cM1 : 2.210 Hz
   M2 : 2.152 Hz
   OC : 2.058 Hz
  Simulated time: 1.0 s; 32 workers
  Run time: 7111.55 s
Saving output as ../data/v28_manualTune/v28_tune2.json  ...
Finished saving!
  Done; saving time = 3.83 s.
**** comet
Running...
0.1 s
0.2 s
0.3 s
0.4 s
0.5 s
0.6 s
0.7 s
0.8 s
0.9 s
  Done; run time = 1470.58 s; real-time ratio: 0.00.

Gathering data...
  Done; gather time = 4.54 s.

Analyzing...
  Cells: 18124
  Connections: 0 (0.00 per cell)
  Spikes: 81488 (4.50 Hz)
   IT2 : 1.523 Hz
   SOM2 : 3.000 Hz
   PV2 : 3.245 Hz
   IT4 : 2.006 Hz
   IT5A : 4.422 Hz
   SOM5A : 3.236 Hz
   PV5A : 3.500 Hz
   IT5B : 8.182 Hz
   PT5B : 6.589 Hz
   SOM5B : 3.245 Hz
   PV5B : 3.190 Hz
   IT6 : 18.686 Hz
   CT6 : 6.273 Hz
   SOM6 : 3.581 Hz
   PV6 : 1.798 Hz
   TPO : 2.085 Hz
   TVL : 2.229 Hz
   S1 : 2.185 Hz
   S2 : 2.144 Hz
   cM1 : 2.210 Hz
   M2 : 2.152 Hz
   OC : 2.058 Hz
  Simulated time: 1.0 s; 96 workers
  Run time: 1470.58 s
Saving output as ../data/v28_manualTune/v28_tune2.json  ...
Finished saving!
  Done; saving time = 2.12 s.
Plotting raster...
  Done; plotting time = 27.46 s

Total time = 1785.39 s

** v28_batch1 - 300x300, all conns; IT5A+PT5B full; tune E/I balance (FS bug)
*** BUGS - FS cell axon instead of dend had 2*L; FS+LTS no wieghtNorm
axon L=115*2
should have been: L=2*22
difference for IClamp 0.4nA:
114Hz (axon L*2)
117Hz (dend L*2)

0.2nA, 0.25nA:
36 Hz (axon L*2)
0 Hz (dend L*2)

0.25nA:
77 Hz (axon L*2)
0 Hz (dend L*2)

0.3nA:
94Hz (axon L*2)
44 Hz (dend L*2)

so could be major difference

- plus no weightNorm for PV+SOM !!

** v29_batch1 - fI curve for reduced models with shorter Bdend
*** error
using original L IT5B_reduced produced 75Hz for IClamp 0.45nA !! (0.4= 30hz, 0.5=40hz)
applied same method to adapt L -- 1/3 of layer = 290.25 = very close to original of 295 adend and 266 for bdend

** v29_batch2 - fI curve for reduced models with shorter Bdend; IT5B also adapted
all:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170306_181627.png][fig]]
E:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170306_184334.png][fig]]
I:
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170306_181642.png][fig]]

** v29_batch3 - weightNorm for reduced models with shorter Bdend; IT5B also adapted
** v29_batch4 - test weightNorm for reduced models with adapted Bdend
- almost perfect match for 0.1, 0.5 weight --> 0.1 and 0.5 mV soma EPSP
** v29_batch5 - weightNorm for PV+SOM cell
** v29_batch6 - test weightNorm for PV and SOM cells
- perfect match for 0.1, 0.5 weight --> 0.1 and 0.5 mV soma EPSP
** v29_batch7 - 300x300, all conns; IT5A+PT5B full; tune E/I balance (numCells bug)
*** BUG
numCells was <10k due to fixed layer boundaries
*** params?
cfg.EEGain = 1.0

cfg.EIGain = 1.0
cfg.IEGain = 1.0
cfg.IIGain = 1.0

## E->I gains
cfg.EPVGain = 1.2
cfg.ESOMGain = 0.8

## I->E gains
cfg.PVEGain = 1.0
cfg.SOMEGain = 0.8

## I->I gains
cfg.PVIGain = 1.0
cfg.SOMIGain = 1.0

option 1 (unfeasible):
- 7 variables; 5 states (0.8,0.9,1.0,1.1,1.2) = 5^7 = 78125 sims
- 4 sec sims = 6000 sec (100 mins) in 96 cores
- if can use 72*24 = 1728
- 78125 sim * 100 min/sim * 96 cores / 1728 cores = 434 027 mins

option 2:
- 4 sec sims
- EE, II, EPV, ESOM, PVE, SOME; 3 states (0.8, 1.0, 1.2) = 729
- 729 * 100 min/sim * 96 / 1728 = 4050 min = 67.5 hr

option 3:
- 3 sec
- EE, II, EPV, ESOM, PVE, SOME; 3 states (0.8, 1.0, 1.2) = 729
- 729 * 66.67 min/sim * 96 / 1728 = 2700 min = 45

*** final params
	params['EEGain'] = [0.8, 1.0, 1.2]
	params['EPVGain'] = [0.8, 1.0, 1.2]
	params['ESOMGain'] = [0.8, 1.0, 1.2]
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['IIGain'] = [0.8, 1.0, 1.2]

b.batchLabel = 'v28_batch1'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'
b.runCfg = {'type': 'hpc_slurm',
			'allocation': 'shs100',
			'walltime': '04:00:00',
			'nodes': 1,
			'coresPerNode': 24,
			'email': 'salvadordura@gmail.com',
			'folder': '/home/salvadord/m1/sim/',
			'script': 'init.py',
			'skip': True}

*** cores/job ?
better many-core short jobs, or fewer-core longer jobs

- fixed overhead = 310 sec
- run time 96 cores = 1470 sec
- total = 1780 s
- 4 jobs requires = 7120

- 24 cores= 1470*4 + 310 = 6190 sec (can run 4 jobs)  wrong!

- so better fewer cores and simultaneous

** v30_batch1 - 300x300, all conns; IT5A+PT5B full; tune E/I balance; fixed cellDensity (netstim, IClamp, IIGain bug)
- rates seem too high
- PT dep blockade - partly due to bug? NetStim1+IClamp was on! thats why other cells not being recorded
- IIGain not doing anything!? - nope! removing all redundant ones - rerun in v31_batch2

- examining rasters visually:
-- 000010 - ok except PV5B 112hz + SOM2 75hz

- something happens after 1 sec -- all sims have a change of activity across pops; IT6 very strongly affected, stops spiking
  for ~10-100 ms; maybe netstim? also IClamp!!

*** filtering
 Filtering based on: ['rates', 'I>E', 'E5>E6>E2', 'PV>SOM'] 2<=CT6<=20 and 5<=PV2<=50 and 5<=PV6<=50 and 5<=SOM5A<=40 and
4<=IT5A<=20 and 4<=IT5B<=20 and 4<=PT5B<=20 and 5<=PV5A<=50 and 5<=PV5B<=50 and 2<=IT6<=20 and 2<=IT4<=20 and 5<=SOM2<=40 and
2<=IT2<=15 and 5<=SOM5B<=40 and 5<=SOM6<=40 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and
SOM5B > IT5B and PV6 > IT6 and SOM6 > IT6 and (IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 >
IT2 and PV2 > IT2 and PV5A > SOM5A and PV5B > SOM5B and PV6 > SOM6 0

 Filtering based on: ['rates', 'I>E', 'E5>E6>E2'] 2<=CT6<=20 and 5<=PV2<=50 and 5<=PV6<=50 and 5<=SOM5A<=40 and 4<=IT5A<=20
and 4<=IT5B<=20 and 4<=PT5B<=20 and 5<=PV5A<=50 and 5<=PV5B<=50 and 2<=IT6<=20 and 2<=IT4<=20 and 5<=SOM2<=40 and 2<=IT2<=15
and 5<=SOM5B<=40 and 5<=SOM6<=40 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and SOM5B >
IT5B and PV6 > IT6 and SOM6 > IT6 and (IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 > IT2 0

 Filtering based on: ['rates', 'I>E'] 2<=CT6<=20 and 5<=PV2<=50 and 5<=PV6<=50 and 5<=SOM5A<=40 and 4<=IT5A<=20 and
4<=IT5B<=20 and 4<=PT5B<=20 and 5<=PV5A<=50 and 5<=PV5B<=50 and 2<=IT6<=20 and 2<=IT4<=20 and 5<=SOM2<=40 and 2<=IT2<=15 and
5<=SOM5B<=40 and 5<=SOM6<=40 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and SOM5B > IT5B
and PV6 > IT6 and SOM6 > IT6 0

 Filtering based on: ['rates'] 2<=CT6<=20 and 5<=PV2<=50 and 5<=PV6<=50 and 5<=SOM5A<=40 and 4<=IT5A<=20 and 4<=IT5B<=20 and
4<=PT5B<=20 and 5<=PV5A<=50 and 5<=PV5B<=50 and 2<=IT6<=20 and 2<=IT4<=20 and 5<=SOM2<=40 and 2<=IT2<=15 and 5<=SOM5B<=40 and
5<=SOM6<=40 0

 Filtering based on: ['I>E']
PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and SOM5B > IT5B and PV6 > IT6 and SOM6 > IT6
21

 Filtering based on: ['E5>E6>E2']
(IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 > IT2
37

 Filtering based on: ['PV>SOM']
PV2 > IT2 and PV5A > SOM5A and PV5B > SOM5B and PV6 > SOM6

*** candidates based on last 1 sec
EE, EPV, ESOM, PVE, SOME, II


[[file+sys:data/v30_batch1/v30_batch1_2_0_0_2_2_0_raster.png]]

[[file+sys:data/v30_batch1/v30_batch1_2_0_1_0_1_0_raster.png]]

[[file+sys:data/v30_batch1/v30_batch1_2_1_0_0_2_0_raster.png]] --> use this

[[file+sys:data/v30_batch1/v30_batch1_2_1_1_0_2_0_raster.png]]

** v31_batch1 - 300x300, all conns; IT5A+PT5B full; tune E/I balance; bkg rates [0,2]Hz (bug SOMEgain, PVEgain)

long rates = [0,2]

	params['EEGain'] = [0.8, 1.0, 1.2]
	#params['EPVGain'] = [0.8, 1.0, 1.2]  - fixed to 0.8
	#params['ESOMGain'] = [0.8, 1.0, 1.2] - fixed to 0.8
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['IIGain'] = [0.8, 1.0, 1.2]

	b = Batch(params=params)
	b.runCfg = {'type': 'hpc_slurm',
			'allocation': 'shs100',
			'walltime': '07:00:00',
			'nodes': 1,
			'coresPerNode': 24,
			'email': 'salvadordura@gmail.com',
			'folder': '/home/salvadord/m1/sim/',
			'script': 'init.py',
			'skip': True}
- lower spk threhsold

- lower long rates lead to higher rates -- maybe because less inh, or maybe because less dep blockade

*** trends
- II up -> E,I up
- SOMEGain - no change (fixed to 0.8)
- PVEGain - no change (fixed to 0.8)
- EE up -> E,I up




*** filtering results
 Filtering based on: ['rates', 'I>E', 'E5>E6>E2', 'PV>SOM'] 2<=CT6<=25 and 2<=PV2<=60 and 2<=PV6<=60 and 2<=SOM5A<=50 and
2<=IT5A<=25 and 2<=IT5B<=25 and 2<=PT5B<=25 and 2<=PV5A<=60 and 2<=PV5B<=60 and 2<=IT6<=25 and 2<=IT4<=25 and 2<=SOM2<=50 and
2<=IT2<=25 and 2<=SOM5B<=50 and 2<=SOM6<=50 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and
SOM5B > IT5B and PV6 > IT6 and SOM6 > IT6 and (IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 >
IT2 and PV2 > IT2 and PV5A > SOM5A and PV5B > SOM5B and PV6 > SOM6 0 0

 Filtering based on: ['rates', 'I>E', 'E5>E6>E2'] 2<=CT6<=25 and 2<=PV2<=60 and 2<=PV6<=60 and 2<=SOM5A<=50 and 2<=IT5A<=25
and 2<=IT5B<=25 and 2<=PT5B<=25 and 2<=PV5A<=60 and 2<=PV5B<=60 and 2<=IT6<=25 and 2<=IT4<=25 and 2<=SOM2<=50 and 2<=IT2<=25
and 2<=SOM5B<=50 and 2<=SOM6<=50 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and SOM5B >
IT5B and PV6 > IT6 and SOM6 > IT6 and (IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 > IT2 0 0

 Filtering based on: ['rates', 'I>E'] 2<=CT6<=25 and 2<=PV2<=60 and 2<=PV6<=60 and 2<=SOM5A<=50 and 2<=IT5A<=25 and
2<=IT5B<=25 and 2<=PT5B<=25 and 2<=PV5A<=60 and 2<=PV5B<=60 and 2<=IT6<=25 and 2<=IT4<=25 and 2<=SOM2<=50 and 2<=IT2<=25 and
2<=SOM5B<=50 and 2<=SOM6<=50 and PV2 > IT2 and SOM2 > IT2 and PV5A > IT5A and SOM5A > IT5A and PV5B > IT5B and SOM5B > IT5B
and PV6 > IT6 and SOM6 > IT6 0 0

 Filtering based on: ['rates', 'E5>E6>E2'] 2<=CT6<=25 and 2<=PV2<=60 and 2<=PV6<=60 and 2<=SOM5A<=50 and 2<=IT5A<=25 and
2<=IT5B<=25 and 2<=PT5B<=25 and 2<=PV5A<=60 and 2<=PV5B<=60 and 2<=IT6<=25 and 2<=IT4<=25 and 2<=SOM2<=50 and 2<=IT2<=25 and
2<=SOM5B<=50 and 2<=SOM6<=50 and (IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 > IT2 0 0

 Filtering based on: ['rates']
2<=CT6<=25 and 2<=PV2<=60 and 2<=PV6<=60 and 2<=SOM5A<=50 and 2<=IT5A<=25 and 2<=IT5B<=25 and 2<=PT5B<=25 and 2<=PV5A<=60 and 2<=PV5B<=60 and 2<=IT6<=25 and 2<=IT4<=25 and 2<=SOM2<=50 and 2<=IT2<=25 and 2<=SOM5B<=50 and 2<=SOM6<=50
0
0

 Filtering based on: ['E5>E6>E2']
(IT5A+IT5B+PT5B)/3 > (IT6+CT6)/2 and (IT6+CT6)/2 > IT2 and (IT5A+IT5B+PT5B)/3 > IT2
0
0

 Filtering based on: ['PV>SOM']
PV2 > IT2 and PV5A > SOM5A and PV5B > SOM5B and PV6 > SOM6
0
0

** v31_batch2 - IIGains [1.0,1.2]; EIGains = 1.0; bkg rates [0,5] (bug SOMEgain, PVEgain)
	params['EEGain'] = [0.8, 1.0, 1.2]
	#params['EPVGain'] = [0.8, 1.0, 1.2] - 1.0
	#params['ESOMGain'] = [0.8, 1.0, 1.2] - 1.0
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['IIGain'] = [1.0, 1.2]

only 54 sims in total

*** trends
- II up -> E,I generally up; but some E,I down
- SOMEGain - no change (fixed to 0.8)
- PVEGain - no change (fixed to 0.8)
- EE up -> E,I up

*** compare bkg rates (with v31_batch1)
- bkg [0,2] hz - higher L2/3,4,5A rates, but slightly lower L5B,6 rates

** v31_batch3 - Long range stim using v30_batch1_2_1_0_0_2_0 (bug SOMEgain, PVEgain)

** v31_batch4 - CANCELLED - Test EIGains; II=[1.0,1.2], EE = 1.2, PVE=0.8, SOME=1.2; bkg rates [0,5]
check what was missing from v30_batch1 and v31_batch2

	#params['EEGain'] = [0.8, 1.0, 1.2] - fixed to 1.2
	params['EPVGain'] = [0.8, 1.0, 1.2]
	params['ESOMGain'] = [0.8, 1.0, 1.2]
	#params['PVEGain'] = [0.8, 1.0, 1.2] - fixed to 0.8
	#params['SOMEGain'] = [0.8, 1.0, 1.2] - fixed to 1.2
	params['IIGain'] = [1.0, 1.2]

*** trends

** v31_batch5 - Test EIGains and IEGains with 1 sec sims, bkg rates [0,5]
- on comet

	#params['EEGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['EPVGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['ESOMGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['PVIGain'] = [0.8, 1.0, 1.2]
	params['SOMIGain'] = [0.8, 1.0, 1.2]

** v31_batch6 - Test EIGains and IEGains with 1 sec sims, bkg rates [0,2]
- on ma
	#params['EEGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['EPVGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['ESOMGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['PVIGain'] = [0.8, 1.0, 1.2]
	params['SOMIGain'] = [0.8, 1.0, 1.2]



*** patterns
-SOMIGain up - rates up
- PVIGain up - 0 low, 1,2 - high similar

*** selected
- 0_1_0_0 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170316_202659.png][fig]]

** v31_batch6b - Replicated v31_batch_0_1_0_0 ok in ma (single sim)

** v31_tune5 - Local conn convergence
run on zn

** v31_tune6 - long conn convergence
** v31_tune7 - EPSPs
** v31_batch7 - Long range stim using v31_batch6_0_1_0_0 (TP, TVL, S2, M2) (!= v31_batch6_0_1_0_0)
	params['PVEGain'] = [0.8, 1.0, 1.2] - 0.8
	params['SOMEGain'] = [0.8, 1.0, 1.2] - 1.0
	params['PVIGain'] = [0.8, 1.0, 1.2] - 0.8
	params['SOMIGain'] = [0.8, 1.0, 1.2] - 0.8

- 2 sec - use 2x cores = 2x 24 = 48 = 6*8
- can run 4 at the same time: [TPO, TVL, S2, M2]

*** results different to orig! why?
- _cfg.json equivalent
- bkg noise / spk times equivalent
- num nodes?? 24 vs 48 -- rerunning v31_batch6 (b) using 48 cores

** v31_batch8 - Long range stim using v31_batch6_0_1_0_0 (S1) (!= v31_batch6_0_1_0_0) - vecstim bug
use 48 cores

- results different - reruninng v31_batch8(b) using 24 cores

** v31_batch9 - Same as v31_batch7 but different batch structure (!= v31_batch6_0_1_0_0) - vecstim bug

- just changed in cfg.py:
duration = 2.0
addPulses = 1

def EIbalance():
	params = specs.ODict()
	#params['EEGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['EPVGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['ESOMGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	params['PVEGain'] = [0.8]#, 1.0, 1.2]
	params['SOMEGain'] = [1.0]#[0.8, 1.0, 1.2]
	params['PVIGain'] = [0.8]#, 1.0, 1.2]
	params['SOMIGain'] = [0.8]#[0.8, 1.0, 1.2]
	params[('pulse',0)] = ['TPO', 'TVL', 'S2', 'M2']

	b = Batch(params=params)

	b.runCfg = {'type': 'hpc_torque',
	 			'script': 'init.py',
	 			'nodes': 4,
	 			'ppn': 8,
	 			'walltime': "8:00:00",
	 			'queueName': 'longerq',
	 			'sleepInterval': 5,
	 			'skip': True}

- check if difference is due to increase duration or addPulse=1
- v31_batch10 - set addPulses=0

** v31_batch10 - Trying to replicate v31_batch6_0_1_0_0 but with duration=2 (!=v31_batch6_0_1_0_0) - vecstim bug
- 1st sec different
- compare with v31_batch6b -- only diffs in cfg and netParams is duration (and output spk times)
- ah maybe vecstim spks different if 1 vs 2 sec!? - YESSS!!! - fix!

** v31_batch11 - Trying to replicate v31_batch6_0_1_0_0 but with duration=1 - vecstim bug
- this should be identical to v31_batch_6b!

** v31_batch12 - EIbalance, 2 secs, vecstim fixed, 0-2 hz


	params['EEGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['EPVGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	#params['ESOMGain'] = [0.8, 1.0, 1.2]  # fixed to 1.0
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['PVIGain'] = [0.8, 1.0, 1.2]
	params['SOMIGain'] = [0.8, 1.0, 1.2]


		b.runCfg = {'type': 'hpc_slurm',
			'allocation': 'shs100',
			'walltime': '04:00:00',
			'nodes': 2,
			'coresPerNode': 24,
			'email': 'salvadordura@gmail.com',
			'folder': '/home/salvadord/m1/sim/',
			'script': 'init.py',
			'skip': True}

- need to increase E-I in L6 ??
- tune long-range weight?
- tune E->I ?
*** selected
v31_batch12_2_2_2_2_2_raster

v31_batch12_2_0_2_1_2_raster

*** plotting figs
In [2]: import json
   ...: import pickle
   ...: import numpy as np
   ...: from pylab import *
   ...: from itertools import product
   ...: import pandas as pd
   ...: from pprint import pprint
   ...:
   ...: from netpyne import specs


In [19]:     import matplotlib.pyplot as plt
    ...:     from netpyne import specs,sim
    ...:     cfg = specs.SimConfig(data['simConfig'])
    ...:     cfg.createNEURONObj = False
    ...:
    ...:     sim.initialize()  # create network object and set cfg and net params
    ...:     sim.loadAll('', data=data)
    ...:     sim.setSimCfg(cfg)

In [19]:         sim.net.createPops()
    ...:         sim.net.createCells()
    ...:         sim.gatherData()

sim.allSimData = data['simData']

In [18]:         figh = sim.analysis.plotRaster(include=range(10171), timeRange=[200,2000], labels='overlay', popRates=True, orderInverse=True, lw=0.
    ...: 3, marker='|', showFig=False, saveFig=False)
    ...:         ax = plt.gca()
    ...:         plt.savefig(cfg.filename+'_raster.png', dpi=1000)
    ...:
Plotting raster...

figh = sim.analysis.plotSpikeHist(include=['all', 'IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6'], yaxis='count', binSize=10, timeRange=[200,2000], showFig=False, saveFig=1)

** v31_batch13 - EIbalance, 2 secs, vecstim fixed, 0-5 hz
*** selected

** v31_batch14 - Attempt to test long-range stim with v31_batch12_2_2_2_2_2 and _2_0_2_1_2 (TPO, TVL, S2, M2)
- on ma

bugs in 1st attempt:
- set all gains to 1.2 -- including EPV and ESOM
- stim start at 1.0sec instead of 2.0sec


	params[('pulse',0)] = ['TPO', 'TVL', 'S2', 'M2']
	#params[('pulse',2)] = [1100, 1200]
	#params[('pulse',3)] = [30, 40]

	params['EEGain'] = 	[1.2, 1.2]  # fixed
	params['EPVGain'] = 	[1.0, 1.0]  # fixed
	params['ESOMGain'] = 	[1.0, 1.0]  # fixed
	params['PVEGain'] = 	[0.8, 1.2]  # grouped
	params['SOMEGain'] = 	[1.2, 1.2]  # fixed
	params['PVIGain'] = 	[1.0, 1.2]  # grouped
	params['SOMIGain'] = 	[1.2, 1.2]  # fixed

** v31_batch15 - Test long-range stim with v31_batch12_2_0_2_1_2 (None, TPO, TVL, S1, S2, cM1, M2, OC)

run for 4 sec

	params[('pulse',0)] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'cM1', 'M2', 'OC']
	#params[('pulse',2)] = [2100, 2200]
	#params[('pulse',3)] = [30, 40]

set these in cfg:
	params['EEGain'] = 	[1.2]  # fixed
	params['EPVGain'] = 	[1.0]  # fixed
	params['ESOMGain'] = 	[1.0]  # fixed
	params['PVEGain'] = 	[0.8]  # grouped
	params['SOMEGain'] = 	[1.2]  # fixed
	params['PVIGain'] = 	[1.0]  # grouped
	params['SOMIGain'] = 	[1.2]  # fixed

*** spikes being detected but not visible in voltage trace -- instabilities?
- test single cell with higher resolution

** v31_batch16 - Test long-range stim with v31_batch12_2_0_2_1_2 (None) - check for instabilities
** v32_batch1 - EIbalance, 2 secs, 0-2hz

	params['EEGain'] = [0.8, 1.0, 1.2]
	params['EIGain'] = [0.8, 1.0, 1.2]
	params['IEGain'] = [0.8, 1.0, 1.2]
	params['IIGain'] = [0.8, 1.0, 1.2]


- PT depol blockade
- IT6, CT6 too high

possible solutions:
- increase I->E gain L5 and L6
- increase w in conn.py for L5/6

** v33_batch1 - EIbalance, 2 sec, 0-2hz, I->layer weights
on ma

	params['IIGain'] = [0.8, 1.0]

	params[('Iweights',1)] = [1.5, 2.0]
	params[('Iweights',2)] = [1.5, 2.0]

- justified because weightNorm wasn't adjusted for GABA syns, so could be off

- important to reduce IIGain while increasing Iweight - but only for L5 and L6
- if reduce IIGain then L234 too low activity?
- maybe separate?

eg. Iweight1,2 = 2.0
IIGain = 0.8

L2 IE=1.0, II=0.8
L5 IE=2.0, II=1.6
L6 IE=2.0, II=1.6

** v33_batch2 - EIbalance, 2 sec, 0-2hz, I->layer weights
on comet

	params['IEGain'] = [0.5, 1.0, 1.5]
	params['IIGain'] = [0.5, 1.0, 1.5]

	params[('Iweights',1)] = [1.0, 1.5, 2.0]
	params[('Iweights',2)] = [1.0, 1.5, 2.0]

- only that get close are IEGain=1.5, IIGain=0.5, Iweights1+2= 2.0

** v34_batch1 - EIbalance, 2 sec, 0-2hz, I->E/I layer weights
on ma

	params[('IEweights',1)] = [1.5, 2.0, 2.5]
	params[('IEweights',2)] = [1.5, 2.0, 2.5]

- IT6,CT6 also excite SOM5B,PV5B, so when increase L6 I->E, also decreasing L5;
- I->E and E->I, recurrent, so need to compensate by increasing E->I
- PV5A/SOM5A -> IT4+IT5A+IT5B

** v34_batch2 - EIbalance, 2 sec, 0-2hz, I->E/I layer weights
on comet
	# L2/3+4
	params[('IEweights',0)] = [0.8, 1.0, 1.2]
	params[('IIweights',0)] = [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [1.5, 2.0, 2.5]
	params[('IIweights',1)] = [0.5, 1.0, 1.5]
	# L6
	params[('IEweights',2)] = [1.5, 2.0, 2.5]
	params[('IIweights',2)] = [0.5, 1.0, 1.5]

- all with depol blockade in PT5B

- decent IT2 + IT6:
1_2_0_2_0_0
2_2_0_2_0_0

** v34_batch3 - EIbalance, 2 sec, 0-2hz, I->E/PT/I layer weights
on ma

	params['IIGain'] = [0.5, 1.0]
	# PT
	params['IPTGain'] = [2.0,3.0]
	# L6
	params[('IEweights',2)] = [2.0, 3.0]

- for CT6/IT6 - weight of 2.0 ~ok
- for PT5B need even higher IPTGain or lowe IIGain
- L2/3+4 need a boost

** v34_batch4 - EIbalance, 2 sec, 0-2hz, I->E/PT/I layer weights
on comet
	# L2/3+4
	params[('IEweights',0)] = [0.75, 1.0]  0
	params[('IIweights',0)] = [1.0, 1.25] 1
	# L5
	params['IPTGain'] = [3.0, 4.0]  1
	params[('IIweights',1)] = [0.5, 0.75]  0
	# L6
	params[('IEweights',2)] = [2.0, 3.0] 0
	params[('IIweights',2)] = [0.5, 0.75] 1

** v34_batch5 - EIbalance, 2 sec, 0-2hz, I->E/PT/I layer weights
on ma

params['EEGain'] = [0.75, 1.0, 1.25]
params['EIGain'] = [0.75, 1.0, 1.25]

	# L2/3+4
	params[('IEweights',0)] = [0.75]
	params[('IIweights',0)] = [1.25]
	# L5
	params['IPTGain'] = [4.0]
	params[('IIweights',1)] = [0.5]
	# L6
	params[('IEweights',2)] = [2.0]
	params[('IIweights',2)] = [0.75]

** v34_batch6 - EIbalance, 2 sec, 0-2hz, I->E/PT/I layer weights
on ma

params['EEGain'] = [0.75, 1.0, 1.25] - 1.0
params['EIGain'] = [0.75, 1.0, 1.25] - 1.0

	# L2/3+4
	params[('IEweights',0)] = [1.0]
	params[('IIweights',0)] = [2.0, 3.0]
	# L5
	params['IPTGain'] = [6.0, 8.0]
	params[('IIweights',1)] = [0.5]
	# L6
	params[('IEweights',2)] = [2.0]
	params[('IIweights',2)] = [0.5]

** v34_batch7 - EIbalance, 2 sec, 0-2hz, I->E/PT/I layer weights

	# EE, EI
	params['EEGain'] = [1.0, 1.25]
	params['EIGain'] = [1.0]

	# L2/3+4
	params[('IEweights',0)] = [0.75]
	params[('IIweights',0)] = [1.25]
	# L5
	params['IPTGain'] = [10.0, 12.5, 15.0]
	params[('IIweights',1)] = [0.5, 0.75]
	# L6
	params[('IEweights',2)] = [2.0]
	params[('IIweights',2)] = [0.75]

** v34_tune1 - Conn analysis - PT depol blockade

*** stim params cfg_cell
				## numStims, pop, cellRule, secList, allSegs,  loc, synMech, 				start, interval, noise, number, weight, delay
cfg.GroupNetStimEPT = 	[500,'PT5B', 'PT5B_full', 	'spiny',	True,  ['AMPA','NMDA'], 		50, 1000/2.0, 0.5, 10, 0.1, 1]
cfg.GroupNetStimSOMPT = [10,'PT5B', 'PT5B_full', 	'perisom', 	True,  ['GABAASlow','GABAB'], 	50, 1000/2.0, 0.5, 10, 0.1, 1]
cfg.GroupNetStimPVPT = 	[10,'PT5B', 'PT5B_full', 	'perisom', 	True,  ['GABAA'], 				50, 1000/2.0, 0.5, 10, 0.1, 1]

cfg.GroupNetStimEIT = 	[500,'IT5A', 'IT5A_full', 	'spiny', 	True,  ['AMPA','NMDA'], 		50, 1000/2.0, 0.5, 10, 0.1, 1]
cfg.GroupNetStimSOMIT = [10,'IT5A', 'IT5A_full', 	'perisom', 	True,  ['GABAASlow','GABAB'], 	50, 1000/2.0, 0.5, 10, 0.1, 1]
cfg.GroupNetStimPVIT = 	[10,'IT5A', 'IT5A_full', 	'perisom', 	True,  ['GABAA'], 				50, 1000/2.0, 0.5, 10, 0.1, 1]

*** calls to plot funcs
fig=sim.analysis.plotShape(includePre=['all'], includePost= ['IT5A'], cvar='numSyns', saveFig=True, showFig=True, iv=0, includeAxon=False)

In [2]: sim.analysis.plotConn(includePre = ['all'], includePost = ['IT5A', 'PT5B'], feature = 'strength', orderBy = 'gid', figSize = (10,10), groupBy = 'pop',graphType = 'bar', synOrConn = 'syn', synMech = 'GABAA', saveData = None, saveFig = 1, showFig = True)
Plotting connectivity matrix...
Out[2]: <matplotlib.figure.Figure at 0x11af19690>

In [3]: sim.analysis.plotConn(includePre = ['all'], includePost = ['IT5A', 'PT5B'], feature = 'numConns', orderBy = 'gid', figSize = (10,10), gro
   ...: upBy = 'pop',graphType = 'bar', synOrConn = 'conn', synMech = None, saveData = None, saveFig = 1, showFig = True)
Plotting connectivity matrix...
Out[3]: <matplotlib.figure.Figure at 0x11a15e1d0>

In [4]: sim.analysis.plotConn(includePre = ['all'], includePost = ['IT5A', 'PT5B'], feature = 'convergence', orderBy = 'gid', figSize = (10,10),
   ...: groupBy = 'pop',graphType = 'bar', synOrConn = 'conn', synMech = None, saveData = None, saveFig = 1, showFig = True)


In [6]: fig=sim.analysis.plotShape(includePre=['GroupNetStimEIT'], includePost= ['IT5A'], cvar='numSyns', saveFig=True, showFig=True, iv=0, inclu
   ...: deAxon=False)

In [7]: fig=sim.analysis.plotShape(includePre=['GroupNetStimPVIT', 'GroupNetStimSOMIT'], includePost= ['IT5A'], cvar='numSyns', saveFig=True, sho
   ...: wFig=True, iv=0, includeAxon=False)

In [8]: fig=sim.analysis.plotShape(includePre=['GroupNetStimEPT'], includePost= ['PT5B'], cvar='numSyns', saveFig=True, showFig=True, iv=0, inclu
   ...: deAxon=False)

In [9]: fig=sim.analysis.plotShape(includePre=['GroupNetStimPVPT', 'GroupNetStimSOMPT'], includePost= ['PT5B'], cvar='numSyns', saveFig=True, sho
   ...: wFig=True, iv=0, includeAxon=False)

*** individual tune sims cfg_cell
weight=0.1, E seclist=spiny AMPA+NMDA, I seclist=perisom GABAA or GABAAslow+GABAB, 2 Hz, noise=0.5, delay=1

tune4 - 500 E + 200 I = 0 spks
tune5 - 4000 E + 2000 I = 0 spks
tune6 - 4000 E + 200 I = 1 spk in IT5A


converted to pop instead of stim
weight=0.1, 1 Hz, noise=1.0, delay=1

tune7 - 400 E + 200 I, all same syn = PT 3spks, IT 0 spk
tune8 - 400 E + 100 I, unif dist = no spks
tune9 - 4000 E + 1000 I, unif = PT -70mV, IT 11 spks

tune10 - PT shape plot
tune11 - reduced PT

tune12 - 6000 E + 1000 I, unif = PT -70mV, IT 11 spks = PT 2 spks, IT 29 spks


*** issues to check:
- uniform should show all segs with same num of syns, but there is wide range
- perisom of PT includes 1 in apical and 1 in distal basal
- answer: distributeSynsUniformly depends of length not num segments!

*** checking conn on zn - cfg (m1 net)
sim.analysis.plotConn(includePre = ['all'], includePost = ['IT5A', 'PT5B'], feature = 'strength', orderBy = 'gid', figSize= (10,10), groupBy = 'pop',graphType = 'bar', synOrConn = 'syn', synMech = 'AMPA', saveData = None, saveFig = 1, showFig = True)

- strength bar shows ~9000 strength for PT vs ~10 for IT -- [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170403_225123.png][fig]]

sim.analysis.plotConn(includePre = ['all'], includePost = ['IT5A', 'PT5B'], feature = 'strength', orderBy = 'gid', fig= (10,10), groupBy = 'pop',graphType = 'bar', synOrConn = 'syn', synMech = 'GABAA', saveData = None, saveFig = 1, showFig = True)



- checking conns in terminal

In [3]: pt=next(c for c in sim.net.cells if c.tags['cellType']=='PT')

In [4]: pt
Out[4]: <netpyne.cell.CompartCell at 0x7f7e342da290>

In [5]: len(pt.conns)
Out[5]: 11500

In [7]: it=next(c for c in sim.net.cells if c.tags['popLabel']=='IT5A')

In [8]: it
Out[8]: <netpyne.cell.CompartCell at 0x7f7e577826d0>

In [9]: len(it.conns)
Out[9]: 7850



In [10]: ptw = sum([c.weight for c in pt.conns])

In [11]: ptw
Out[11]: 48.713442775822834

In [12]: itw = sum([c.weight for c in it.conns])

In [13]: itw
Out[13]: 0.80970082009520716

In [18]: ptwm
Out[18]: 0.00423595154572428

In [19]: itwm = mean([c.weight for c in it.conns])

In [20]: itwm
Out[20]: 0.00010314660128601427


In [32]: ptwnorm = mean([mean(s['weightNorm']) for s in pt.secs.values() if not isinstance(s['weightNorm'],dict)])

In [33]: ptwnorm
Out[33]: 0.011376747957466732

In [34]: itwnorm = mean([mean(s['weightNorm']) for s in it.secs.values() if not isinstance(s['weightNorm'],dict)])

In [35]: itwnorm
Out[35]: 0.00081354807333677099


In [57]: s(includePre=['M2'],includePost=[('PT5B',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[57]: <matplotlib.figure.Figure at 0x7f751531bed0>

In [58]: s(includePre=['OC'],includePost=[('PT5B',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[58]: <matplotlib.figure.Figure at 0x7f751430f590>
         s(includePre=['IT2'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[59]: <matplotlib.figure.Figure at 0x7f7512395fd0>

In [60]: s(includePre=['IT4'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[60]: <matplotlib.figure.Figure at 0x7f751235b410>

In [61]: s(includePre=['IT5A'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[61]: <matplotlib.figure.Figure at 0x7f7511c700d0>

In [62]: s(includePre=['IT5B'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[62]: <matplotlib.figure.Figure at 0x7f751150f710>

In [63]: s(includePre=['PT5B'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[63]: <matplotlib.figure.Figure at 0x7f7510e24590>

In [64]: s(includePre=['IT2'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[64]: <matplotlib.figure.Figure at 0x7f751072a510>

In [65]: s(includePre=['IT6'],includePost=[('PT5B',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[65]: <matplotlib.figure.Figure at 0x7f750ffbf4d0>

In [66]: s(includePre=['CT6'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[66]: <matplotlib.figure.Figure at 0x7f750f8c8510>

In [67]: s(includePre=['TVL'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)
Out[67]: <matplotlib.figure.Figure at 0x7f750f2e0050>

In [68]: s(includePre=['TPO'],includePost=[('IT5A',100)],cvar='numSyns',saveFig=1,showFig=0,includeAxon=0)

- some subconn rules wrong! lead to all syns in same segment

*** comparing to conns of cfg_cell (controlled inputs)
In [1]: pt=next(c for c in sim.net.cells if c.tags['cellType']=='PT')

In [2]: len(pt.conns)
Out[2]: 13500

In [3]: from pylab import mean

In [4]: ptw = mean([c.weight for c in pt.conns])

In [5]: ptw
Out[5]: 7.4744913210576496e-05

In [6]:  ptwnorm = mean([mean(s['weightNorm']) for s in pt.secs.values() if not isinstance(s['weightNorm'],dict)])

In [7]: ptwnorm
Out[7]: 0.011376747957466732

In [8]: it=next(c for c in sim.net.cells if c.tags['popLabel']=='IT5A')

In [9]: len(it.conns)
Out[9]: 13500

In [10]: itwm = mean([c.weight for c in it.conns])

In [11]: itwm
Out[11]: 6.9583057477231458e-05

In [12]: itwnorm = mean([mean(s['weightNorm']) for s in it.secs.values() if not isinstance(s['weightNorm'],dict)])

In [13]: itwnorm
Out[13]: 0.00081354807333677099

- Note here similar mean weights, whereas in real net huge difference
-- location of syns / weightNorm ??

- numConns to PT5B=~5.5M, to IT5A=2.2M
- numCells PT5B=1155, IT5A=636
- cons/cell PT5B= 4761, IT5A=3459


In [79]: ptw = mean([c.weight for c in pt.conns])
Out[80]: 0.00423595154572428

In [84]: mean([c.weight for c in it.conns])
Out[84]: 0.00010314660128601427


In [81]: itws = sum([c.weight for c in it.conns])
Out[82]: 0.80970082009520716

In [83]: sum([c.weight for c in pt.conns])
Out[83]: 48.713442775822834


In [86]: mean([c.weight for c in it.conns if c.sec.startswith('dend')])
Out[86]: 9.9383067687941102e-05

In [87]: mean([c.weight for c in pt.conns if c.sec.startswith('dend')])
Out[87]: 0.0040083854245262307

In [88]: mean([mean(s['weightNorm']) for s in pt.secs.values() if not isinstance(s['weightNorm'],dict)])
Out[88]: 0.011376747957466732

In [89]: mean([mean(s['weightNorm']) for s in it.secs.values() if not isinstance(s['weightNorm'],dict)])
Out[89]: 0.00081354807333677099

In [90]: sim.net.params.cellParams.IT5A_full.secs.dend_1.weightNorm
Out[90]: [0.00067116292126642718]

In [91]: sim.net.params.cellParams.PT5B_full.secs.dend_1.weightNorm
Out[91]: [0.00069749222289998002]

** v35_batch1 - EIbalance, 2 sec, 0-2Hz
on ma
	params['IEGain'] = [0.8, 1.0]
	params['IIGain'] = [0.8, 1.0]

** v35_tune1 - IIGain=0.8 (added missing subconn rules)
on zn and local

tune2 - wnorm max=10, syns=spiny: PT5B=2 hz
tune3 - wnorm max=10, syns=tuft: PT5B=0 hz
tune4 - wnorm max=1000, syns=spiny: PT5B=2 hz
tune5 - wnorm max=1000, syns=tuft: PT5B=0 hz
tune6 - wnorm max=1000, syns=tuft, no inh: PT5B=0 hz

** v36_tune1 - IIGain=0.8 (added weightNorm threshold)

- removed depol blockade!
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170410_130044.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170410_130053.png][fig]]

** v36_batch1 - IE / IE balance, per layer, with PT weighNorm threshold=10
on comet
	params[('IEweights',0)] = [0.75, 1.0, 1.25]
	params[('IIweights',0)] = [0.75, 1.0, 1.25]
	# L5
	params[('IEweights',1)] = [0.75, 1.0, 1.25]
	params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# L6
	params[('IEweights',2)] = [0.75, 1.0, 1.25]
	params[('IIweights',2)] = [0.75, 1.0, 1.25]


disaster! waste!
all with IT2,IT4,IT5A,IT5B ~0.0
PT5B> 20Hz

** v36_batch2 - IE / II balance, globally, with PT weighNorm threshold=10
on ma

params['IEGain'] = [0.5, 0.75, 1.0, 1.25, 1.5]
params['IIGain'] = [0.5, 0.75, 1.0, 1.25, 1.5]

- PT requires high EIGain, whereas rest

*** some good looking raster - but bad PT trac
0_1 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170411_204835.png][fig]]
0_2 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170411_204851.png][fig]]
0_3 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170411_204956.png][fig]]
0_4 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170411_205012.png][fig]]

*** good looking PT traces - but bad raster
4_0 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170417_204021.png][fig]]
4_1 -

** v36_batch3 - IE / II balance, per layer, with PT weighNorm threshold=10

	params[('IEweights',0)] = [0.25, 0.5]
	params[('IIweights',0)] = [0.75, 1.0, 1.25]
	# L5
	params[('IEweights',1)] = [0.25, 0.5]
	params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# L6
	params[('IEweights',2)] = [0.25, 0.5]
	params[('IIweights',2)] = [0.75, 1.0, 1.25]

 PT dep block
- run sim with max PT weightNorm 1,.., 10

** v37_batch1 - PT weightNorm threshold = 5
ma
	params['IEGain'] = [0.5]
	params['IIGain'] = [0.75]
	params['IPTGain'] = [3.0] (1.5 = 0.5 * 3.0)
	params['weightNormThreshold'] = [2,5,10]

** v37_manualTune - IE balance with netClamp
*** tune1 -  IE balance, with variable PT weightNorm threshold
zn

	params['IEGain'] = [0.5]
	params['IIGain'] = [0.75]
	params['IPTGain'] = [5.0] (2.5 = 0.5 * 5.0)
	params['weightNormThreshold'] = [10]

*** tune2 -

*** tune6 - PT netclamp for v37_batch2 0020
  Cells: 763
  Connections: 762 (1.00 per cell)
  Synaptic contacts: 7205 (9.44 per cell)
  Spikes: 14729 (9.65 Hz)

- PV and SOM inhibit each other
- only time no depol block is when PV high enough - 500-1000 ms
- peaks of block depol due to IT5B and PT5B - presumably will also lower if higher Inh

*** tune7 - PV5B 10Hz
- less depol block
*** tune8 - PV5B+PV5A 20Hz
- less depbloc
*** tune9 - PV5B+PV5A+SOM5A+SOM5B 20Hz
- less depblock - but same 2 peak depblock regions
*** tune10 - PV5B+PV5A+SOM5A+SOM5B 30Hz
- less depblock - but same 2 peak depblock regions
*** tune11 - PV5B+PV5A+SOM5A+SOM5B 40Hz
- depblock only remaining in 2 initial high zones; no spks elsewhere
*** tune12 - PV5B+PV5A+SOM5A+SOM5B 50Hz
practically normal spks

** v37_batch2 -  IE balance, with variable PT weightNorm threshold
comet
	params['IEGain'] = [0.25, 0.5, 0.75]
	params['IIGain'] = [0.75]
	params['IPTGain'] = [3.0, 4.0, 5.0, 6.0]
	params['weightNormThreshold'] = [2.0, 3.0, 4.0]

*** notes
- even with weightNorm thresh at 2.0, depol blockade happens periodically
- seems like PT either few spikes+subthresh or quickly goes into depol block
- no intermediate regime of operation

- check again if get depol blockade with single cell stims
- test cell individually -- reproduce all incoming spikes:
-- check conns of cell: sec, loc, preGid, weight
-- check spk times of preGid cells
-- for each conn/syn, create vecStim with spike times

- choose 1 to run long range stim inputs, and generate conns - 0020 (best looking and filter.py result; but dep block)

*** results
0000,0001, -
0010,0011,0012
0020,0021,0022
0030,0031,0032 - reasonable rates, nice oscillations, PT depol block

0002 - only PT5B (24hz) and IT6 spking (+ ihn cells)

1000,1001,1002
1010,1011,1012
1020,1021,1022
1030,1031,1032 -  higher IT rates (specially L6), higher freq osc, PT initial burst or some osc, fewer depol block

2000,2001,2002
2010,2011,2012
2020,2021,2022
2030,2031,2032 -  very low rates upper layer IT, high rate L6, higher freq osc, PT initial burst or few osc, no depol block

- one option would be to use IEGain=0.25 but increase further IPTgain

** v37_batch3 - Long stim with 0020 from v37_batch2
comet
	IEGain = 0.25
	IIGain = 0.75
	IPTGain = 5.0
	weightNormThreshold=2.0

params[('pulse',0)] = ['None', 'TPO', 'TVL',  'S2', 'M2']

** v38_batch1 - SOM<->PV gains (bug)

   cfg.py
	params['IEGain'] = [0.25, 0.5, 0.75] -> 0.25
	params['IIGain'] = [0.75]  -> None
	params['PVPVGain'] = [0.1, 0.25, 0.5] -> 0.75
	params['SOMSOMGain'] = [0.1, 0.25, 0.5] -> 0.75
	params['IPTGain'] = [3.0, 4.0, 5.0, 6.0] -> 0.6
	params['weightNormThreshold'] = [2.0, 3.0, 4.0] -> 0.2

batch.py
	params['SOMPVGain'] = [0.1, 0.25, 0.5]
	params['PVSOMGain'] = [0.1, 0.25, 0.5]

- maybe reduce overall exp decay func -> 0.5*exp(-d/lambda) ? (actually hass paper pcons very high - 0.6)

- depol blocakde in PT5B and IT5A

check why bug?? IIGain gets set first and so is not None!?

** v38_manualTune
   cfg.py
	params['IEGain'] = [0.25, 0.5, 0.75] -> 0.25
	params['IIGain'] = [0.75]  -> None
	params['PVPVGain'] = [0.1, 0.25, 0.5] -> 0.75
	params['SOMSOMGain'] = [0.1, 0.25, 0.5] -> 0.75
	params['IPTGain'] = [3.0, 4.0, 5.0, 6.0] -> 0.6
	params['weightNormThreshold'] = [2.0, 3.0, 4.0] -> 0.2

	params['SOMPVGain'] = 0.25 (instead of 0.75)
	params['PVSOMGain'] = 0.25 (instead of 0.75)

*** tune1 - increased PVSOM, SOMPV gains
- compared to v37_batch1 0030:
L2: increased PV2 and SOM2 -> slightly higher IT2
-- why? higher inh -> lower IT2 but inputs from IT4,5A,5B,6 -- so compensated by Exc inhs?
-- maybe also depol blockade? - YES!

L4: lower rate
-- why? lower IT5A, higher SOM5A; although lower PV5A

L5: much higer SOM5A
-- why? less PV5A, more IT5B, PT5B, IT6,CT6
lower PV5A -
-- why?? - depol blockade!!

lower IT5A (continuos vs bursts) - depol blockade!!
higher IT5B (cont vs burst) - partly because depol block
higher PT5B (cont vs burst) - partly because more depol block

SOM5A/B higher but PV5A/B lower, why??
-- SOM strong input from L2 E but not so much from L5 E; PV input reduced
-- PV strong input from L4 and L5 but not from L2; higher L5, but in theory lowe SOM (although overall more?); maybe depol
too? YES depol block!!!


L6: much higher IT6 and CT6
why?
slightly higher IT5B but also much higher SOM6 and PV6 which should reduce rate!

*** tune2 - rerun to check if other cells also dep block
depol blocks:
- IT2 (partly)
- IT5A
- PT5B (partly)
- PV5A
- PV5B
- CT6

very high rate:
- PV2
- SOM2
- IT5B
- SOM5A
- SOM5B
- PV6
- SOM6

reasonable:
IT4
IT6

*** tune3 - check depol blockades in v37_batch2 2011
in zn

	params['IEGain'] =  0.75
	params['IIGain'] = 0.75
	params['IPTGain'] = 4.0
	params['weightNormThreshold'] = 3.0

- NO DEPOL BLOCKADE!

** v38_batch2 - IE, II balance layerwise with v37_batch2 2011

ma

	params['IEGain'] =  0.75
	params['IIGain'] = 0.75
	params['IPTGain'] = 4.0
	params['weightNormThreshold'] = 3.0

modify layerwise weights (increase L4, decrease L2)

	# # L2/3+4
	params[('IEweights',0)] = [0.8,1.0]
	params[('IIweights',0)] = [1.0,1.2]
	# L6
	params[('IEweights',2)] = [1.0, 1.2]
	params[('IIweights',2)] = [0.8, 1.0]

*** results for bug run
- check why IIweights not working!!
- L2 IEweight decrease -> slightly increased IT2, SOM2,PV2,IT5A
- L5 IEweight increase -> shift IT pops start earlier ~100 ms; decreased PT5B,SOM6,PV6; probably dec IT6,CT6 but more spks
  since start earlier
- so overall IEweight effect is as desired


*** check why II not working
                "I_HH_simple_2_2": {
                    "postConds": {
                        "cellModel": "HH_simple",
                        "ynorm": [
                            0.77,
                            1
                        ],
                        "cellType": [
                            "PV",
                            "SOM"
                        ]
                    },
                    "weight": 0.75,
                    "synMech": [
                        "GABAASlow",
                        "GABAB"

had to split ['PV', 'SOM'] into 'PV' and 'SOM'

*** results
L6 IIweights decrease -> decreased IT6,CT6, IT5A, IT2,IT4; SOM6,PV6 also decreased! (recurrent effect?) -- ok
L6 IEweights increase -> decreased IT6,CT6, SOM6,PV6; slightly increased IT4, IT5A, IT5B,PT5B; slightly reduced IT2 -- ok
L2 II weights increase -> increase IT2; less relatively stable -- ok
L2 IE weights decrease -> increase IT2,IT4, IT5A, IT5B, PT5B -- ok

note: L6 IIweight increase -> increased IT6/CT6 -> increased IT5A (depol),IT5B,PT5B -> icnreased IT2,IT4 -- maybe lower E
L6->L5?! gmgs didn't include in major projections

** v38_batch3 - larger IE, II balance layerwise with v37_batch2 2011
comet

	params['IEGain'] =  0.75
	params['IIGain'] = 0.75
	params['IPTGain'] = 4.0
	params['weightNormThreshold'] = 3.0  - (realistic range of weights - EPSP mV ?)


	# # L2/3+4
	params[('IEweights',0)] = [0.6, 0.7, 0.8, 0.9, 1.0]
	params[('IIweights',0)] = [1.0, 1.1, 1.2, 1.3, 1.4]
	# L5
	# params[('IEweights',1)] = [0.75, 1.0, 1.25]
	# params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# L6
	params[('IEweights',2)] = [1.0, 1.1, 1.2, 1.3, 1.4]
	params[('IIweights',2)] = [0.6, 0.7, 0.8, 0.9, 1.0]

large, fine-tuned - 625

*** results
**** IT2
- L2_IEweights increase -> decrease firing if L6_IEweights <= 0.7 but increase! if L6_IEweights > 0.7 (dep blockade)
-- why? could depend on delay of 1st spike - no!
-- inc inh -> oscillations (faster hyper?) - dep blockade!

- L2_IIweights increase -> increase if L6_IE = 1.4 and/or if IIweight = 0.6 else decrease!
-- why? (should increase)
-- check 0_0_2_2 vs 0_4_2_2: increased L2_II 1)shifts peak of oscs back (earlier), 2) dec SOM2,PV2, 3) dec IT2
-- higher inh allows for faster spk rates (faster hyperpol, ready to spk again?)
-- check 0_0_2_1 vs 0_4_2_1 (no osc peaks): increased L2_II -> 1) dec SOM2,PV2, 2) inc IT2

- L6_IEweights increase -> IT2 decrease (significant for L5_IIw >=0.8)
-- why? (shouldn't really affect much) -
-- compare 3304 vs 3344:  L6->L5->L2, so if L6 dec -> L2 dec (higher leads to oscs, that start earlier)
*-- further isolate IT5A <-> IT5B, PT5B->IT5B, IT6/CT6->IT5B!!

- L6_IIw inc -> IT2 increase (similar but opposite effect as L6_IEw inc)
-- compare 0_4_2_1 with 0_4_2_3
-- due to increased L6 -> L5+L4? -> L2 (2 peaks)
*-- could be avoided if reduce L6->L5 E weights

- Using only secs 1-2 shows same pattern but max=7.5Hz instead of 4Hz

**** IT4
- same pattern as IT2
- minor difference for the ones with low variations (blank when norm) -- random, no clear pattern
- max avg 1-2sec = 3Hz

**** IT5A
- same as IT4
- max avg 1-2sec = 30Hz
- some dep blockade; plus dep block in SOM5A

**** IT5B
- L2_IEweights increase -> U-shaped - decrease, then increases
-- why??
-- check 0303 -> 4303: increased L2IE shifts peak of L2,L4,L5A; L5A high inhibits L5BIT (via inh?)
*-- reduce IT2,IT4,IT5A->IT5B

- L2_IIw increase -> inc for L2_IEw low; dec for L2_IEw high

- L6_IEw increase -> inc for L5_IIw > 0.6
-- why?
-- check 2202 -> 2242: L6 dec -> L2+L5 dec -> PV5,SOM5 dec -> IT5B inc
*-- lower L6->L2+L5

- L6_IIw inc -> dec
--check 2200 -> 2204: L6 inc -> L2+L5 inc -> PV5,SOM5 inc -> IT5B dec
*-- lower L6->L2+L5

**** PT5B
- L2_IEw inc -> inc
-- why? should decrease
-- 0404->4404: L2IT increases due to osc  - ok

- L2_IIw inc -> dec

- L6_IEw inc -> generally inc
- 2200->2240: IT6 dec -> SOM5B,PT5B dec -> PT5B inc

- L6_IIw inc -> dec
--  IT6 inc -> SOM5B,PT5B inc -> PT5B dec

**** IT6,CT6
- L2_IEw and L2_IIw - mostly independent - good

- L6_IEw inc -> dec - good

- L6_IIw inc -> inc - good

** v38_batch4 - IE, II balance layerwise with v37_batch2 2012 (weightNormThreshold higher)
ma - overheated!

	params['IEGain'] =  0.75
	params['IIGain'] = 0.75
	params['IPTGain'] = 4.0
	params['weightNormThreshold'] = 4.0

modify layerwise weights (increase L4, decrease L2)

	# # L2/3+4
	params[('IEweights',0)] = [0.8,1.0]
	params[('IIweights',0)] = [1.0,1.2]
	# L6
	params[('IEweights',2)] = [1.0, 1.2]
	params[('IIweights',2)] = [0.8, 1.0]

** v39_manualTune - check v38_batch3 2222 no errors and reasonable rates
on 'my'

- choose reasonable one from v38_batch3 - 2222

cfg.EEGain = 1.0
cfg.EIGain = 1.0
cfg.IEGain = 0.75
cfg.IIGain = 0.75

cfg.weightNormThreshold = 4.0  # weight normalization factor threshold


## I->E/I layer weights (L2/3+4, L5, L6)
cfg.IEweights = [0.8, 1.0, 1.2]
cfg.IIweights = [1.2, 1.0, 0.8]

RESULTS:

tune3 - solved mystery! was missing loc in netClamp !!

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170512_121617.png][fig]]
- mostly low firing in all pops except PT5B

tune10 - netClamp
- check what are inputs to PT5B and why so high - netClamp
-- have spks
-- need conns -- plot conn strength,convg barplot etc
- no strong inputs -- only recurrent from PT5B, and PV5B
- lower recurrent conns?

tune4 - netclamp without PT5B inputs
- no firing

tune5 - plotShape- syns/seg too high! 140!

tune6 - PT with long range to check syns/seg - subConn rules!

tune7 - PT netClamp + subConn redistribute -- only small diff in firing

tune8 - popColors

tune13 - netClamp ih vs no-ih -- same rate

tune14 - check if dend spikes; compare with apicdend wnorm*2.0/3.0
-- no dend spikes
-- ~3-4mV difference when 2/3 * weight (adends)

tune15 - increased inh weights

** v40_manualTune - checking ih effect on PT
- tune1 - soma, Exp2Syn(0.05, 5.3), wnorm=10
- tune2 - soma, Exp2Syn, w=7.5e-3 -> ratio 1.04
- tune3 - soma, Exp2Syn, w=7.5e-3, orig dend Na level -> small dif
- tune4 - use same PT params as sam (na blocked, lower kdmc, remove ca hotzone) -> small diff
- tune5 - start later to stabilize rmp (us cvode) -> ratio 1.03
- tune6 - use orig h -> ratio <1.0
- tune7 - use harnett h -> ratio 1.02

Note before was only changing ih in apical dends!

- tune8 - orig PT params, exp, 7.5e-3 -> ratio 1.08
- tune9 - no Na - identical -- weird?
- tune10 - w*1.5, with Na --> higher am ~15mV; similar ratio (slightly lower?)
- tune11 - w*1.5, without Na -->  same as with Na -- bug, not changing
- tune12 - w*5, with Na -> 5 spks
- tune13 - w*5, without Na -> 35mV EPSP
- tune14 - syn tau2*1.5 -> ratio 1.10
- tune15 - kap_gbar=0 -> ratio 1.10 (also increased slightly ratio of ih PT)
- tune16 - iclamp zn 0.1nA -> ratio 1.06 (higher V than ih)
- tune17 - iclamp 0.0975nA - to match RMP

- v39_tune13 - PT5B in netClamp with ih vs no-ih

- check Nat Neu paper (Geor09) kdr effect; and syn weight effect;  - Fig 4

- rerun sam, wider epsp, amp, iclamp, batch;

Fine tuning v40_batch5 0440 to match Sheets fig5; improve more by
1) increasing ih to 1.2;
2) reducing weight (EPSP should be ~5mV);
3) include corticostriatal

- tune23 - reproduce 0440
- tune24 - ih=1.2
- tune25 - ih=1.3
-  tune26 - ih=1.4
-  tune27 - ih=1.5
...
- tune30 - ih 1.8
- tune31 - w=0.15 -- too small
- tune32 - w=0.2
- actually weight was fine initally -- EPSP = 4-5mV

... increase tau? - increases overall level (but also inclination?)
- tune 33 - tau 0.3
- tune 34 - tau 0.35
...
- tune36: tau=0.28, ih=2.3,

- tune37: increase kdr*1.25 - lowered all amplitudes
- tune38: kdr*0 - also lowered -- weird

not including CSTR since higher - not well tuned? variability?

tuning train of spikes (sheets fig 8)
- tune40 - 10 dend inputs, 1stim, w=7.5e-3 - no spk (25mV, 18mV)
- tune41 - 10 dend inputs, 1stim, w=7.5e-3 * 3 - no spk (27 mV, 20 mV)
- tune42 - 10 dend inputs, 1stim, w=7.5e-3 * 4 -  no spk (29 mV, 22 mV)

sheets fig 8 - NOTE: b = after correcting axon Ra! (was commented out)
- tune47 - 100 inputs, 4 stim, w=0.1 wnorm, noise=0.5, delay=0.5-1.5
- tune48 - w=0.05 wnorm, syntau*0.5
- tune49 - w=0.05 wnorm
- tune49 - w=0.1 wnorm, syntau*0.5
- tune50 - w=0.1 wnorm, syntau*0.5, overlayed
- tune51 - w=0.1 wnorm, syntau*0.1
- tune52 - w=0.1 wnorm, syntau*0.5, noise=0.1
- tune53 - w=0.1 wnorm, syntau*0.5, noise=0.5, delay=0.5-1.0 (delay not doing much!)
- tune54 - noise=0.25, delay=1.0
- tune55 - w=0.15,noise=0.2,
- tune56 - w=0.2, noise=.2
- tune57 - w=0.15,noise=0.2, ih1=2.0, ih2=0.3
- tune57 - w=0.1,noise=0.25, ih1=2.0, ih2=0.3
- tune58 - w=0.15,noise=0.25, ih1=2.0, ih2=0.3
- tune59  - w=0.1,noise=0.3, ih1=2.0, ih2=0.3
- tune60  - w=0.1,noise=0.2, ih1=2.0, ih2=0.3
- tune60b

sheets fig 9 - NOTE: b = after correcting axon Ra! (was commented out)
- tune62 - 50 syns/stim, delay 50, syntau=0.5
- tune63 - 100 syns/stim, delay 50, different dend dist
- tune64 - ih2=0.1, w=0.2
- tune65 - only 1 pulse per stim (before 4), no Iclamp
- tune66 - syntau = 1.0
- tune67 - weight = 0.3 - worse
- tune68 - noise = 0.3 - perfect!
- tune68b
- tune69 - with Iclamp
- tune69b

sheets fig 11
- tune70 - rate= 20*0.2, numstims= 8*16*100*0.5, noise=1.0
- tune71 - numstims= 8*16*100*0.5
- tune72 - numstims= 8*16*100*0.25, noise=0.5
- tune73 - numstims= 8*16*100*0.1,rate=20*0.5, noise=0.5
- tune74 - number=1e9 (was 1!), start=100 (was 700)
- tune75 - 0.5-1.5 sec, number=rate (so stops)
- tune76 - num=rate*1.2, w=0.1 -> low spike peak <0mV
- tune77 - fixed bug - Axon Ra back - only 4 spks
- tune78 - rate 20 Hz, stims=8*16*0.2
- tune79 - num*19, stims*0.1
- tune80 - stims*0.07 - good
- tune81 - 5 sec duration
- tune82 - 5 sec with num*100
- tune83 - 1 sec, noise=0.0
- tune84 - stims*0.03
- tune85 - stims*0.05
- tune86 - stims*0.05 - opposite effect :/
- tune87 - noise 1.0
iclamp dur was only 1sec!!
- tune88 - stims*0.09
- tune89 - noise 0.5, stim*0.08
- tune90 - stims*0.06 - no ih spikes, 8 zd spikes
- tune91 - stims*0.07 - zd=2*ih
- tune92 - 40 hz
- tune93 - no Iclamp

** v40_batch4 - IE, II balance layerwise
note: used wrong label (v40_batch4 instead of batch1)
on comet

	params['IEGain'] =  0.75
	params['IIGain'] = 0.75
	params['IPTGain'] = 4.0
	params['weightNormThreshold'] = 2.0  - (realistic range of weights - EPSP mV ?)


	# # L2/3+4
	params[('IEweights',0)] =  [0.6, 0.8, 1.0]
	params[('IIweights',0)] = [1.0, 1.2, 1.4]
	# L5
	# params[('IEweights',1)] = [0.75, 1.0, 1.25]
	# params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# params['weightNormThreshold'] = [2.0, 3.0]
	params['IPTGain'] = [4.0, 5.0, 6.0]
	# L6
	params[('IEweights',2)] =  [1.0, 1.2, 1.4]
	params[('IIweights',2)] =  [0.6, 0.8, 1.0]


- maybe increase prob of Inh->PT5B ?2 - fixed; distance-based

*** filter exc cells < 7.5hz
<5hz - 1
<7.5 - 52
<10hz - ~150

IT2 and IT5A showing depol block
- possibly because IT5A (multicomp) also requires increased I (like PT)

*** grid results
IT2:
- IE_2 inc -> should be dec, but diff effects - dep on dep block and osc
- II_2 inc -> shuld be inc, but diff effects - dep on dep block and osc
- IE_6 inc -> dec (shouldn't have such big effect)
- II_6 inc -> inc (shouldn't have such big effect)

** v40_batch2 - ih in PT cell; ih level, num inputs, rate
- weightFactor: [0.25, 0.5, 1.0, 1.5, 2.0]  (7.5e-3)
- syn tau: [0.5, 1.0, 1.5, 2.0, 2.5]
- rate: [10, 20, 30, 40, 50] hz
- ih level: [0.0, 0.1, 0.25, 0.5, 0.75]

- iclamp (RMP): [0.0, 0.0486, 0.0972]
- ih level:
- kdr level: no effect

measure 1) ratio of 2nd (last?) peak (zd-ih), 2) epsp amp (zd-ih), 3) peak v (zd-ih)
Na blocked?

- TEST also ih level! arnsten (wang07b) found dependence (high doses of zn inversed firing)

*** results
syn weight (inc):
- inc peak diff (absolute value very close) - less neg values, good since ih > zd
- inc amp diff (amplitude of zn very high comparatively, to compensate for lower RMP) - good since zd > ih
- dec ratio (smaller epsps show higher ratio) - bad

syn tau2 (inc):
- inc peak diff - good
- inc amp diff - good
- inc (for low rates) + dec (for high rates) ratio diff - good, bad; for high rates, ih also increases ratio

rate (inc):
- same peak diff - small effect
- same amp diff - small effect (only noticeable 10 to 20 hz)
- ratio inc + dec (invert U) - good + bad

ih (inc):
- dec peak diff
- dec amp diff
- dec ratio diff - bad

summary:
- reproduced closer fig 7 sheets - eg. 0410 shows ratio of ~1.18 and increasing
- still didn't find example when abs V is higher in zd vs ih
- tau and rate have similar effect of ratio diff; but tau also increased peak/amp diff
- weight good for peak/amp diffs but bad for ratio

to do:
-- check 0.75 ih vs 0.25 ih -- PT ih might be too high; zd might not block all
-- try with Na on - v40_batch3
-- try with inputs to dends
-- try with real network activity

** v40_batch3 - ih PT; batch2 but with Na on
zn

	params['groupWeight'] = [x*7.5e-3 for x in [0.5, 1.0, 1.5, 2.0, 2.5]]
	params['excTau2Factor'] = [0.5, 1.0, 1.5, 2.0, 2.5]
	params['groupRate'] = [10, 20, 30, 40, 50]
	params['ihFactor2'] = [0.0, 0.1, 0.25, 0.5, 0.75]

- ih always spikes more than zd
** v40_batch4b - ih PT; batch2 with range of ih + Na
zn

	params['groupWeight'] = [x*7.5e-3 for x in [0.25, 0.5, 1.0, 1.5, 2.0]]
	params['excTau2Factor'] = [0.5, 1.0, 1.5, 2.0, 2.5]
	params['ihFactor1'] = [0.7, 0.8, 0.9, 1.0, 1.1]
	params['ihFactor2'] = [0.0, 0.1, 0.2, 0.3, 0.4]

** v40_batch5 - ih PT; batch2 with range of ih; without Na

zn

	params['groupWeight'] = [x*7.5e-3 for x in [0.25, 0.5, 1.0, 1.5, 2.0]]
	params['excTau2Factor'] = [0.5, 1.0, 1.5, 2.0, 2.5]
	params['ihFactor1'] = [0.7, 0.8, 0.9, 1.0, 1.1]
	params['ihFactor2'] = [0.0, 0.1, 0.2, 0.3, 0.4]

- find examples closer to sheets fig4 (ratio 1.20 increasing; pt ih 3rd epsp <1.0)
0200 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170522_185047.png][fig]]
0300 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170522_185254.png][fig]]
0310 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170522_185150.png][fig]]
0320
0330

0440 [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170522_185606.png][fig]] - improve more by increasing to 1.2; and reducing weight (EPSP should be ~5mV);
include corticostriatal

** v40_batch6 - ih PT; 10 stims in apicdend; no Na
	params['groupWeight'] = [x*7.5e-3 for x in [0.25, 0.5, 1.0, 1.5, 2.0]]
	params['excTau2Factor'] = [0.5, 1.0, 1.5, 2.0, 2.5]
	params['ihFactor1'] = [0.7, 0.8, 0.9, 1.0, 1.1]
	params['ihFactor2'] = [0.0, 0.1, 0.2, 0.3, 0.4]

** v40_batch7 - ih PT; grid stims
- set stims initially to nonspiny sec with weightNorm=0
- change with subConnParams to other secs with weightNorm=1
- otherwise subConn distributes, but doesn't remvoe stims

- results - use same colors; show also profile by plot1D with avg

** v40_batch8 - ih PT; 10 stims in apicdend; with Na  - CHECK WHY NO SPKS!
on zn

no spikes in any of them!!? weird - is it possible?? check; increase stim?

** v40_batch9 - ih PT; grid stim for different weights
** v40_batch10 - ih PT; grid stim lower weights
divided by 5.0

- check weight= index 2 !!!!
- use same colors; show also profile by plot1D with avg
** v40_batch11 - ih PT; grid stim with scaled weights based on dend L
- getting closer but ih epsps not low enough - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170529_200909.png][fig]]
- trying higher ih

** v40_batch12 - ih PT; grid stim with scaled weights based on dend L; higher ih
	params['ihX'] = range(8)
	params['ihY'] = range(24)
	params['groupWeight'] = [x*7.5e-3/5.0 for x in [0.1, 0.2, 0.3, 0.4]]
	params['ihFactor1'] = [1.5, 2.0]

** v40_batch13 - ih PT; 10 stims apicdend; with Na, higher amp (wrong axon Ra!)
- in zn -
- v40_batch8 - increase amp so get spikes
- multiplied weight * 2
- groupRate * 2 -> 40


	params['groupWeight'] = [x*7.5e-3*2 for x in [0.25, 0.5, 1.0, 1.5, 2.0]]
	params['excTau2Factor'] = [0.5, 1.0, 1.5, 2.0, 2.5]
	params['ihFactor1'] = [0.7, 0.8, 0.9, 1.0, 1.1]
	params['ihFactor2'] = [0.0, 0.1, 0.2, 0.3, 0.4]

*** results
- low amp spikes - ~-10 (not reaching 0mV threshold) -- not sure why
- only few cases spike -- not sure why either -- check manualTune?
- in all cases PT_ih fires more than PT_zd

- low amp spikes due to commented out AXON RA!

** v40_batch14 - ih PT; fig 9 sheets, temp integration
note: repeated after fixing axon Ra
params[('GroupNetStimEPT2',12)] = [10, 25, 50, 75, 100, 150, 200]

** v41_batch0 - IE,II balance layerwise (added IFullGain)
on comet
	params['IEGain'] =  0.75 -> 1.0
	params['IIGain'] = 0.75
	IPTGain = 1.0  - fixed
	params['weightNormThreshold'] = 2.0  - (realistic range of weights - EPSP mV ?)

	# # L2/3+4
	params[('IEweights',0)] =  [0.75, 1.0, 1.25]
	params[('IIweights',0)] = [0.75, 1.0, 1.25]
	# L5
	# params[('IEweights',1)] = [0.75, 1.0, 1.25]
	# params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# params['weightNormThreshold'] = [2.0, 3.0]
	params['IFullGain'] = [2.0, 3.0, 4.0]

	# L6
	params[('IEweights',2)] =  [0.75, 1.0, 1.25]
	params[('IIweights',2)] =  [0.75, 1.0, 1.25]


- IT2 too low - include 0.6, 0.8
- IT5A too low - remove from IFullGain; IEGain might be enough; otherwise use IEweights,1
- PT5BGain = 3.0

** v41_batch1 - IE, II balance (fixed weightNorm bug!)
on bridges psg - error - rerunnig! (compare with comet output)
on comet
fixed weightNorm! - might need to rerun with lower PT?!

	params['IEGain'] = 1.0
	params['IIGain'] = 0.75 -> 0.8
	IPTGain = 3.0  - fixed
	params['weightNormThreshold'] = 2.0  - (realistic range of weights - EPSP mV ?)

	# # L2/3+4
	params[('IEweights',0)] =  [0.6, 0.8, 1.0]
	params[('IIweights',0)] = [1.0, 1.2, 1.4]
	# L5
	# params[('IEweights',1)] = [0.75, 1.0, 1.25]
	# params[('IIweights',1)] = [0.75, 1.0, 1.25]
	# params['weightNormThreshold'] = [2.0, 3.0]
	# params[('IEGain,1')] = [0.6, 0.8, 1.0]
	# L6
	params[('IEweights',2)] =  [1.0, 1.2, 1.4]
	params[('IIweights',2)] =  [0.6, 0.8, 1.0]


*** results
- good rates in all pops
- CT6 a bit too low -- max 0.2hz
- IT5A depol blockade
-- decrease via IEweights,1 -- IT5B and PT5B also ok if get decreased
-- dec via IIT5AGain - no
-- dec via IFullGain - ?

** v41_batch2 - IE, II balance
on bridges psg - error
on comet
fixed weightNorm! - might need to rerun with lower PT?!

	params['IEGain'] = 1.0
	params['IIGain'] = 0.75 -> 0.8
	params['weightNormThreshold'] = 2.0  - (realistic range of weights - EPSP mV ?)

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]
	params[('IIweights',0)] = [1.0, 1.2]
	# L5
	params[('IEweights',1)] = [1.0, 1.2, 1.4]
	params[IPTGain,1] = [2.0,3.0]
	params['weightNormThreshold'] = [2.0, 3.0]
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0]

*** results
- check 0_1_1_0_1_1_0 - very low IT2
- good rates:
--  1_1_0_1_1_1_0 - IEweight_1=1.0, IPT_Gain=3.0 but ok (wnormthresh 2 or 3)
-- 1100110 - good params and ok
-- 1000110 - even better params (only L6 inc, IPTGain=2), osc -- traces ok
-- 1000010 - also ok, more PT
--
*** try with 1000110

	params['IEGain'] = 1.0
	params['IIGain'] = 0.8

	# # L2/3+4
	IEweights_0 = 1.0
	IIweights_0 = 1.0
	# L5
	IEweights_1= 1.0
	IPTGain_1 = 2.0
	weightNormThreshold = 3.0
	# L6
	IEweights_2 =  1.2
	IIweights_2 =  0.8

** v41_batch3 - long stim + ih with v41_batch2 1000110
on comet

	params['IEGain'] = 1.0
	params['IIGain'] = 0.8

	# # L2/3+4
	IEweights_0 = 1.0
	IIweights_0 = 1.0
	# L5
	IEweights_1= 1.0
	IPTGain_1 = 2.0
	weightNormThreshold = 3.0
	# L6
	IEweights_2 =  1.2
	IIweights_2 =  0.8

	params['ihFactor'] = [0.0, 1.0, 2.0]
	params[('pulse',0)] = ['None', 'TPO', 'TVL',  'S2', 'M2', 'OC']# ['S1','cM1','OC']
	params[('pulse',3)] = [20, 30]


-- ihFactor didn't work - not implemented in netParams.py

*** results
- TPO->IT2 - ok
- TPO->IT4 - not strong enough, should be stronger than ->IT2 -- why?
- TPO->IT5A - depol block
- TPO->IT5B - no response -good?
- TPO->PT5B - delayed 20ms, depol block
- TPO->IT6 - no response
- TPO->CT6 - no response - good

- TPO->SOM2 - high freq
- TPO->PV2 - high freq

** v41_batch4 - long stim + ih with v41_batch2 1000110, fixed ih, updated netpyne randomizer (still bugs)
runing on comet
usekole=True (old ih)
	params['ihFactor'] = [0.0, 1.0, 2.0]
	params[('pulse',0)] = ['None', 'TPO', 'TVL',  'S2', 'M2', 'OC']# ['S1','cM1','OC']
	params[('pulse',3)] = [20, 30]
** v41_batch5 - long stim + ih with v41_batch2 1000110, fixed ih, updated netpyne v0.7.0
runing on comet
usekole=True (old ih)
	params['ihFactor'] = [0.0, 1.0, 2.0]
	params[('pulse',0)] = ['None', 'TPO', 'TVL',  'S2', 'M2', 'OC']# ['S1','cM1','OC']
	params[('pulse',3)] = [20, 30]

- ihFactor increase -> decrease PT5B rate! why!? depol block?
- bug - all ihn cells = 0.333 Hz !? 1 spk in 3 sec
- due to updated randomizer -- E->I rules?
- vsoma of PV+SOM goes to super high ~250 mV -- remains ~fixed

** v42_batch1 - PT fI curve with new ih channel (Migliore)
- bug in distribution (gbar)
b = IFcurveParam(pnameList = ['hMod', 'ihFactor1'],
				pvaluesList = [['kole', 'migliore'], [0.0, 1.0]],
				groupList = [0,0],
				Ivalues=list(np.arange(-2.0, 8.0, 0.5)/10.0))

- this is somatic, but really need netstims to dends to check ih effect

** v42_batch2 - PT somatic epsp in response to dend syn input with new ih (migliore)

	params['ihModel'] = ['kole']*2+['migliore']*5
	params['ihGbar'] = [0.0] + [1.0]*6
	params['ihLeak'] = [0.0, 0.0, 0.1, 0.3, 0.5, 0.7, 0.9]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0, 21.0, 2.5)]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

	grouped = ['ihModel', 'ihGbar', 'ihLeak']
	for p in b.params:
		if p['label'] in grouped: p['group'] = True

** v42_batch3 - PT somatic epsp in response to dend syn input with new ih (migliore); ihlke

	params['ihModel'] = ['kole']*2+['migliore']*5
	params['ihGbar'] = [0.0] + [1.0]*6
	params['ihlkc'] = [0.0, 0.0, 0.7, 0.7, 0.7, 0.7, 0.7]
	params['ihlke'] = [0.0, 0.0, -70, -80, -90, -100, -110]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.000001, 21.0, 2.5)]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

	grouped = ['ihModel', 'ihGbar', 'ihlkc', 'ihlke']
	for p in b.params:
		if p['label'] in grouped: p['group'] = True

- worked! check:
-- lower ihlke and higher ihlkc
-- ihGbar = [0.1, 1.5, 2.0]
-- higher num of syns / weightNorm / obliques

- plot somatic fIcurve -- make sure doesn't change much

- plot sheets fig 11

** v42_batch4 - PT somatic eps, dend syn input, migliore ih, finer tuning

** v42_batch5 - PT ih migliore, fI curve

	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [1.0,2.0] +[1.0]*4 + [2.0]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.0, 1.0, 1.1, 1.1, 1.0, 1.0, 1.1, 1.1]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -90, -100, -90, -100, -90, -100, -90, -100] # [-90, -100]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
** v42_batch6 - PT ih migliore, fI curve (higher c, lower e)

	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [0.75,1.0] +[0.75]*4 + [1.0]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -60, -70, -60, -70, -60, -70, -60, -70] # [-60, -70]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)

** v42_batch7 - PT somatic eps, dend syn input, migliore ih, finer tuning

	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [0.75,1.0] +[0.75]*4 + [1.0]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -60, -70, -60, -70, -60, -70, -60, -70] # [-60, -70]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]

** v42_batch8 - PT somatic eps, dend syn input, migliore ih, finer tuning

	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [1.25,1.5] +[1.25]*4 + [1.5]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -80, -80, -70, -70, -80, -80, -70, -70] # [-60, -70]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

** v42_batch9 - PT ih migliore, fI curve
	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [1.25,1.5] +[1.25]*4 + [1.5]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4, 1.2, 1.4]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -80, -80, -70, -70, -80, -80, -70, -70] # [-60, -70]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

** v42_batch10 - PT somatic eps, dend syn input, migliore ih, finer tuning
	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [1.25,1.5] +[1.25]*4 + [1.5]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.4, 1.6, 1.4, 1.6, 1.4, 1.6, 1.4, 1.6]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -85, -85, -90, -90, -85, -85, -90, -90] # [-60, -70]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

** v42_batch11 - PT ih migliore, fI curve
	params['ihModel'] = ['kole']*3+['migliore']*8
	params['ihGbar'] = [0.0] + [1.25,1.5] +[1.25]*4 + [1.5]*4  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.0, 1.4, 1.6, 1.4, 1.6, 1.4, 1.6, 1.4, 1.6]  # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, 0.0, -85, -85, -90, -90, -85, -85, -90, -90] # [-60, -70]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)

** v42_manualTune
tune5 - migliore, alldend, w=0.1
tune6 - kole
tune7 - kole, w=0.2
tune8 - 40 hz, apicdend
tune9 - w=0.4
tune10 - noise=0.2 (so there's some summation)
tune10 - w=0.8
tune11 - migliore
tune12 - ihLeak = 0.2

fig 11 sheets with new ih:
tune13-19

check fI curve for batch10 and 11
tune21 - cfg.ihModel = 'migliore', cfg.ihGbar = 1.25, cfg.ihlkc = 1.2, cfg.ihlke = -70, amp=0.4 (0.5?), 0.5sec  -> 7 spks
tune22 - ihGbar=1.5 -> 1 spk
tune27 - ihGbar = 1.0 -> 9 spk
tune23 - ihlkc=1.4 -> 1 spk
tune26 - ihlkc=1.0 -> 8 spk
tune24 - ihlke = -60 -> 16 spk
tune25 - ihlke = -80 -> 0 spk

check reducing somatic ih
tune26 - ihGbar = 1.25, ihlkc = 1.2, ihlke = -70, amp=.6, 0.5sec -> 12 spk
tune27 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, amp=.6, 0.5sec -> 11 spk
tune28 - ihGbar = 1.25, ihlkc = 1.2, ihlke = -70, amp=.5, 0.5sec -> 7 spk
tune29 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, amp=.5, 0.5sec -> 1 spk
tune30 - ih soma=0, ihGbar = 1.25, ihlkc = 1.2, ihlke = -70, amp=.6, 0.5sec -> 13 spk
tune31 - ih soma+basal *0.1 -> 16 spk (good! close orig)
tune32 - ihgbarBasal = 1.0; epsp 5-> -68.5mV
tune33 - ihgbarBasal = 0.1; epsp 5-> -70.8mV
tune34 - h_gbar * 0.1 (PTcell.hoc); epsp 5-> -72.03mV
tune35 - h_gbar * 0.1 (PTcell.hoc); fI -> 17 spk
tune36 - ihgbar = 0.1 (cfg); fI -> 18 spk
tune37 - ihgbar = 0.1 (cfg); epsp 5-> -72.78
tune38 - ihgbar = 0.0 (cfg); epsp 5-> -79.64
tune39 - ihgbar = 0.0 (cfg); fI -> 17 spk
tune40 - ihgbar = 0.0 (cfg); epsp 20 -> -65.47
tune41 - h_gbar * 0.1 (PTcell.hoc); epsp 20-> -60.86
tune42 - ihgbarBasal = 0.1; epsp 20-> -61.13
tune43 - ihlke=-80, ihgbarBasal = 0.1; epsp 20-> -64
tune44 - ihlke=-80, ihgbarBasal = 0.5; epsp 20-> -63.85
tune45 - ihgbar=1.5, ihlke=-80, ihgbarBasal = 0.1; epsp 20-> 64.39
tune46 - ihgbar=1.5, ihlkc=1.5, ihlke=-80, ihgbarBasal = 0.1; epsp 20-> 65.24
tune47 - ihgbar=1.5, ihlkc=1.5, ihlke=-80, ihgbarBasal = 1.0; epsp 20-> -65.64
tune48 - ihgbar=1.5, ihlkc=1.5, ihlke=-80, ihgbarBasal = 0.1; ih, 1sec -> 20 spk !
tune49 - ihgbar=1.5, ihlkc=1.5, ihlke=-80, ihgbarBasal = 1.0; ih, 1sec -> 0 spk !
tune50 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal = 0.1; ih, 1sec -> 14 spk
tune51 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal = 0.05; ih, 1sec -> 16 spk
tune52 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal = 0.01; ih, 1sec -> 18 spk
tune52r - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal = 0.01; epsp 20 -> -66.77
tune53 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal = 1.0; epsp 20 -> -67.5
tune54 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal=1.0, steady state: -67.5mV, 0 spk
tune55 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, ihgbarBasal=0.01, steady state: -66.8mV, 13 spk
tune56 - ihgbar=1.5, ihlkc=1.5, ihlke=-85, h_gbar * 0.1, steady state: -64.73mV, 20 spk
tune57 - ihgbar=0.0, ihlkc=1.5, ihlke=-85, steady state: -65.47mV, 23 spk

check migliore ghdbar_hd(x) = ghd*(1+100/(1+exp((half-xdist)/slope))); ghd = 0.6e-4; slope = 14, half = 265

tune58 - ihGbar = 1.25, ihGbarBasal = 1.0, ihlkc = 1.2, ihlke = -70, mig orig distribut -> 25 spk, -60.84
tune59 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, mig orig distribut -> 0 spk, -67.6mV
tune60 - ihGbar = 0, ihlkc = 1.5, ihlke = -85, mig orig distribut -> 23 spk, -65.475mV
tune61 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, vhalfl from mig distribut -> 0 spk, -66.51mV -> GOOD!
tune62 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, vhafl_hd=-78.474, vhaft_hd=-66.139 -> 0spk, -63.2mV -> bad
tune63 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70 -> 21 spk, -60.3
tune64 - ihGbar = 0, ihlkc = 1.2, ihlke = -70 -> 23 spk, -65.4750021773807
tune65 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, vhafl_hd=-78.474, vhaft_hd=-66.1 -> 28spk, -56.26  -> bad
tune66 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, vhalfl from mig distribut -> 22 spk, -59.56 -> ok'ish
tune67 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig distribut -> 23 spk, -60.99 -> GOOD! lower epsp (<60.3), same fI
tune68 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig distribut, basal func of x -> 23 spk, -60.99 (same good)
tune69 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -85, mig orig distribut, basal func of x -> 0 spk, -66.433
tune70 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -85 -> 0 spk, -66.213 (so only slightly worse)
tune71 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=297 -> 24 spk, -59.753 (worse, >60.3)
tune72 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=230 -> 21 spk, -62.612 (good, <60.3)
tune73 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=200 -> 17 spk, -64.113 (compromise, <60.3)
tune74 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=170 -> 11 spk, -65.406 (compromise, <60.3)
tune75 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=140 -> 0 spk, -66.51 (compromise, <60.3)

location of inputs

tune76 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=265; unif dist: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170630_124210.png][fig]]-> 0 spk, -60.9 ;
tune77 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900] [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170630_125552.png][fig]] -> 23 spk, -71.618 (no epsp)
tune78 - ihGbar = 0.0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900] [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170630_125552.png][fig]] -> 22 spk, -84.25
tune79 - ihGbar = 0.0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900], w=80e-4 -> 22 spk, -81.9
tune80 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900], w=80e-4 -> 23 spk, -71.57 (no epsp)
tune81 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900], w=80e-4 -> 27 spk, -72.53 (small epsp)
tune82 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -70, mig orig, half=230; upper apic [300-900], w=80e-4 -> 25 spk, -72.19 (no epsp)
tune83 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; upper apic [300-900], w=80e-4, num=150 -> 27 spk, -72.41
(no epsp)
tune90 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, mig orig, half=265; upper apic [0-300], w=80e-4, num=75 -> 0spk, -78.31 mv (bad)
tune91 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, sam dist, half=265; upper apic [0-300], w=80e-4, num=75 -> 0spk, -79.30 mv (better?)

tune84 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=265; lowe apic [0-300], w=20e-4, num=75 -> 24spk, 16.1 mv
tune85 - ihGbar = 0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; lower apic [0-300], w=20e-4, num=75 -> 23spk, 15.5 mv
tune86 - ihGbar = 0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; lower apic [0-300], w=5e-4, num=75 -> 22spk, -64.6 mv
tune87 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -70, mig orig, half=265; lower apic [0-300], w=5e-4, num=75 -> 28spk, 13.8 mv
tune88 - ihGbar = 1.5, ihlkc = 1.2, ihlke = -70, mig orig, half=265; lower apic [0-300], w=5e-4, num=75 -> 23spk, -54.6 mv
tune89 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, mig orig, half=265; lower apic [0-300], w=5e-4, num=75 -> 0spk, -62.61 mv (bad)
tune92 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, sam dist, half=265; lower apic [0-300], w=5e-4, num=75 -> 0spk, -63.75 mv (better?)

spiking (sheets fig 11); num=int(8*16*100*0.07), w=7.5e-3, noise=0.5, start=500, dur=1.5, alldend

tune93 - ihGbar = 0.0, ihlkc = 1.5, ihlke = -85, mig orig, half=265; 32.67hz
tune94 - ihGbar = 1.5, ihlkc = 1.5, ihlke = -85, mig orig, half=265; 0.667hz
tune95 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -75, mig orig, half=265; 18hz
tune96 - ihGbar = 1.0, ihlkc = 1.2, ihlke = -75, mig orig, half=265; apicdend, 0hz
tune96 - ihGbar = 0.0, ihlkc = 1.2, ihlke = -75, mig orig, half=265; apicdend, 6.6hz

ihGbarBasal; check if also no spks- ok; check if fix basal+soma to min

tune97 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4, amp=0.6,start=1000ms -> 23 spk, -65.47mV
tune98 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4, amp=0.6,start=1000ms -> 18 spk, -61.792
tune99 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp w=20e-4,amp=0.6,start=1000ms -> 27 spk, -62.46
tune100 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4,amp=0.6, start=0ms -> 34 spk - large diff!
tune102 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4,amp=0.6, start=0ms -> 19 spk
tune101 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp w=20e-4,amp=0.6, start=0ms -> 29 spk
tune103 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4,amp=0.6, start=500ms -> 27 spk
tune104 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4,amp=0.6, start=500ms -> 18 spk
tune105 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp w=20e-4,amp=0.6, start=500ms -> 28 spk
tune106 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), w=5e-4 -> 10 spk
tune107 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), w=5e-4 -> 0 spk
tune108 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp num=(8*16*100*0.07), w=5e-4 -> 0 spk
tune109 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, mig dist, epsp num=(8*16*100*0.07), w=5e-4 -> 0 spk
tune111 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), w=20e-4 -> 51 spk
tune112 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), w=20e-4 -> 33 spk
tune110 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp num=(8*16*100*0.07), w=20e-4 -> 43 spk
tune113 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), alldend, w=20e-4 -> 49 spk
tune114 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp num=(8*16*100*0.07), alldend, w=20e-4 -> 36 spk - good
tune115 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4, noise=0.2 -> -67.26mV
tune116 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4, noise=0.0 -> -61.79mV
tune117 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=1.0, sam dist, epsp w=20e-4, noise=0.2 -> -67.52mV
tune118 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1, sam dist, epsp w=20e-4, noise=0.2 -> -68.29mV

Network with mig ih!

tune120 - ihGbar=1.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1 - good!
  Spikes: 35122 (2.05 Hz)
   IT2 : 0.041 Hz
   SOM2 : 10.788 Hz
   PV2 : 0.000 Hz
   IT4 : 0.936 Hz
   IT5A : 1.552 Hz
   SOM5A : 0.652 Hz
   PV5A : 36.148 Hz
   IT5B : 5.188 Hz
   PT5B : 0.263 Hz
   SOM5B : 0.446 Hz
   PV5B : 22.285 Hz
   IT6 : 2.812 Hz
   CT6 : 0.006 Hz
   SOM6 : 10.785 Hz
   PV6 : 0.000 Hz
   TPO : 0.627 Hz
   TVL : 0.656 Hz
   S1 : 0.659 Hz
   S2 : 0.648 Hz
   cM1 : 0.612 Hz
   M2 : 0.689 Hz
   OC : 0.643 Hz

tune121 - ihGbar=0.0, ihlkc=1.2, ihlke=-75, ihGbarBasal=0.1 - increased PT5B!
  Spikes: 34255 (1.99 Hz)
   IT2 : 0.012 Hz
   SOM2 : 10.481 Hz
   PV2 : 0.000 Hz
   IT4 : 0.994 Hz
   IT5A : 1.379 Hz
   SOM5A : 0.652 Hz
   PV5A : 35.258 Hz
   IT5B : 4.950 Hz
   PT5B : 0.514 Hz
   SOM5B : 0.446 Hz
   PV5B : 21.526 Hz
   IT6 : 2.659 Hz
   CT6 : 0.004 Hz
   SOM6 : 10.355 Hz
   PV6 : 0.000 Hz
   TPO : 0.627 Hz
   TVL : 0.656 Hz
   S1 : 0.659 Hz
   S2 : 0.648 Hz
   cM1 : 0.612 Hz
   M2 : 0.689 Hz
   OC : 0.643 Hz

** v42_batch12 - PT ih migliore, epsp syn input, explor 3 ih params
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-60, -65, -70, -75, -80, -85, -90, -95] # [-60, -70]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

- ihGbar ok - but very small effect
- ihlkc ok - but small effect
- ihlke and groupWeight ok

- need to plot difference between crosspoint with no ih

** v42_batch13 - PT fIcurve, explor 3 ih params
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['ihGbar'] = [0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-60, -65, -70, -75, -80, -85, -90, -95] # [-60, -70]

- possible good compromise - nope, bad epsp:
-- ihGbar = 0.9
-- ihlke = -80
-- ihlkc = 0.9

- try modifying distribution? more or less in soma?
- retune PT - since new ih lowers excitability, the PT with ih should show similar fI as orig, and the no ih should show
  higher fI -- increase na?

- so overall with new ih excitability is reduced (which is what we wanted), but messes up fI curve — so was thinking that
  perhaps the prev fix we did to eliminate dendritic spikes (reduced dend na x4) might not be needed anymore since the new ih
  might take care of that — I’ll check

** v42_batch14 - PT ih migliore, epsp syn input, (ihgbar 0.9, ihlke -75, ihlck 0.9)

	params['ihModel'] = ['kole','migliore', 'migliore']
	params['ihGbar'] = [0.9, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6] # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, -75] #[-60, -65, -70, -75, -80, -85, -90, -95] # [-60, -70]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

- does not match v42_batch12! why?? -- substract from batch12 values so clear
-- does match v42_batch12, but was interpreting wrong

** v42_batch15 - PT fIcurve, test (ihgbar 0.9, ihlke -80, ihlck 0.9)
	params['ihModel'] = ['kole','migliore', 'migliore']
	params['ihGbar'] = [0.9, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6] # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, -80] #[-60, -65, -70, -75, -80, -85, -90, -95] # [-60, -70]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

	grouped = ['ihModel', 'ihGbar', 'ihlkc', 'ihlke']
	for p in b.params:
		if p['label'] in grouped: p['group'] = True

- too far from orig PT fI curve

** v42_batch16 - PT fIcurve, test (ihgbar 0.9, ihlke -75, ihlck 0.9)
	params['ihModel'] = ['kole','migliore', 'migliore']
	params['ihGbar'] = [0.9, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.0, 0.0, 0.9] #[0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6] # [1.0. 1.1]
	params['ihlke'] = [0.0, 0.0, -75] #[-60, -65, -70, -75, -80, -85, -90, -95] # [-60, -70]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py')

	grouped = ['ihModel', 'ihGbar', 'ihlkc', 'ihlke']
	for p in b.params:
		if p['label'] in grouped: p['group'] = True
** v42_batch17 - PT ih=1.5 fIcurve, dend Na, axon Na+Ra

   cfg.ihModel = 'migliore'  # ih model
   cfg.ihGbar = 1.5  # multiplicative factor for ih gbar in PT cells
   cfg.ihlkc = 1.5  # ih leak param (used in Migliore)
   cfg.ihlke = -90  # ih leak param (used in Migliore)


	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['dendNa'] = [0.1, 0.25, 0.4, 0.7, 1.0]
	params['axonNa'] = [0.5, 1, 6, 11, 15]
	params['axonRa'] = [0.001, 0.005, 0.1, 0.5, 1]

** v42_batch18 - PT ih=0,0.5,1.0, fIcurve, dend Na, axon Na+Ra
running on zn

   cfg.ihModel = 'migliore'  # ih model
   cfg.ihlkc = 1.5  # ih leak param (used in Migliore)
   cfg.ihlke = -90  # ih leak param (used in Migliore)


	params['ihGbar'] = [0.0, 0.5, 1.0]
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['dendNa'] = [0.1, 0.25, 0.4, 0.7, 1.0]
	params['axonNa'] = [0.5, 1, 6, 11, 15]
	params['axonRa'] = [0.001, 0.005, 0.1, 0.5, 1]

- fI with orig na+axon -> increased diff between ih vs no ih
- only increasing dendNa or axonNa -> higher fI (ih=0.5), lower fI (ih=0.0)
- dec axonRa -> higher fI (ih=0.5)

- if ih=1.0 -> all fI = 0

REPEAT FOR EPSP - v42_batch20 (different ih params)
REPEAT FOR EPSP - v42_batch21

** v42_batch19 - PT ih fI curve, ihgbarBasal
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['ihGbar'] = [0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]
	params['ihgbarBasal'] = [0.001, 0.01, 0.1, 0.5, 1.0]

- repeat since ihgbarBasal ->ihGbarBasal
- repeat since Iclamp delay=1000 -> changed to 0 manually on zn

- with ihBasal=0.1, get ~decent ih with ihlkc=1.2 and ihlke=85 -> reversal epsp - GREAT!
- check epsps v42_batch22

** v42_batch20 - PT ih=0,0.5,1.0, EPSP, dend Na, axon Na+Ra, ihlkc=1.2, ihkle=-70

   cfg.ihModel = 'migliore'  # ih model
   cfg.ihlkc = 1.5  # ih leak param (used in Migliore) - wrong! = 1.2
   cfg.ihlke = -90  # ih leak param (used in Migliore) - wrong! = -70


	params['ihGbar'] = [0.0, 0.5, 1.0]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['dendNa'] = [0.1, 0.25, 0.4, 0.7, 1.0]
	params['axonNa'] = [0.5, 1, 6, 11, 15]
	params['axonRa'] = [0.001, 0.005, 0.1, 0.5, 1]

0_8_1_3_1

- with orig na+axon -> 0.0 vs 0.5/1.0: early reversal effect (after stp 2) -- GOOD; but then reverse again (ih spikes before) --
  BAD
- just inc dendNa -> higher epsp curve - easier to cross with ih?
- subtract from corresponding loc in ih=0.0 -- no soln shows valid reversal
- repeat with same ih params as batch18 -- v42_batch21

** v42_batch21 - PT ih=0,0.5,1.0, EPSP, dend Na, axon Na+Ra, ihlkc=1.5, ihkle=-90
on zn
   cfg.ihModel = 'migliore'  # ih model
   cfg.ihlkc = 1.5  # ih leak param (used in Migliore)
   cfg.ihlke = -90  # ih leak param (used in Migliore)


	params['ihGbar'] = [0.0, 0.5, 1.0]
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['dendNa'] = [0.1, 0.25, 0.4, 0.7, 1.0]
	params['axonNa'] = [0.5, 1, 6, 11, 15]
	params['axonRa'] = [0.001, 0.005, 0.1, 0.5, 1]

- wrong - only weight changing -- why?!? - had old netParams_cell.py

** v42_batch22 - PT ih epsp, ihgbarBasal
on ag
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]
	params['ihGbarBasal'] = [0.01, 0.1, 0.5, 1.0]


repeated! ihgbarBasal -> ihGbarBasal

- interesting 0.01 actually similar to 1.0 !!

** v42_batch23 - PT ih fI curve, mig distribut, with varying ihHalf
mig orig distribution, with varying half

	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['ihGbar'] = [0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]
	params['ihHalf'] = [200, 230, 265]

- 265 only decent ih -- less ih near some -> better
- ihGbarBasal=0.1 better ih curve than mig dist; for ih=0.8, e=-75, c=1.2: mig=6 pt, basal 0.1=8 pt
- with epsp reversal - only 5/6 fI pts

** v42_batch24 - PT ih epsp,  mig distribut, with varying ihHalf

	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]
	params['ihHalf'] = [200, 230, 265]

- compared to sam dist: practically identical epsp; slightly better fI

** v42_batch25 - PT ih epsp,  mig distribut, test num inputs (bug)
	params[('IClamp1', 5)] = list(np.arange(-2.0, 8.0, 0.5)/10.0)
	params['ihGbar'] = [0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]
	params[('IClamp1', 1)] = [50, 75, 100]

** v42_batch26 - PT ih spikes

	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]  # [1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2, 1.4, 1.6] # [1.0. 1.1]
	params['ihlke'] = [-75, -80, -85, -90, -95] # [-60, -70]

weight= 0 -> bug, shows weight=0.0075

- spk rate decreases almost linearly with ih - great!

** v42_batch27 - PT epsp
   ihkle = -75
   ihklc = 1.2

	params['groupWeight'] = [x*1e-5 for x in np.arange(0.0, 300, 5)]
	params['ihGbar'] = [0.0, 0.8, 1.0, 1.2]
   	params[('GroupNetStimEPT', 0)] = [50, 75, 100] # numStims
   	params[('GroupNetStimEPT', 4)] = ['alldend', 'apicdend']  # secList
   	params['ihGbarBasal'] = [0.1, 0.5, 1.0]

- no reversal in any of them :(

** v42_batch28 - PT epsp, with noise
   ihkle = -75
   ihklc = 1.2

	params['groupWeight'] = [x*1e-5 for x in np.arange(0.0, 300, 5)]
	params['ihGbar'] = [0.0, 0.8, 1.0, 1.2]
   	params[('GroupNetStimEPT', 9)] = [0.0, 0.1, 0.2, 0.5] # numStims
   	params[('GroupNetStimEPT', 4)] = ['alldend', 'apicdend']  # secList
   	params['ihGbarBasal'] = [0.1, 0.5, 1.0]

-- reversal using 0.2 noise !!! ih=1.0, ihbasal=0.1,c=1.2, e=-75 (only if apicdend :/)  - should be decent fI curve - great!
-- also ih=1.0, ihbasal=1.0, c=1.2, e=-75, alldend, noise=0.5 -> reversal at high weights (>200*1e-5)

** v42_batch29 - IE, II balance (with mig ih)
on comet

	params['IEGain'] = 1.0
	params['IIGain'] = 0.75 -> 0.8

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]
	params[('IIweights',0)] = [1.0, 1.2]
	# L5
	params[('IEweights',1)] = [1.0, 1.2]
	params[IPTGain,1] = [2.0,3.0]
	params['weightNormThreshold'] = [3.0, 4.0]
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0]

- all look ok'ish -- oscillations in IT, bursts in PT, low rate in CT
- rates + E5>E6>E2 -> 1 case = 1110111
- only rates -> 4 other cases: 0011010, 001100,0001000,0000000

- plot traces of selected!

** v42_batch30 - long stim + ih with v41_batch2 1000110 (with mig ih) - USED FOR CNS17 POSTER
on cm

cfg.ihGbarBasal = 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihlke = -75  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005  # axon axial resist (reduced to compensate)


	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse',0)] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC']#['S1','cM1','OC']
	params[('pulse',3)] = [20, 30]

- compare ih vs zd
- modes of operation - what needs to change to get them?

- ALL:
-- slow ~1hz osc in IT2 -- originate in IT2? zoom in

- TPO:
-- 20 hz stim produce approx same amp as natural slow osc
-- 30 hz stim comparatively higher amp + strong ~20hz osc
-- ih dec -> increase PT freq but not much - 3.4 -> 3.8Hz
-- IT5A+PT5B some dep block after 30hz stim (not with 30hz)

- TVL:
-- ih dec -> increase PT freq but not much
-- PT5B activated directly, with less upper IT
--  PT5a activated later -- due to PT5B?? shoudln't, check with netclamp??

- S2:
-- ih dec -> increase PT freq but not much
-- PT5B activated directly, with less upper IT

- M2:
-- IT6 highly activated; but not much PT
-- CT6 also active

- OC:
-- IT6 + CT6 activated; some PT too

*** for poster
- ih difference in TVL - ih 0 vs 2 - 700-1700 ms
- pathways S2->L23/5A->PT (30 hz) - 1000 - 1050?
- pathay M2->PT ?
- beta freq?
- Granger S2 vs M2?

** v43_batch1 - fI curve for all pops (start=500ms)
	# list of params and values
	params[('IClamp1', 'pop')] = ['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6', 'PV2', 'SOM2']
	params[('IClamp1', 'amp')] = list(np.arange(-2.0, 6.5, 0.5)/10.0)

** v43_batch2 - fI curve for PT with different params -
	params[('IClamp1', 'amp')] = [0.3,0.6]
	params['ihGbar'] = [0.5, 1.0, 1.5, 2.0]
	params['ihGbarBasal'] = [0.01, 0.1]
	params['ihlkc'] = [0.8, 1.0, 1.2]
	params['ihlke'] = [-66, -68, -70, -72, -74, -76]
	params['axonNa'] = [1, 3, 5, 7, 9, 11]

** v43_batch3 - netstim spikes with same params as v43_batch2
	params['ihGbar'] = [0.0 0.5, 1.0, 1.5, 2.0]
	params['ihGbarBasal'] = [0.01, 0.1]
	params['ihlkc'] = [0.8, 1.0, 1.2]
	params['ihlke'] = [-66, -68, -70, -72, -74, -76]
	params['axonNa'] = [1, 3, 5, 7, 9, 11]

- find balance:
-- ihGbar inc -> fI dec, spk inc => 1.0 for fI, inc up to 2.0 in sims for spk)
-- ihGbarBasal inc -> fI dec, spk inc (stronger for fI?) => ? 0.1 easier to justify?
-- axonNa inc -> fI dec, spk dec (but threshold where inverts, ~5) => 5 (maybe 4?)
-- ihlkc inc -> fI dec, spk inc (stronger for spk) => 1.2 ?
-- ihlke inc -> fI inc, spk dec => -72

** v43_batch4 - long stim + ih - params from v43_batch2+3 + v42_batch29
comet  - rerunning
error due to plotTraces[pop,0) -> fixed manually on comet

params['ihGbarBasal'] = 0.01
params['ihlkc'] = 1.2
params['ihlke'] = -72
params['axonNa'] = 5 #11

params[('IEweights',0)] =  1.0
params[('IIweights',0)] = 1.2
# L5
params[('IEweights',1)] = 1.2
params[IPTGain,1] = 2.0
params['weightNormThreshold'] = 4.0
# L6
params[('IEweights',2)] = 1.2
params[('IIweights',2)] = 1.0

  params['ihGbar'] = [0.0, 1.0, 2.0]
  params[('pulse',0)] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']
  params[('pulse',3)] = [20, 30]

- looks good - more activity in IT2; osc in all layers; osc in PT as result of stim
- most PT depol block
** v43_batch5 - local stim + ih- params from v43_batch2+3 + v42_batch29

comet -
error due to plotTraces[pop,0) -> fixed manually on comet

params['ihGbarBasal'] = 0.01
params['ihlkc'] = 1.2
params['ihlke'] = -72
params['axonNa'] = 5 #11

params[('IEweights',0)] =  1.0
params[('IIweights',0)] = 1.2
# L5
params[('IEweights',1)] = 1.2
params[IPTGain,1] = 2.0
params['weightNormThreshold'] = 4.0
# L6
params[('IEweights',2)] = 1.2
params[('IIweights',2)] = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
  	params[('NetStim1','pop')] = ['IT2','IT4','IT5A','IT5B','PT5B','IT6','CT6']
	params[('NetStim1','interval')] = [1000.0/20.0, 1000.0/30.0]

- netstim number = 1, so small effect
- repeat with ihLkcBasal = 0.01 - v44_batch6

** v43_manualTune
   improve fI curve
tune1 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 28hz
tune2 - ihGbar=0.5, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 30hz
tune3 - ihGbar=1.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 29hz
tune4 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.0, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 29hz
tune5 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 32hz
tune6 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.5, axonNa = 11, axonRa = 0.005 -> 27Hz
tune8 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.1, axonNa = 11, axonRa = 0.005 -> 29Hz
tune7 - ihGbar=0.5, ihGbarBasal=0.01, ihlkc=1.0, ihlke = -70, dendNa = 0.25, axonNa = 11, axonRa = 0.005 -> 32hz
tune9 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.1, axonNa = 11*0.5, axonRa = 0.005 -> 30Hz
tune10 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005/10 -> 28Hz
tune11 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 37Hz
tune12 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 55Hz (netstim)
tune13 - ihGbar=0.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 63Hz (netstim)
tune14 - ihGbar=2.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 43Hz (netstim)
tune15 - ihGbar=2.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 32Hz
tune16 - ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 35Hz
tune17 - ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005 -> 46Hz (netstim)

subthreshold IClamp
tune18 - ihGbar=1.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005,-0.1nA -> -4.5mV
tune19 - ihGbar=1.0, kole, dendNa = 0.25, axonNa = 11, axonRa = 0.005, -0.1nA -> -8mV
tune20 - ihGbar=1.0, kole, dendNa = 1, axonNa = 1, axonRa = 1, -0.1nA -> -8mV
tune21 - ihGbar=1.0, ihGbarBasal=1.0, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005, -0.1nA-> -3mV
tune22 - ihGbar=2.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005, -0.1nA -> -4mV
tune23 - ihGbar=2.0, ihGbarBasal=0.1, ihlkc=1.2, ihlke = -75, dendNa = 0.25, axonNa = 11, axonRa = 0.005, 0.1nA -> +4.5mV
tune24 - ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke = -70, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005, 0.1 -> +4.5mV

sheets fig 7
tune25 - w=0.25 * 7.5e-3, syntau=0.5, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.0, ihlke=-70 -> 1.08
tune26 - w=7.5e-3, syntau=0.5, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.0, ihlke=-70 -> 1.08
tune27 - w=0.75*7.5e-3, syntau=1.0, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.0, ihlke=-70 -> 1.09
tune28 - w=0.75*7.5e-3, syntau=0.25, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.0, ihlke=-70 -> 1.07
tune28 - w=0.75*7.5e-3, syntau=0.25, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.0, ihlke=-70-> 1.07
tune29 - w=0.75*7.5e-3, syntau=0.25, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=1.0, ihlke=-70-> 1.07
tune30 - w=0.75*7.5e-3, syntau=0.25, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=0.0, ihlke=-70-> 1.07 (PTih dropped drastically!)
note: ih params not changing the zd cell!
tune31 - w=0.75*7.5e-3, syntau=2.0, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke=-75-> 1.12
tune32 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke=-75-> 1.22, 1.04
tune33 - w=0.25*7.5e-3, syntau=3.0, ihGbar=1.0, ihGbarBasal=0.01, ihlkc=1.2, ihlke=-75-> 1.22, 1.05
tune34 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=1.2, ihlke=-75-> 1.22, 1.01 - great
tune35 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=0.6, ihlke=-75-> 1.22,0.99
tune36 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=0.3, ihlke=-75-> 1.22,0.98
tune37 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=0.9, ihlke=-75-> 1.22,0.96
tune38 - w=0.25*7.5e-3, syntau=3.0, ihGbar=1.0, ihGbarBasal=1.0, ihlkc=0.6, ihlke=-75-> 1.22,1.01 (fast dec)
tune39 - w=0.25*7.5e-3, syntau=3.0, ihGbar=2.0, ihGbarBasal=0.01, ihlkc=0.6, ihlke=-75-> 1.22, 1.04
tune40 - w=0.25*7.5e-3, syntau=4.0, ihGbar=2.0, ihGbarBasal=1.0, ihlkc=0.6, ihlke=-75-> 1.28, 1.04
to lower ihGbarBasal need lower ihlkc

test effect of exctaufactor and cfg.ihLkcBasal
ihGbar=2.0, ihGbarBasal=0.01, ihlkc=1.2, ihLkcBasal=1.2, ihlke = -72, dendNa = 0.25, axonNa = 11*0.5, axonRa = 0.005,
iclamp=0.6, w=5e-4, alldend, noise=0.5, excTau2Factor = 0.5
tune41 -> 31 hz, -68.33
tune42 - apicdend, ihGbar=2.0 -> 31, -73.57
tune43 - apicdend, ihGbar = 0.0 -> 32 hz, -80.88
tune44 - apicdend, exctau=2.0, ihGbar=2.0-> 31 hz, -69.60
tune45 - apicdend, exctau=2.0, ihGbar=0.0-> 33 hz, -68.63 -> greaat! (exctau works)
tune46 - apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0 -> 0.0, -68.87
tune47 - apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 1.2*0.01 -> 33, -67.01 -> great!!
tune48 - alldend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 1.2*0.01 -> 33, -57.29
tune49 - alldend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 1.2 -> 0.0, -62.98
tune50 - alldend, exctau=2.0, ihGbar=2.0, ihGbarBasal=0.01,ihLkcBasal = 1.2 -> 31, -59.33
tune51 - alldend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 1.2 -> 34, -58.93 - great!! (even if alldend!)

** v43_batch7 - ih mig sheets fig 4
   on zn

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 2.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 0.01 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.removeNa = True #False  # simulate TTX; set gnabar=0s

cfg.dendNa = 0.25
cfg.axonNa = 11*0.5
cfg.axonRa = 0.005


   	params['ihX'] = range(8)
	params['ihY'] = range(24)
	params['groupWeight'] = [x*7.5e-3/5.0 for x in [0.1, 0.2, 0.3, 0.4, 0.6, 0.8, 1.0, 1.5, 2.0]]
	params['ihGbar'] = [0.0, 1.0, 1.5, 2.0]

NOTE: requires:
- fixing cell x,y pos: popParams ... , 'xRange':[100,100],'yRange':[735,735]}
- cellRule['secs']['apic_0']['weightNorm'] = [1e-6]

** v43_batch8 - PT ih fI curve, ihLkBasal
   repeat v43_batch2+3 with ihLkcBasal, exctau

params['ihGbarBasal'] = 1.0
cfg.axonNa = 5
dendNa = 0.25

	params[('IClamp1', 'amp')] = [0.3,0.6]
	params['ihGbar'] = [0.5, 1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2]
	params['ihlke'] = [-66, -68, -70, -72, -74, -76]
	params['ihLkcBasal'] = [0.0, 0.01, 0.1, 0.5, 1.0]

ihGbar = 1.0, ihlkc=1.2, ihlke=-72, ihlkcBasal=0.01 -> 0.6amp ~= 37

** v43_batch9 - PT ih epsps, ihLkcBasal
on zn
repeat v43_batch2+3 with ihLkcBasal, exctau

params['ihGbarBasal'] = 1.0
cfg.axonNa = 5
dendNa = 0.25
alldend !!

	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2]
	params['ihlke'] = [-66, -68, -70, -72, -74, -76]
	params['ihLkcBasal'] = [0.0, 0.01, 0.1, 0.5, 1.0]
	params['excTau2Factor'] = [0.5, 1.0, 2.0, 3.0]

- ihlke == -72 or -76 and ihlkc==1.2
-- no reversal; spiking early

** v44_batch1 - long stim + ih with ihLkcBasal - depol

- rerun on cm - plotTraces bug

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5   # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005  # axon axial resist (reduced to compensate)


  params['ihGbar'] = [0.0, 1.0, 2.0]
  params[('pulse','pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']
  params[('pulse','interval')] = [20, 30]
  params['AMPATau2Factor'] = [1.0, 1.5, 2.0, 3.0]

- pulse rate not having effect since used 'interval' - by default = 30hz
- that might explain why depol!
- rerun with 20 hz
*** results
None
- ih no sig diff
- PT depol block in ih=2.0; rest ok
- nice oscillations in most layers
- PSD beta peak for IT
- granger strong IT2<->IT5A

TPO
*- small diff in PT with high ih (when zoom quite small)
*- L2/3 -> PT5B example
- IT5A+PT5B depol block

TVL
- IT5A+PT5B depol block

S1
- IT5A+PT5B depol block

S2
- IT5A+PT5B depol block

M2
- weird behavior - PT gets inhibited by strong L5/L6 IT?
- IT5A+PT5B depol block

OC
- IT5A+PT5B depol block


*** to do
- spikeHist replot with diff freq -- too many osc/ripples

** v44_batch2 - PT ih netstim spks, ihLkcBasal, excTau2Factor
on zn

	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.5, 1.0, 2.0]
	params['ihlkc'] = [0.8, 1.0, 1.2]
	params['ihlke'] = [-68, -70, -72, -74, -76]
	params['ihLkcBasal'] = [0.0, 0.01, 0.1, 0.5, 1.0]
	params['excTau2Factor'] = [0.5, 1.0, 2.0, 3.0]

- excTau2Factor leads to earlier dep block at high weights
- ihlkcbasal increases diff between ih and no ih (but of course messes up fI curve)

** v44_batch3 - IE, II balance (with mig ih + params from v43_batch8+9)
bridges -rerunning - not working
comet -reran
manually fixed batch -> hpc_slurm_comet

ihGbar = 1.0, ihlkc=1.2, ihlke=-72, ihlkcBasal=0.01


	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1

*** results
with depol block (38/128):
0000000
0000001
0000010
0000011
0000100
0000101
0000110
0000111
0001010
0001011
0001110
0001111
0010010
0010110
0011010
0011110
0100000
0100001
0100010
0100010
0100011
0100100
0100101
0100110
0100110
0101000
0101001
0101010
0101011
0101100
0101101
0101110
0101111
0110010
0110011
0110110
0111010
0111110
1101000

- note this is for no stim, so even if no depol block, might have depol block when stim, which is what happened with
  v44_batch1 (corresponds to 1110111)
- repeat with stim ?

** v44_batch4 - PT ih epsps, params from v43_batch8
by mistake ran as batch1 - renamed folder!

ihGbar = 1.0, ihlkc=1.2, ihlke=-72, ihlkcBasal=0.01

  params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
  params['ihGbar'] = [0.0, 1.0, 2.0]

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170712_185117.png][fig]] - almost but not enough - maybe try increasing excTau2 ?

** v44_batch5 - PT ih epsps, params from v43_batch8, with excTau2=3.0

params['excTau2Factor'] = 3.0
  params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
  params['ihGbar'] = [0.0, 1.0, 2.0]

- ih start spiking sooner

** v44_batch6 - local stim + ih- params from v43_batch2+3 + v42_batch29, ihLkcBasal - rerun

comet -
error due to plotTraces[pop,0) -> fixed manually on comet

params['ihLkcBasal'] = 0.01
params['ihlkc'] = 1.2
params['ihlke'] = -72
params['axonNa'] = 5 #11

params[('IEweights',0)] =  1.0
params[('IIweights',0)] = 1.2
# L5
params[('IEweights',1)] = 1.2
params[IPTGain,1] = 2.0
params['weightNormThreshold'] = 4.0
# L6
params[('IEweights',2)] = 1.2
params[('IIweights',2)] = 1.0

netstim number = 10

	params['ihGbar'] = [0.0, 1.0, 2.0]
  	params[('NetStim1','pop')] = ['IT2','IT4','IT5A','IT5B','PT5B','IT6','CT6']
	params[('NetStim1','interval')] = [1000.0/20.0, 1000.0/30.0]

- increase num netstims or weight -- otherwise just small EPSP

** v44_batch7 - PT ih epsps, params from v44_tune18 (george/mig fig)
w=20, noise=0.4, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.78

  params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
  params['ihGbar'] = [0.0, 1.0, 2.0]

- ih start spiking sooner
** v44_batch8 - PT fI curve, ih ihkcBasal
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25
cfg.axonNa = 5 #11*0.5
cfg.axonRa = 0.005


	params[('IClamp1', 'amp')] = list(np.arange(-2.0, 6.5, 0.5)/10.0)
	params['ihGbar'] = [0.0, 0.5, 1.0, 1.5, 2.0]

** v44_batch9 - PT fI curve, ihlkcBasal, explore pas g+e (wrong direction)
	params[('IClamp1', 'amp')] = list(np.arange(-2.0, 6.5, 0.5)/10.0)s
	params['pasg'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]
	params['pase'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- should have decreased, not increased! - v44_batch13

- any increase of pase>1.0, increases rheobase > 0.45
- min rheobase is with pase=1.0 = 0.45
- pasg doesn't reduce rheobase for pase=1.0

** v44_batch10 - PT EPSP (George), ihlkcBasal, explore pas g+e (wrong direction)
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['pasg'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]
	params['pase'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- pasg should decrease - v44_batch14

** v44_batch11 - IE, II balance, S2 input, ihlkcBasal (50x50 um!)
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.0

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1

-- check depol

- redo full size in v44_batch15

** v44_batch12 - long stim + ih with ihLkcBasal (20hz) (50x50 um!)
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']

- redo full size in v44_batch16

** v44_batch13 - PT fI curve, ihlkcBasal, explore pas g+e
	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	params['gpas'] = [1.0, 0.95, 0.9, 0.85, 0.8, 0.75]
	params['epas'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- 0.8 has 0.4 rheobase and linear curve - similar to exp - great!

** v44_batch14 - PT EPSP (George), ihlkcBasal, explore pas g+e
- repeating with weightnorm=False


	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['gpas'] = [1.0, 0.95, 0.9, 0.85, 0.8, 0.75]
	params['epas'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- gpas < 1.0 (including 0.8) still shows reversal effect!! actually increases effect
- check if something else messed up... RMP? spike amp? - all looks ok
- great!

** v44_batch15 - IE, II balance, S2 input, ihlkcBasal
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1

-- check depol

*** results
- no depol:
1000010 - ok but IT2 low
1000101 (low amp spks - 0mV) - ok
1001010 (low amp spks) - IT5A depol
1001110 - ok
1010001 (low amp) - ok but IT2 low
1011010 - ok
1111110 - ok

*** 3 good options
current: 1110111

options 1 - 1001110:
	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1


options 2 - 1011010:
	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 3.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1


options 3 - 1111110:
	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 1.0 # [0.8, 1.0]  # 1.0 , 1

** v44_batch16 - long stim + ih with ihLkcBasal (20hz)
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']

- still depol block
- prob due to lower axonNa
- check its 20 hz - yes

** v44_batch17 - PT fI curve, ihlkcBasal, explore lower pas g+e
zn
	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	params['gpas'] = [1.0, 0.7, 0.65, 0.6, 0.55, 0.5]
	params['epas'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

*** gpas=0.6, epas= 1.0 seems like good compromise for rheobase:
-- rheobase 0.3-0.35 (vs 0.25-0.3)
-- 0.4nA -> ~17hz (vs ~19hz)
-- 0.5nA -> ~33hz (vs ~28hz)
-- 0.6nA -> ~46hz (vs ~ 38hz)

- note RMP = -74 (vs -80)  (affected by new ih lke)
- how to lower RMP but keeping fI curve?
-- lower ihGbar and inc epas?

*** gpas=0.7, epas=1.0 also ok'ish:
-- rheobase 0.35-0.4 (vs 0.25-0.3)
-- 0.4nA -> ~13hz (vs ~19hz)
-- 0.5nA -> ~30hz (vs ~28hz)
-- 0.6nA -> ~45hz (vs ~ 38hz)

*** gpas=0.8, epas=1.0 - better match of high nA:
-- rheobase 0.35-0.4 (vs 0.25-0.3)
-- 0.4nA -> ~12hz (vs ~19hz)
-- 0.5nA -> ~29hz (vs ~28hz)
-- 0.6nA -> ~44hz (vs ~ 38hz)

** v44_batch18 - PT EPSP (George), ihlkcBasal, explore lowe pas g+e
zn
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['gpas'] = [1.0, 0.7, 0.65, 0.6, 0.55, 0.5]
	params['epas'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- reversal ok
- with lower gpas, get zd spikes sooner - great

** v44_batch19 - long stim + ih, gpas=0.8, EI v44_batch15 (1001110) - BUG! (low PT, depol)
bug: axonRa=0.05

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 0.8
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

*** results
None, ih0 - very low PT rate
TPO, ih0 - very low PT rate, PT+IT5A depol block
TVL, ih0 - very low PT rate, PT+IT5A depol block
S1, ih0 - very low PT rate, PT+IT5A depol block
S2, ih0 - very low PT rate, PT+IT5A depol block
M2, ih0 - very low PT rate
OC, ih0 - very low PT rate, PT+IT5A depol block

None, ih1 - very low PT rate, PT+IT5A depol block
TPO, ih1 - very low PT rate, PT+IT5A depol block
TVL, ih1 - very low PT rate, PT+IT5A depol block
S1, ih1 - very low PT rate, PT+IT5A depol block
S2, ih1 - very low PT rate, PT+IT5A depol block
M2, ih1 - very low PT rate
OC, ih1 - very low PT rate, PT+IT5A depol block

** v44_batch20 - long stim + ih, gpas=0.8, EI v44_batch15 (1011010) - BUG!
   bug: axonRa=0.05 + wrong IE params?

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 3.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 0.8
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

*** results
None, ih0 - very low PT rate
TPO, ih0 - very low PT rate, PT+IT5A depol block
TVL, ih0 - very low PT rate, PT+IT5A depol block
S1, ih0 - very low PT rate, PT+IT5A depol block
S2, ih0 - very low PT rate, PT+IT5A depol block
M2, ih0 - very low PT rate
OC, ih0 - very low PT rate, PT+IT5A depol block

None, ih1 - very low PT rate, PT+IT5A depol block
TPO, ih1 - very low PT rate, PT+IT5A depol block
TVL, ih1 - very low PT rate, PT+IT5A depol block
S1, ih1 - very low PT rate, PT+IT5A depol block
S2, ih1 - very low PT rate, PT+IT5A depol block
M2, ih1 - very low PT rate
OC, ih1 - very low PT rate, PT+IT5A depol block

** v44_batch21 - long stim + ih, gpas=0.8, EI v44_batch15 (1111110) - BUG!
bug: axonRa=0.05 + wrong IE params¿

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 1.0 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 0.8
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

- PT too low + depol block




*** v44_manualTune
tune1 - w=20, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.817
tune2 - w=20, apicdend, exctau=2.0, ihGbar=1.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk
tune3 - w=20, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.22
tune4 - w=20, apicdend, exctau=3.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk
tune5 - w=20, noise=0.3, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -58.42
tune6 - w=20, noise=0.3, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -57.21 - ok but small diff
tune7 - w=25, noise=0.3, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.24
tune8 - w=25, noise=0.3, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.33
tune13 - w=20, noise=0.4, apicdend, exctau=.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -66.58
tune14 - w=20, noise=0.4, apicdend, exctau=.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -70.16
tune15 - w=20, noise=0.4, apicdend, exctau=1.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -63.10
tune16 - w=20, noise=0.4, apicdend, exctau=1.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -62.19
tune17 - w=20, noise=0.4, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -59.47
tune18 - w=20, noise=0.4, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.78
tune19 - w=20, noise=0.4, apicdend, exctau=2.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -58.382
tune20 - w=20, noise=0.4, apicdend, exctau=2.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk

check spks 'numStims': int(8*16*100*0.07), noise=0.5
tune8 - w=5, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 24
tune9 - w=5, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 31
tune10 - w=10, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> dep block
tune11 - w=20, apicdend, exctau=0.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 30
tune12 - w=20, apicdend, exctau=0.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 41

sheets fig 8 - temp sum from L2/3, num=100, alldend
tune21 - w=0.1 wnorm, noise=0.2, allcdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune22 - w=0.1 wnorm, noise=0.2, alldend, exctau=2.0, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune23 - w=0.1 wnorm, noise=0.2, alldend, exctau=1.0, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune25 - w=0.1 wnorm, noise=0.2, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune26 - w=0.1 wnorm, noise=0.1, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune27 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune28 - w=0.1 wnorm, noise=0.15, apicdend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune29 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune30 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.01, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune31 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune32 - w=0.1 wnorm, num=120, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune33 - w=0.12 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune34 - w=0.1 wnorm, num=120, noise=0.2, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune35 - w=0.1 wnorm, num=120, noise=0.12, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01

sheets fig 9 -coinc detec, delay=50
tune36 - w=0.2 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune37 - w=0.2 wnorm, num=100, noise=0.3, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune38 - w=0.4 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune39 - w=0.4 wnorm, num=100, noise=0.3, alldend, exctau=1.0, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune40 - w=0.4 wnorm, num=100, noise=0.15, alldend, exctau=0.3, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune41 - w=0.4 wnorm, num=100, noise=0.3, alldend, exctau=0.4, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune42 - w=0.4 wnorm, num=100, noise=0.25, alldend, exctau=0.3, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune43 - w=0.4 wnorm, num=100, noise=0.25, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune44 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune45 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune46 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune47 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01

sheets fig 11 -coinc detec, delay=50
tune48 - w=0.1 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune49 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune50 - w=0.4 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune51 - w=0.4 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune52 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune53,54 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.0, ihGbarBasal=1.0, ihLkcBasal=0.01

** v44_batch22 - PT fI curve, ihlkcBasal, explore lower pas g+e
zn
	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	params['ihGbar'] = [0.0, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
	params['gpas'] = [1.0, 0.7, 0.65, 0.6, 0.55, 0.5]
	params['epas'] = [1.0, 1.05, 1.1, 1.15, 1.2, 1.25]

- lower RMP with same fI curve? by lowering ihGbar?
- 1.0->0.8 ihgbar ==> <1mv RMP

** v44_batch23 - IE, II balance, S2 input, ihlkcBasal, PT gpas=0.8 - BUG!
bug: axonRa=0.05

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005

cfg.gpas = 0.8

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1

- ALL so far PT low rate and depol block - surprising gpas has such an effect!
- still waiting for ~60 sims

** v44_batch24 - long stim + ih, gpas=1.0, EI v44_batch15 (1111110) - BUG!
bug: axonRa = 0.05
bug setting batch params - rerun

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 1.0 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 1.0
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

- according to v44_batch15 this should produce reasonable non dep block PT rates
- however when ran with gpas=0.8, PT was ~silent or depol block
- when testing in manualTune the difference between gpas=0.8 vs 0.1 increased depol but only by small amount
- this sim also makes sure no other params changed

** v44_batch25 - long stim + ih, gpas=1.0, EI v44_batch15 (1001110) - BUG!
bug setting batch params - rerun
bug: axonRa=0.05

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 0.8
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

** v44_batch26 - long stim + ih, gpas=1.0, EI v44_batch15 (1011010) - BUG!
bug setting batch params - rerun

	params[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = 1.2 # [1.0, 1.2]   # 1.2 , 1
	params['IPTGain'] =       3.0 # [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = 3.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] = 0.8 # [0.8, 1.0]  # 1.0 , 1

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.05
cfg.gpas = 0.8
cfg.epas = 1.0

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

** v44_batch27 - calculate PT weightNorm with new ih, gpas=0.8, etc
- rerun due to bug on segs vs secs

	# Add params
	from cfg_cell import cfg
	from netParams_cell import netParams

	excludeSegs = ['axon']
	if not segs:
		secs = []
		locs = []
		for secName,sec in netParams.cellParams[rule]['secs'].iteritems():
			if secName not in excludeSegs:
				secs.append(secName)
				if allSegs:
					nseg = sec['geom']['nseg']
					for iseg in range(nseg):
						locs.append((iseg+1)*(1.0/(nseg+1)))
				else:
					locs.append(0.5)

	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1

b = weightNormE(pops=['PT5B'], rule='PT5B_full')

** v44_batch28 - IE, IE balance, no pulses, ihlkcBasal, PT gpas=0.8, wnorm
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005

cfg.gpas = 0.8

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1

*** results
note this is based on single pop example; others might have depol block
reasonable firing but no depol block:

ideal:
1000101

options:
1000000 *2
1000011
1000100 *1
1000110 *2
1000111 *1
1001000
1001010
1001011
1001100 *2
1001110
1001111
1011010
1100000
1100010
1100011
1100100
1101000
1101010
1101011
1101100
1101111
1110011
1110110
1111010

** v44_batch29 - IE, IE balance, S2 for 500ms, ihlkcBasal, PT gpas=0.8, wnorm - check

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 5 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005

cfg.gpas = 0.8


	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'end')] = 1500.0


	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0]  # 1.0 , 1
	params[('IIweights',0)] = [1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [2.0,3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	# L6
	params[('IEweights',2)] =  [1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0]  # 1.0 , 1
** v44_batch30 - long stim + ih, gpas=0.8, EI v44_batch28 (1000111) - canceled

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]


	# initial config
	initCfg = {}

	initCfg[('IEweights',0)] = 1.0 #  [0.8, 1.0]  # 1.0 , 1
	initCfg[('IIweights',0)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	# L5
	initCfg[('IEweights',1)] = 1.0 # [1.0, 1.2]   # 1.2 , 1
	initCfg['IPTGain'] =       2.0 # [2.0,3.0]          # 2.0 , 0
	initCfg['weightNormThreshold'] = 4.0 # [3.0, 4.0] # 4.0 , 1
	# L6
	initCfg[('IEweights',2)] = 1.2 #  [1.0, 1.2]  # 1.2 , 1
	initCfg[('IIweights',2)] = 1.0 # [0.8, 1.0]  # 1.0 , 1

	initCfg['ihModel'] = 'migliore'  # ih model
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 1.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -72  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 5 #11  # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.8
	initCfg['epas'] = 1.0

** v44_manualTune
tune1 - w=20, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.817
tune2 - w=20, apicdend, exctau=2.0, ihGbar=1.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk
tune3 - w=20, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.22
tune4 - w=20, apicdend, exctau=3.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk
tune5 - w=20, noise=0.3, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -58.42
tune6 - w=20, noise=0.3, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -57.21 - ok but small diff
tune7 - w=25, noise=0.3, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.24
tune8 - w=25, noise=0.3, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.33
tune13 - w=20, noise=0.4, apicdend, exctau=.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -66.58
tune14 - w=20, noise=0.4, apicdend, exctau=.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -70.16
tune15 - w=20, noise=0.4, apicdend, exctau=1.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -63.10
tune16 - w=20, noise=0.4, apicdend, exctau=1.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -62.19
tune17 - w=20, noise=0.4, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -59.47
tune18 - w=20, noise=0.4, apicdend, exctau=2.0, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -55.78
tune19 - w=20, noise=0.4, apicdend, exctau=2.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> -58.382
tune20 - w=20, noise=0.4, apicdend, exctau=2.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> spk

check spks 'numStims': int(8*16*100*0.07), noise=0.5
tune8 - w=5, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 24
tune9 - w=5, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 31
tune10 - w=10, apicdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> dep block
tune11 - w=20, apicdend, exctau=0.5, ihGbar=2.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 30
tune12 - w=20, apicdend, exctau=0.5, ihGbar=0.0, ihGbarBasal=1.0,ihLkcBasal = 0.01 -> 41

sheets fig 8 - temp sum from L2/3, num=100, alldend
tune21 - w=0.1 wnorm, noise=0.2, allcdend, exctau=2.0, ihGbar=2.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune22 - w=0.1 wnorm, noise=0.2, alldend, exctau=2.0, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune23 - w=0.1 wnorm, noise=0.2, alldend, exctau=1.0, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01
tune25 - w=0.1 wnorm, noise=0.2, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune26 - w=0.1 wnorm, noise=0.1, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune27 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune28 - w=0.1 wnorm, noise=0.15, apicdend, exctau=0.5, ihGbar=1.0, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune29 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune30 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.01, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune31 - w=0.1 wnorm, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01, iclamp=0.145
tune32 - w=0.1 wnorm, num=120, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune33 - w=0.12 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune34 - w=0.1 wnorm, num=120, noise=0.2, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune35 - w=0.1 wnorm, num=120, noise=0.12, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01

sheets fig 9 -coinc detec, delay=50
tune36 - w=0.2 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune37 - w=0.2 wnorm, num=100, noise=0.3, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune38 - w=0.4 wnorm, num=100, noise=0.15, alldend, exctau=0.5, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune39 - w=0.4 wnorm, num=100, noise=0.3, alldend, exctau=1.0, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune40 - w=0.4 wnorm, num=100, noise=0.15, alldend, exctau=0.3, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune41 - w=0.4 wnorm, num=100, noise=0.3, alldend, exctau=0.4, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune42 - w=0.4 wnorm, num=100, noise=0.25, alldend, exctau=0.3, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune43 - w=0.4 wnorm, num=100, noise=0.25, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune44 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune45 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.05, ihGbarBasal=1.0, ihLkcBasal=0.01
tune46 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.0, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune47 - w=0.4 wnorm, num=100, noise=0.2, alldend, exctau=0.25, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01

sheets fig 11 -coinc detec, delay=50
tune48 - w=0.1 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune49 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune50 - w=0.4 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=0.2, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune51 - w=0.4 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune52 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.1, ihGbarBasal=1.0, ihLkcBasal=0.01
tune53,54 - w=0.2 wnorm, num=(8*16*100*0.07), noise=0.5, alldend, exctau=1.0, ihGbar=1.5, ihGbarZD=0.0, ihGbarBasal=1.0, ihLkcBasal=0.01

checking response range of PT cell with gpas=0.8
56-62 - depol block with w=0.5; minor difference with gpas=0.8 vs 1.0
checked PT weightNorm
- with gpas=1.0:
-- soma, dend_1, dend_20, w=0.5 -> 0.41;
-- apic_20, w=0.5 -> 0.15
- with gpas=1.0:
-- soma, dend_20, w=0.5 -> 0.42;
-- apic_20, w=0.5 -> 0.17

check if can increase spk peak (currently <10mV) using dendNa withut messing too much with rest
tune70 - axonNa 5 -> 43 spk, 8mv
tune71 - axonNa 6 -> 41 spk, 10mv
tune72 - axonNa 7 -> 39 spk, 12mv
tune73,74 - axonNa 5, epsp spk -> ih=25.3hz, zd=34.6hz
tune75,76 - axonNa 6, epsp spk -> ih=24.667hz, zd=33.3hz
tune77 - axonNa 5, epsp w=0.5 -> 0.499
tune78 - axonNa 5, epsp w=0.5 -> 0.499

synMechWeightFactor fixed
- weightNorms still apply since were calculated for AMPA

** v45_batch1 - EI,II balance, fixed synMechWeighFactor, axonNa=6 (BUG!)
BUG: synMechWeightFactor wasn't implemented (netpyne v0.7.1 27a360)

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01 # multiplicative factor for ih lk in PT cells
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
cfg.axonNa = 6 #11  # axon Na conduct (increased to compensate)
cfg.axonRa = 0.005

cfg.gpas = 0.8

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'end')] = 1200.0

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]   # 1.2 , 1
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]   # 1.2 , 1
	params[IPTGain,1] = [1.0, 2.0, 3.0]          # 2.0 , 0
	params['weightNormThreshold'] = [3.0, 4.0] # 4.0 , 1
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]  # 1.2 , 1
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

*** results
candidates with Erange = [0.05,25] + Irange = [0.05,100] rates + no
IT5A,PT5B depol block:

ideal:
- 11 1 01 1 11
- 10 1 01 0 10 (II = 0.8)
- 01 0 01 1 01 (IE = 0.8
- 21 2 01 1 21 (IE = 1.2)

with IPTGain = 1.0; weightNormThreshold=4.0:
- 10 2 01 0 02 - no IT2
- 20 1 01 1 01 - good; maybe slightly high PT?; ah no IT2!
- 20 2 01 1 02 - no IT2
- 21 2 01 0 02 - no IT2

with IPTGain = 1.0; weightNormThreshold=3.0:
- 10200002 - no IT2
- 20200002 - no IT2
- 20200102 - no IT2
- 20200202 - no IT2
- 21200002 - no IT2

IT2 rate>0:
-*10 1 21 2 11 --> selected
- 21 0 21 1 00 - peaks
- 21 0 21 2 11 - peaks
- 21 0 21 2 22 - peaks
-*22 0 21 1 11 - peaks
- 22 0 21 1 12 - peaks

** v45_batch2 - PT fI curve, axonNa
	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['axonNa'] = [5, 6, 7]

axonNa rotates fI line clockwise, which is exactly what I needed!
so maybe if combine with lower gpas can get better match

** v45_batch3 - PT epsp, axonNa
	params['groupWeight'] = [x*1e-4 for x in np.arange(0.0, 21.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0, 2.0]
	params['axonNa'] = [5, 6, 7]

axonNa has ~no effect; but when epsp generates spks, inc axonNa dec diff between ih+zd spks (see v44_tine 73-75)

** v45_batch4 - PT fI curve, axonNa

	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	#params['ihGbar'] = [0.0, 1.0, 2.0]
	params['axonNa'] = [5, 6, 7, 8]
	params['gpas'] = [0.6, 0.65, 0.70, 0.75]
	params['epas'] = [1.0, 1.05]

	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['addIClamp'] = True
	initCfg['addNetStim'] = False
	initCfg[('analysis','plotTraces','timeRage')] = [0, 1500]

	groupedParams = []

- axonNa=7.0, gpas=0.65 -> very close to original fIcurve
** v45_batch5 -  PT epsp, axonNa, gpas, epas
	params['groupWeight'] = [x*1e-4 for x in np.arange(5.0, 26.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0]
	params['axonNa'] = [5, 6, 7, 8]
	params['gpas'] = [0.6, 0.65, 0.70, 0.75]
	params['epas'] = [1.0, 1.05]

	# initial config
	initCfg = {}
	initCfg['duration'] = 0.5*1e3
	initCfg['addIClamp'] = False
	initCfg['addNetStim'] = True
	initCfg[('analysis','plotTraces','timeRage')] = [0, 500]

** v45_batch6 - PT fI with latest tuned params from v45_tune91
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	params[('IClamp1', 'amp')] = list(np.arange(2.0, 6.5, 0.5)/10.0)
	params['ihGbar'] = [0.0, 1.0, 2.0]
	# params['axonNa'] = [5, 6, 7, 8]
	# params['gpas'] = [0.6, 0.65, 0.70, 0.75]
	# params['epas'] = [1.0, 1.05]
	# params['ihLkcBasal'] = [0.0, 0.01, 0.1, 0.5, 1.0]

	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['addIClamp'] = True
	initCfg['addNetStim'] = False
	initCfg[('IClamp1','sec')] = 'soma'
	initCfg[('IClamp1','loc')] = 0.5
	initCfg[('IClamp1','start')] = 500
	initCfg[('IClamp1','dur')] = 1000
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1500]

** v45_batch7 - PT epsp with latest tuned params from v45_tune91
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	params['groupWeight'] = [x*1e-4 for x in np.arange(2.5, 30.0, 2.5)]
	params['ihGbar'] = [0.0, 1.0]


	# initial config
	initCfg = {}
	initCfg['duration'] = 0.5*1e3
	initCfg['addIClamp'] = False
	initCfg['addNetStim'] = True
	initCfg[('GroupNetStimW1', 'pop')] = 'PT5B'
	initCfg[('NetStim1', 'pop')] = 'None'
	initCfg[('analysis','plotTraces','timeRange')] = [0, 500]
	initCfg['excTau2Factor'] = 2.0
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg['ihGbarZD'] = None
** v45_batch8 - PT wnorm with latest tuned params from v45_tune91 - check!!
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	# Add params
	from cfg_cell import cfg
	from netParams_cell import netParams

	excludeSegs = ['axon']
	if not segs:
		secs = []
		locs = []
		for secName,sec in netParams.cellParams[rule]['secs'].iteritems():
			if secName not in excludeSegs:
				if allSegs:
					nseg = sec['geom']['nseg']
					for iseg in range(nseg):
						secs.append(secName)
						locs.append((iseg+1)*(1.0/(nseg+1)))
				else:
					secs.append(secName)
					locs.append(0.5)

	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg['synMechWeightFactor'] = [1.0,0.1]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	initCfg[('GroupNetStimW1', 'pop')] = 'None'

- all epsps = 0.514 -- not sure why?!

** v45_batch9 - PT epsp (new weights) with latest tuned params from v45_tune91

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells


	params['groupWeight'] = [x*0.1 for x in np.arange(1, 11, 1)]
	params['ihGbar'] = [0.0, 1.0]


	# initial config
	initCfg = {}
	initCfg['duration'] = 0.5*1e3
	initCfg['addIClamp'] = False
	initCfg['addNetStim'] = True
	initCfg[('GroupNetStimW1', 'pop')] = 'PT5B'
	initCfg[('NetStim1', 'pop')] = 'None'
	initCfg[('analysis','plotTraces','timeRange')] = [0, 500]
	initCfg['excTau2Factor'] = 2.0
	initCfg['weightNorm'] = True
	initCfg['stimSubConn'] = False
	initCfg['ihGbarZD'] = None

*** results
great reversal 0.3; ranges -80 to .60 mV; after 0.8 ZD= spks

** v45_manualTune
tune1 - axonNa=5, epsp 75 -> -67
tune2 - axonNa=7, epsp 75 -> -67

tune5,6- 7, 0.65 -> 34-25-21hz (36%, 61%) - not so great, but ok!
tune7,8- 5, 1.0 -> 30-21-15hz (43%, 100%)

tune10,11 - 7, 0.65 -> -59 to -54mV -- great!

*** tune12-140 - sheets fig11 with retuned PT
tune11:
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01
cfg.ihlke = -72  # ih leak param (used in Migliore)
cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.25
cfg.axonNa = 7
cfg.axonRa = 0.005
cfg.gpas = 0.65  # multiplicative factor for pas g in PT cells
cfg.epas = 1.0  # multiplicative factor for pas e in PT cells

cfg.GroupNetStimEPT = {'nstype': 'pop', 'numStims': int(8*16*100*0.07), 'pop': 'PT5B', 'cellRule': 'PT5B_full', 'secList':
'alldend', 'allSegs': True, 'synMech': ['exc'], 'start': 500, 'interval': 1000/20.0, 'noise': 0.5, 'number':
cfg.groupRate*2.1, 'weight': 0.2, 'delay': 0}

cfg.excTau2Factor = 1.0

fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 38.00 - 50.00

tune12: cfg.ihlke = -74
fI 0.35-0.6nA: 3.00 - 40.00
stim ih-zd   : 37.00 - 50.00

tune13: cfg.ihlkc = 1.4
fI 0.35-0.6nA: 5.00 - 41.00
stim ih-zd   : 37.00 - 50.00

tune14: cfg.ihlke = -80
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 32.00 - 50.00

tune15: cfg.ihlkc = 1.8
fI 0.35-0.6nA: 0.00 - 39.00
stim ih-zd   : 35.00 - 50.00

tune16: cfg.ihGbarBasal = 1.5
fI 0.35-0.6nA: 11.00 - 42.00
stim ih-zd   : 39.00 - 50.00

tune17: cfg.ihLkcBasal = 0.1
fI 0.35-0.6nA: 5.00 - 40.00
stim ih-zd   : 38.00 - 50.00

tune18: basaldend
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 75.00 - 74.00

tune19: apicdend
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 2.00 - 19.00

tune20: basaldend + ihGbarBasal=1.5
fI 0.35-0.6nA: 11.00 - 42.00
stim ih-zd   : 75.00 - 74.00

tune21: basaldend + ihlkcBasal=0.1
fI 0.35-0.6nA: 5.00 - 40.00
stim ih-zd   : 73.00 - 74.00

tune22: basaldend + ihlkcBasal=0.5
fI 0.35-0.6nA: 0.00 - 35.00
stim ih-zd   : 66.00 - 74.00

tune23: basaldend + ihlkcBasal=1.0 (because of ih exp dist)
fI 0.35-0.6nA: 0.00 - 28.00
stim ih-zd   : 58.00 - 74.00

tune24: subconn L2/3->PT
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 67.00 - 75.00

tune25: subconn L2/3->PT + cfg.ihLkcBasal = 1.0
fI 0.35-0.6nA: 0.00 - 28.00
stim ih-zd   : 52.00 - 75.00

tune26: subconn L2/3->PT, rate=40
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 3.00 - 5.00 (dep block)

tune27: subconn L2/3->PT, rate=10
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 23.00 - 32.00

tune28: basaldend, rate=10
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 27.00 - 20.00

most syns in main trunk -- between soma and nexus (apic, some dend)
currently, soma=basal=oblique=h_gbar=6e-5
- increase ih in main trunk

tune29: subconn L2/3->PT, rate=10, 2*h_lambda:
fI 0.35-0.6nA: 13.00 - 43.00
stim ih-zd   : 27.00 - 32.00

tune30: subconn L2/3->PT, rate=10, 0.5*h_lambda:
fI 0.35-0.6nA: 0.00 - 35.00
stim ih-zd   : 2.00 - 32.00

tune31: subconn L2/3->PT, rate=10, 0.6*h_lambda:
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 13.00 - 32.00

tune32: subconn L2/3->PT, rate=10, 0.7*h_lambda:
fI 0.35-0.6nA: 0.00 - 39.00
stim ih-zd   : 17.00 - 32.00

tune33: subconn L2/3->PT, rate=10, 0.8*h_lambda:
fI 0.35-0.6nA: 4.00 - 40.00
stim ih-zd   : 19.00 - 32.00

tune34: subconn L2/3->PT, rate=10, 0.9*h_lambda:
fI 0.35-0.6nA: 7.00 - 41.00
stim ih-zd   : 21.00 - 32.00

tune35: subconn L2/3->PT, rate=10, trunk 2*dist:
fI 0.35-0.6nA: 10.00 - 42.00
stim ih-zd   : 23.00 - 32.00

- increase ih for maintrunk + oblique

tune36: subconn L2/3->PT, rate=10, mig dist, slope=14
fI 0.35-0.6nA: 9.00 - 41.00
stim ih-zd   : 17.00 - 32.00

tune37: subconn L2/3->PT, rate=10, mig dist, slope=42
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 1.00 - 32.0

tune38: subconn L2/3->PT, rate=10, mig dist, slope=28
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 9.00 - 32.00

tune39: subconn L2/3->PT, rate=20, mig dist, slope=28
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 53.00 - 75.00

tune40: subconn L2/3->PT, rate=10, mig dist, slope=28, cfg.ihGbarBasal = 0.5
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 8.00 - 32.00

tune41: subconn L2/3->PT, rate=20, mig dist, slope=28, ihgbar=2.0
fI 0.35-0.6nA: 0.00 - 35.00
stim ih-zd   : 44.00 - 75.00

tune42: subconn L2/3->PT, rate=20, mig dist, slope=28, ihlke=-70 - good!
fI 0.35-0.6nA: 5.00 - 41.00
stim ih-zd   : 55.00 - 75.00

tune43: subconn L2/3->PT, rate=20, mig dist, slope=28, cfg.ihLkcBasal = 1.0
fI 0.35-0.6nA: 0.00 - 25.00
stim ih-zd   : 37.00 - 75.00

tune44: subconn L2/3->PT, rate=20, mig dist, slope=28, cfg.ihlkc=1.0 - not bad
fI 0.35-0.6nA: 1.00 - 40.00
stim ih-zd   : 55.00 - 75.00

tune45: subconn L2/3->PT, rate=20, mig dist, slope=28, cfg.ihlkc=0.9
fI 0.35-0.6nA: 3.00 - 40.00
stim ih-zd   : 56.00 - 75.00

tune46: subconn L2/3->PT, rate=20, mig dist, slope=35, cfg.ihlkc=0.9
fI 0.35-0.6nA: 0.00 - 39.00
stim ih-zd   : 53.00 - 75.00

tune47: subconn L2/3->PT, rate=10, mig dist, slope=28, cfg.ihlkc=0.9
fI 0.35-0.6nA: 3.00 - 40.00
stim ih-zd   : 14.00 - 32.00
Note: if start at 1 sec instead of 500ms: 14-21Hz; if add 300 epsp: 14-25hz
(maybe diffs only sig for small t) --> 10 sec: 15-38hz

tune48: subconn L2/3->PT, rate=10, mig dist, slope=35, cfg.ihlkc=0.9
fI 0.35-0.6nA: 0.00 - 39.00
stim ih-zd   : 10.00 - 32.00
weight ih-zd : -65.70 - -57.32 (8.38)

- make basal=below soma (y coord) ??
tune49: subconn L2/3->PT, rate=10, mig dist, slope=28, cfg.ihlkc=0.9, below_soma
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 9.00 - 32.00 (23.00)

DEFAULT NOW IS: subconn L2/3->PT, rate=10, mig dist, slope=28, cfg.ihlkc=0.9, below_soma
- test:
-- cfg.dendNa = 0.25 -- maybe increase just in soma?
-- cfg.axonNa = 7
-- cfg.axonRa = 0.005

tune50: cfg.dendNa=0.3
fI 0.35-0.6nA: 0.00 - 37.00
stim ih-zd   : 11.00 - 32.00 (21.00)

tune51: cfg.dendNa=0.2
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 7.00 - 30.00 (23.00)

tune52: cfg.axonNa=6, dendNa=0.5?
fI 0.35-0.6nA: 0.00 - 36.00
stim ih-zd   : 11.00 - 39.00 (28.00)

tune53: cfg.axonNa=8, dendNa=0.5?
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 14.00 - 37.00 (23.00) - good

tune54: nax_gbar_somam = 1.5, dendNa=0.5?
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 13.00 - 38.00 (25.00)

tune55: axonRa= 0.0025, dendNa=0.5?
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 13.00 - 38.00 (25.00)

tune56: axonRa= 0.01, dendNa=0.5?
fI 0.35-0.6nA: 0.00 - 35.00
stim ih-zd   : 13.00 - 37.00 (24.00)

tune57: epas=1.05, dendNa=0.5?
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 11.00 - 36.00 (25.00)
minV: -72.8 vs -91.3

tune58: epas=0.95, dendNa=0.5?
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 14.00 - 41.00 (27.00) - great!!
minV: -72.3 vs -88

tune59 (actually 58; overwrote prev): epas=0.90, dendNa=0.5
fI 0.35-0.6nA: 10.00 - 38.00
stim ih-zd   : 15.00 - 45.00 (30.00) (with peak=12mV; RMP too high) - fantastic!!
minV: -71 vs -84

tune60: epas=0.85,
fI 0.35-0.6nA: 13.00 - 39.00
stim ih-zd   : 18.00 - 46.00 (28.00)
minV: -71 vs -81

tune62: epas=0.90, dendNa=0.25
fI 0.35-0.6nA: 4.00 - 41.00
stim ih-zd   : 14.00 - 40.00 (26.00)
minV ih-zd   : -71.72 - -84.72

trying to fix RMP:
tune63: epas=0.9, ihlke=-76, dendNa=0.5
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 9.00 - 45.00 (36.00)
minV ih-zd   : -73.87 - -84.72

tune64: epas=0.9, ihlke=-76, dendNa=0.25
fI 0.35-0.6nA: 0.00 - 36.00
stim ih-zd   : 4.00 - 40.00 (36.00)
minV ih-zd   : -73.87 - -84.72

tune65: epas=0.9, ihlke=-72, dendNa=0.25
fI 0.35-0.6nA: 4.00 - 41.00
stim ih-zd   : 14.00 - 40.00 (26.00)
minV ih-zd   : -71.72 - -84.72

tune66: epas=0.9, ihlke=-72, dendNa=0.3
fI 0.35-0.6nA: 5.00 - 40.00
stim ih-zd   : 15.00 - 41.00 (26.00)
minV ih-zd   : -71.72 - -84.72

tune67: epas=0.9, ihlke=-74, dendNa=0.3 ****
fI 0.35-0.6nA: 0.00 - 38.00
stim ih-zd   : 11.00 - 41.00 (30.00)
minV ih-zd   : -72.80 - -84.72

tune68: epas=0.9, ihlke=-74, dendNa=0.3, ihlkc=0.8
fI 0.35-0.6nA: 1.00 - 39.00
stim ih-zd   : 14.00 - 41.00 (27.00)
minV ih-zd   : -72.62 - -84.72

tune69: epas=0.9, ihlke=-74, dendNa=0.3, cfg.ihlkcBelowSoma = 0.1
fI 0.35-0.6nA: 0.00 - 37.00
stim ih-zd   : 9.00 - 41.00 (32.00)
minV ih-zd   : -72.82 - -84.72

tune71: epas=0.9, ihlke=-74, dendNa=0.3, cfg.ihSlope = 14*2.5
fI 0.35-0.6nA: 0.00 - 36.00
stim ih-zd   : 2.00 - 41.00 (39.00)
minV ih-zd   : -72.56 - -84.72

tune72: epas=0.9, ihlke=-74, dendNa=0.3, cfg.axonNa=8
fI 0.35-0.6nA: 1.00 - 37.00
stim ih-zd   : 13.00 - 39.00 (26.00)
minV ih-zd   : -72.79 - -84.72

tune73: epas=0.9, ihlke=-74, dendNa=0.3, axonRa=0.01
fI 0.35-0.6nA: 0.00 - 37.00
stim ih-zd   : 11.00 - 41.00 (30.00)
minV ih-zd   : -72.79 - -84.72

tune74: epas=0.9, ihlke=-80, dendNa=0.3, axonRa=0.1?
fI 0.35-0.6nA: 0.00 - 30.00
stim ih-zd   : 1.00 - 41.00 (40.00)
minV ih-zd   : -75.99 - -84.72

tune75: epas=0.9, ihlke=-80, dendNa=0.3, ihlkc=0.8, axonRa=0.01?
fI 0.35-0.6nA: 0.00 - 32.00
stim ih-zd   : 2.00 - 41.00 (39.00)
minV ih-zd   : -75.71 - -84.72

tune76: epas=0.9, ihlke=-80, dendNa=0.3, ihlkc=0.7, axonRa=0.01?
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 5.00 - 41.00 (36.00)
minV ih-zd   : -75.38 - -84.72

tune77: epas=0.9, ihlke=-80, dendNa=0.3, ihlkc=0.6, axonRa=0.01?
I 0.35-0.6nA: 0.00 - 35.00
stim ih-zd   : 11.00 - 41.00 (30.00)
minV ih-zd   : -74.97 - -84.72

tune78: epas=0.9, ihlke=-80, dendNa=0.3, ihlkc=0.5, axonRa=0.01?
fI 0.35-0.6nA: 1.00 - 38.00
stim ih-zd   : 15.00 - 41.00 (26.00)
minV ih-zd   : -74.46 - -84.72
Peak ih-zd    : 8.62 - 9.68

tune79: epas=0.9, ihlke=-80, dendNa=0.3, ihlkc=0.4, axonRa=0.01?
fI 0.35-0.6nA: 6.00 - 40.00
stim ih-zd   : 18.00 - 41.00 (23.00)
minV ih-zd   : -73.80 - -84.72
Peak ih-zd    : 8.78 - 9.68

tune80: epas=0.9, ihlke=-74, dendNa=0.3, ihlkc=0.5, axonRa=0.01?
fI 0.35-0.6nA: 14.00 - 43.00
stim ih-zd   : 21.00 - 41.00 (20.00)
minV ih-zd    : -71.82 - -84.72
Peak ih-zd    : 8.66 - 9.68

tune81: epas=0.9, ihlke=-74, dendNa=0.3, ihlkc=0.9, axonRa=0.01?
fI 0.35-0.6nA: 0.00 - 37.00
stim ih-zd   : 11.00 - 41.00 (30.00)
minV ih-zd    : -72.79 - -84.72
Peak ih-zd    : 8.61 - 9.68

tune82: epas=0.9, ihlke=-80, dendNa=0.5, ihlkc=0.5, axonRa=0.01?
fI 0.35-0.6nA: 1.00 - 36.00
stim ih-zd   : 16.00 - 45.00 (29.00)
minV ih-zd    : -74.46 - -84.72
Peak ih-zd    : 10.97 - 12.73

tune83: epas=0.9, ihlke=-80, dendNa=0.5, ihlkc=0.4, axonRa=0.01?
fI 0.35-0.6nA: 11.00 - 38.00
stim ih-zd   : 19.00 - 45.00 (26.00)
minV ih-zd    : -73.80 - -84.72
Peak ih-zd    : 11.12 - 12.73

tune84: epas=0.9, ihlke=-82, dendNa=0.5, ihlkc=0.5, axonRa=0.01?
fI 0.35-0.6nA: 1.00 - 34.00
stim ih-zd   : 14.00 - 45.00 (31.00)
minV ih-zd    : -75.33 - -84.72
Peak ih-zd    : 11.17 - 12.73

tune85: epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.5, axonRa=0.01?
fI 0.35-0.6nA: 1.00 - 37.00
stim ih-zd   : 16.00 - 42.00 (26.00)
minV ih-zd    : -74.46 - -84.72
Peak ih-zd    : 9.52 - 11.39

--> tune86: epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.45, axonRa=0.01
fI 0.35-0.6nA: 5.00 - 37.00
stim ih-zd   : 18.00 - 45.00 (27.00)
minV ih-zd    : -74.16 - -84.72
Peak ih-zd    : 11.25 - 12.73

params that lower RMP: dec epas, dec ihlke
params that dont affect RMP much: dendNa, ihlkc, ihSlope,
ihlkcBelowSoma, axonNa, axonRa

tune87 - epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.45 -- check epsp amp wnorm
soma=0.486
dend_1=0.484
dend_10=0.483
apic_5=0.480
apic_10=0.460
apic_20=0.397
apic_30=-0.000

--> tune88: epas=0.9, ihlke=-80, dendNa=0.5, ihlkc=0.45, axonRa=0.005
fI 0.35-0.6nA: 5.00 - 37.00
stim ih-zd   : 19.00 - 48.00 (29.00)
minV ih-zd    : -74.16 - -84.72
Peak ih-zd    : 13.67 - 14.47

tune89: epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.45, axonRa=0.005
fI 0.35-0.6nA: 3.00 - 38.00
stim ih-zd   : 18.00 - 46.00 (28.00)
minV ih-zd    : -74.16 - -84.72
Peak ih-zd    : 12.62 - 13.15

tune90: epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.45, axonRa=0.005, gpas=0.7
fI 0.35-0.6nA: 1.00 - 37.00
stim ih-zd   : 18.00 - 46.00 (28.00)
minV ih-zd    : -74.24 - -84.57
Peak ih-zd    : 12.69 - 13.35

--> tune91: epas=0.9, ihlke=-80, dendNa=0.4, ihlkc=0.45, axonRa=0.005, gpas=0.6
fI 0.35-0.6nA: 6.00 - 38.00
stim ih-zd   : 19.00 - 47.00 (28.00)
minV ih-zd    : -74.07 - -84.90  (NOTE this is minV, not RMP)
Peak ih-zd    : 12.46 - 13.23

tune92: epas=0.9, ihlke=-81, dendNa=0.4, ihlkc=0.45, axonRa=0.005, gpas=0.6
fI 0.35-0.6nA: 3.00 - 38.00
stim ih-zd   : 18.00 - 47.00 (29.00)
minV ih-zd    : -74.50 - -84.90
Peak ih-zd    : 12.21 - 13.23

WAS CALCULATING RMP WRONG - WAS REALLY MINV
FAVOR RMP OVER PEAK
-- reducing peak requires increasing stim ih (reducing diff);
-- compromise not worth; prefer to show strong ih effect than slightlybetter tuned

tune96:
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

--> fI 0.35-0.6nA: 6.00 - 38.00, ihlkc=0.5??
stim ih-zd   : 19.00 - 47.00 (28.00)
RMP ih-zd    : -72.81 - -84.65
Peak ih-zd    : 12.48 - 13.23

tune97: ihlke=-84, ihlkc=0.5??
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 16.00 - 47.00 (31.00)
RMP ih-zd    : -73.63 - -84.65
Peak ih-zd    : 12.55 - 13.23

tune98: ihlke=-84, epas=0.95, ihlkc=0.5¿¿
fI 0.35-0.6nA: 0.00 - 33.00
stim ih-zd   : 11.00 - 43.00 (32.00)
RMP ih-zd    : -74.25 - -87.84
Peak ih-zd    : 12.04 - 13.06

tune99: ihlke=-84, epas=0.95, ihlkc=0.5
fI 0.35-0.6nA: 0.00 - 33.00
stim ih-zd   : 11.00 - 43.00 (32.00)
RMP ih-zd    : -74.25 - -87.84
Peak ih-zd    : 12.04 - 13.06

tune100: ihlke=-84, epas=0.95, ihlkc=0.5, slope=14*1.75
fI 0.35-0.6nA: 0.00 - 34.00
stim ih-zd   : 14.00 - 43.00 (29.00)
RMP ih-zd    : -74.31 - -87.84
Peak ih-zd    : 12.11 - 13.06

tune101: ihlke=-84, epas=0.95, ihlkc=0.6
fI 0.35-0.6nA: 0.00 - 31.00
stim ih-zd   : 3.00 - 43.00 (40.00)
RMP ih-zd    : -74.63 - -87.84
Peak ih-zd    : 12.42 - 13.06

tune102: ihlke=-84, epas=0.95, ihlkc=0.4
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 16.00 - 43.00 (27.00)
RMP ih-zd    : -73.81 - -87.84
Peak ih-zd    : 12.69 - 13.06

tune103: ihlke=-84, epas=0.95, ihlkc=0.4, slope 14*1.5
fI 0.35-0.6nA: 1.00 - 37.00
stim ih-zd   : 19.00 - 43.00 (24.00)
RMP ih-zd    : -73.93 - -87.84
Peak ih-zd    : 12.25 - 13.06

tune104: ihlke=-84, epas=0.95, ihlkc=0.4, dendNa=0.3
fI 0.35-0.6nA: 1.00 - 36.00
stim ih-zd   : 16.00 - 43.00 (27.00)
RMP ih-zd    : -73.81 - -87.84
Peak ih-zd    : 11.72 - 12.03

tune105: ihlke=-84, epas=0.95, ihlkc=0.3, slope 14*1.5, dendNa=0.3, axonNa=0.8
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 19.00 - 41.00 (22.00)
RMP ih-zd    : -73.93 - -87.84
Peak ih-zd    : 12.84 - 13.28

tune106: ihlke=-84, epas=0.95, ihlkc=0.3, dendNa=0.3, axonNa=0.8
fI 0.35-0.6nA: 1.00 - 35.00
stim ih-zd   : 16.00 - 41.00 (25.00)
RMP ih-zd    : -73.81 - -87.84
Peak ih-zd    : 12.81 - 13.28

tune107: ihlke=-84, epas=0.95, ihlkc=0.3, dendNa=0.3, axonNa=0.8, gpas=0.5
fI 0.35-0.6nA: 1.00 - 37.00
stim ih-zd   : 18.00 - 43.00 (25.00)
RMP ih-zd    : -73.62 - -88.08
Peak ih-zd    : 12.96 - 13.43

tune108: ihlke=-84, epas=0.95, ihlkc=0.3, dendNa=0.2, axonNa=0.8
fI 0.35-0.6nA: 1.00 - 36.00
stim ih-zd   : 16.00 - 40.00 (24.00)
RMP ih-zd    : -73.81 - -87.84
Peak ih-zd    : 11.96 - 12.22

tune109: ihlke:-82, ihlkc=0.4
fI 0.35-0.6nA: 5.00 - 38.00
stim ih-zd   : 19.00 - 47.00 (28.00)
RMP ih-zd    : -73.01 - -84.65
Peak ih-zd    : 12.46 - 13.23

tune110: ihlke:-84, ihlkc=0.3
fI 0.35-0.6nA: 12.00 - 40.00
stim ih-zd   : 22.00 - 47.00 (25.00)
RMP ih-zd    : -72.81 - -84.65
Peak ih-zd    : 12.83 - 13.23

tune111: ihlke:-84, ihlkc=0.3, dendNa=0.3
fI 0.35-0.6nA: 11.00 - 41.00
stim ih-zd   : 22.00 - 46.00 (24.00)
RMP ih-zd    : -72.81 - -84.65
Peak ih-zd    : 11.91 - 12.33

tune112: ihlke:-86, ihlkc=0.3, dendNa=0.3
fI 0.35-0.6nA: 6.00 - 40.00
stim ih-zd   : 20.00 - 46.00 (26.00)
RMP ih-zd    : -73.12 - -84.65
Peak ih-zd    : 11.50 - 12.33

tune113: ihlke:-86, ihlkc=0.3
fI 0.35-0.6nA: 10.00 - 39.00
stim ih-zd   : 21.00 - 47.00 (26.00)
RMP ih-zd    : -73.12 - -84.65
Peak ih-zd    : 12.34 - 13.23

tune114: ihlke:-88, ihlkc=0.3
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 19.00 - 47.00 (28.00)
RMP ih-zd    : -73.42 - -84.65
Peak ih-zd    : 12.77 - 13.23

--> tune115: ihlke:-87, ihlkc=0.3
fI 0.35-0.6nA: 6.00 - 38.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.28 - -84.65
Peak ih-zd    : 12.42 - 13.23

tune116: ihlke:-88, ihlkc=0.25
fI 0.35-0.6nA: 12.00 - 39.00
stim ih-zd   : 23.00 - 47.00 (24.00)
RMP ih-zd    : -73.03 - -84.65
Peak ih-zd    : 12.81 - 13.23

tune117: ihlke:-89, ihlkc=0.25
fI 0.35-0.6nA: 11.00 - 39.00
stim ih-zd   : 22.00 - 47.00 (25.00)
RMP ih-zd    : -73.16 - -84.65
Peak ih-zd    : 12.65 - 13.23

tune118: ihlke:-90, ihlkc=0.25
fI 0.35-0.6nA: 9.00 - 38.00
stim ih-zd   : 21.00 - 47.00 (26.00)
RMP ih-zd    : -73.29 - -84.65
Peak ih-zd    : 12.45 - 13.23

--> tune119: ihlke:-91, ihlkc=0.25
fI 0.35-0.6nA: 6.00 - 38.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.42 - -84.65
Peak ih-zd    : 12.82 - 13.23


tune120: ihlke:-95, ihlkc=0.2
fI 0.35-0.6nA: 10.00 - 39.00
stim ih-zd   : 22.00 - 47.00 (25.00)
RMP ih-zd    : -73.36 - -84.65
Peak ih-zd    : 12.53 - 13.23

tune121: ihlke:-96, ihlkc=0.2
fI 0.35-0.6nA: 9.00 - 38.00
stim ih-zd   : 22.00 - 47.00 (25.00)
RMP ih-zd    : -73.47 - -84.65
Peak ih-zd    : 12.84 - 13.23

--> tune122: ihlke:-97, ihlkc=0.2
fI 0.35-0.6nA: 6.00 - 38.00
stim ih-zd   : 21.00 - 47.00 (26.00)
RMP ih-zd    : -73.58 - -84.65
Peak ih-zd    : 12.30 - 13.23

tune123: ihlke:-98, ihlkc=0.2
fI 0.35-0.6nA: 4.00 - 37.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.68 - -84.65
Peak ih-zd    : 12.83 - 13.23

tune124: ihlke:-97, ihlkc=0.2, slope=14 * 2.1
fI 0.35-0.6nA: 4.00 - 38.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.55 - -84.65
Peak ih-zd    : 12.74 - 13.23

tune125: ihlke:-97, ihlkc=0.2, slope=14 * 2.2
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.52 - -84.65
Peak ih-zd    : 12.79 - 13.23

tune126: ihlke:-97, ihlkc=0.2, axonNa=7.5
fI 0.35-0.6nA: 10.00 - 37.00
stim ih-zd   : 21.00 - 46.00 (25.00)
RMP ih-zd    : -73.58 - -84.65
Peak ih-zd    : 13.12 - 13.79

tune127: ihlke:-97, ihlkc=0.2, epas=0.92
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 20.00 - 46.00 (26.00)
RMP ih-zd    : -73.75 - -85.91
Peak ih-zd    : 12.38 - 13.44

tune128: ihlke:-97, ihlkc=0.2, axonNa=6.5
fI 0.35-0.6nA: 3.00 - 38.00
stim ih-zd   : 21.00 - 48.00 (27.00)
RMP ih-zd    : -73.58 - -84.65
Peak ih-zd    : 12.08 - 12.86

--> tune129: ihlke:-97, ihlkc=0.2, gpas=0.58
fI 0.35-0.6nA: 7.00 - 38.00
stim ih-zd   : 21.00 - 47.00 (26.00)
RMP ih-zd    : -73.55 - -84.72
Peak ih-zd    : 12.64 - 13.12

tune130: ihlke:-97, ihlkc=0.2, slope=14*1.8
fI 0.35-0.6nA: 10.00 - 38.00
stim ih-zd   : 22.00 - 47.00 (25.00)
RMP ih-zd    : -73.62 - -84.65
Peak ih-zd    : 12.85 - 13.23

tune131: ihlke:-97, ihlkc=0.2, gpas=0.55, slope=14*1.8
fI 0.35-0.6nA: 11.00 - 39.00
stim ih-zd   : 23.00 - 47.00 (24.00)
RMP ih-zd    : -73.55 - -84.83
Peak ih-zd    : 12.68 - 13.12

tune132: ihlke:-96, ihlkc=0.2, gpas=0.55, slope=14*1.8
fI 0.35-0.6nA: 12.00 - 39.00
stim ih-zd   : 23.00 - 47.00 (24.00)
RMP ih-zd    : -73.45 - -84.83
Peak ih-zd    : 12.70 - 13.12

tune133: ihlke:-97, ihlkc=0.22, gpas=0.55
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.75 - -84.83
Peak ih-zd    : 12.77 - 13.12

tune134: ihlke:-97, ihlkc=0.23, gpas=0.55, slope=14*1.8
fI 0.35-0.6nA: 4.00 - 37.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.90 - -84.83
Peak ih-zd    : 12.73 - 13.12

tune135: ihlke:-94, ihlkc=0.2, gpas=0.55, slope=14*1.8
fI 0.35-0.6nA: 13.00 - 40.00
stim ih-zd   : 23.00 - 47.00 (24.00)
RMP ih-zd    : -73.23 - -84.83
Peak ih-zd    : 12.74 - 13.12

tune136: ihlke:-100, ihlkc=0.2, gpas=0.55,
fI 0.35-0.6nA: 3.00 - 37.00
stim ih-zd   : 20.00 - 47.00 (27.00)
RMP ih-zd    : -73.82 - -84.83
Peak ih-zd    : 12.56 - 13.12

tune141

*** tune1 - check conns in full m1 net
on zn
save secs+conns
don't run
*** v45_batch13_1_3_1_0_2_netClamp - on zn
- copied v45_batch13_1_3_1_0_2_cfg.json
-- modified "saveFolder": "../data/v45_manualTune"
-- "simLabel": "v45_batch13_1_3_1_0_2_netClamp"
-- "saveCellConns": true

- update to correct hg rev so that cellParams, weightNorm etc is same
- screen -L mpiexec 8 nrniv -mpi -python init.py simConfig=../data/v45_manualTune/v45_batch13_1_3_1_0_2_netClamp_cfg.json netParams=../data/v45_manualTune/v45_batch13_netParams.py

- ERROR: bad_alloc memory, mpi -- crashed during gathering data after 36 hours running 3sec in 8 cores
- gonna run without runSim on 1 core

** v45_batch10 - EI balance, with params from v45_tune91 + wnorm, IPTGain=1.0 (WRONG PARAMS!!)
BUG: synMechWeightFactor wasn't implemented (netpyne v0.7.1 27a360)

- using wrong PT ih params:
ihlkc = 1.2
ihlke = -72
dendNa = 0.25

- but v45_batch12 and v45_batch13 correct PT ih params!!! weird! -- guess ih PT similar overall

- Note IIGain = 0.8 !

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells


	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'end')] = 1200.0

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2, 2.0]
	# params[IPTGain,1] = 1.0
	# params['weightNormThreshold'] = 4.0
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

*** results
good rates in all pops (including IT2); no depol block:
- 20 00 21 - IT2 oc, low CT; PT few spk
--> - 21 00 22 - IT2 osc; CT not so low; PT very few spk

- good rates; PT ~ close to dep block
- 20 00 11
- 20 10 20
--> - 20 22 20 - IT2 clear osc; few more PT spks before stim; low CT
- 21 21 21
- 21 22 22

** v45_batch11 - long stim with new PT (v45_tune91+wnorm) and v45_batch1 10121211 (BUGS)
BUG: synMechWeightFactor wasn't implemented (netpyne v0.7.1 27a360)

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	initCfg[('IEweights',0)] = 1.0 #
	initCfg[('IIweights',0)] = 0.8 #
	# L5
	initCfg[('IEweights',1)] = 1.0 #
	initCfg['IPTGain'] =       3.0 #
	initCfg['weightNormThreshold'] = 4.0 #
	initCfg[('IEweights',1)] = 1.2 #
	# L6
	initCfg[('IEweights',2)] = 1.2 #
	initCfg[('IIweights',2)] = 1.0 #


	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]

*** results
None
- ih=0: low IT2, low PT5B
- ih=1: lower PT5B - good

TPO
- ih=0: 1st upper -> PT5B good rate
- ih=1: PT ~lower amp (0.63 vs 1.1 hz); less duration
- ih=2, 20hz: IT5A depol

TVL
15hz
- ih=0,1: no PT spks, but IT2 osc! - why?
- ih=2: PT spks but no IT2 osc
-- check E<->I layer interactions
20hz
- ih=0: strong PT response but after IT23+IT5A
- ih=1: no PT - good
- ih=2: weak PT response but after IT23+IT5A

S1
15hz,20hz
- ih=0,1,2: ~decreasing PT rate with ih

S2
15hz,20hz
- ih=0,1,2: ~decreasing PT rate with ih

M2
15hz - no PT spks
20hz - no PT spks but strong L6 activity

OC
15 hz - high L6 activity; no PT
20 hz - high L6 activity; ih=2: short burst of PT, IT5A mediated?

** v45_batch12 - long stim v45_batch10 210022, PT weightNormThreshold (BUGS)

BUG: clk below soma not implemented! -- all clk = 0.45
-- makes PT fire less (eg. 23 -> 18 hz) with ih (see v46_batch3 vs 4)
-- but doesn't seem so critical as to affect the whole network oscillations
-- maybe related with IIGain?
-- or maybe some other factor? - test doesn't depend on netpyne

Note IIGain = 0.8 !

	# initial config
	initCfg = {}

	## 21 00 22
	# L2
	initCfg[('IEweights',0)] = 1.2 #
	initCfg[('IIweights',0)] = 1.0 #
	# L5
	initCfg[('IEweights',1)] = 0.8 #
	initCfg[('IEweights',1)] = 0.8 #
	# L6
	initCfg[('IEweights',2)] = 1.2 #
	initCfg[('IIweights',2)] = 1.2 #

	initCfg['IPTGain'] =       1.0 #


	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]
	params[('pulse', 'end')] = [1700, 1900]
	params['weightNormThreshold'] = [4.0, 5.0, 6.0]

*** results
ih = 0:
- PT osc high amp -> silences all other exc pops
- after stim - some generate osc in other exc  - eg 04100 or 05100 (no depblock)
- even with wnorm=5 or 6 and longer pulse, most no depol block - good

ih = 1.0:
- ALL depol block or no activity
- some dep block not so bad eg. 13101 (S1->L2/3->PT)
- no activity ok -- just means this cell didn't spike eg. 15101 (M2->PT, no L23)
- why?
-- with upper layers not inhibited, they provide high stim to PT, which already relatively high

ih=2.0:
- similar trend to ih=1, but slightly lower PT rate and depol block

summary:
- good strong modulation of PT via ih
- need intermediate ih, or EI balance so other pops not silenced with ih=0
- rasters ok, but generally depol block with ih=1

** v45_batch13 - long stim v45_batch10 202220, PT weightNormThreshold (BUGS)
BUG: synMechWeightFactor wasn't implemented (netpyne v0.7.1 27a360)

BUG: clk below soma not implemented! -- all clk = 0.45

Note IIGain = 0.8 !


	## 20 22 20
	# L2
	initCfg[('IEweights',0)] = 1.2 #
	initCfg[('IIweights',0)] = 0.8 #
	# L5
	initCfg[('IEweights',1)] = 1.2 #
	initCfg[('IEweights',1)] = 1.2 #
	# L6
	initCfg[('IEweights',2)] = 1.2 #
	initCfg[('IIweights',2)] = 0.8 #

	initCfg['IPTGain'] =       1.0 #

	params['ihGbar'] = [0.0, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]
	params[('pulse', 'end')] = [1700, 1900]
	params['weightNormThreshold'] = [4.0, 5.0, 6.0]

*** results
ih=0.0:
- most no depol (just 1 or 2 out of 84) - great
- high PT activity and osc; inhibits all upper layers (PT->SOM2; PT->PV2)
- TPO reduces PT; triggers upper layer activity + osc
- TVL increases PT; triggers upper layer activity+osc
- S1 strong IT5A, inhibits PT; triggers strong upper layer osc
- S2 increases upper, inhibits PT; triggers upper layer osc
- M2 strong IT5B, L6 inhibits PT, no IT2
- OC strong IT5B, L6; inhibits PT, no IT2

ih=1.0:
- nice activity + osc in all layers (except CT quite weak)
- few depol block
- TPO good examples 2/3->PT, with no dep block
- TVL fewer good examples, more depol, mostly PT activity, but peak at stim in 23 (maybe due to L5A)
- S1,S2 triggers oscillations longer than stim; some dep block
- M2 -> silences L23, high IT5B,6 and CT activity; low PT (due to inhib?)
- OC -> silences L23, high IT5A,B, higher IT6,CT; not much PT

ih=2
- PT activity limited to duration of stim
- no stim -depol block due ot IT2 burst
- S1, S2 -ok
- M2 - few spk
- OC - PT burst

summary:
- ih=0, no depol, PT too high so stim opposite effect
- ih 1, no depol, act+osc all layers, all stim ok except M2,OC -> low PT

num conns:  27443049

*** long plateau examples
13001
13011
13102 *
13110
13111
13112
14110

** v45_batch14 - EI balance, with params from v45_tune91 + wnorm, IPTGain=2.0 - BUG - moved to v46_batch3
- BUG: all PT ih params wrong!!

- error: HDD full, stopped sims

- error - fixed manually on cm:
initCfg[('pulse', 'end')] = 1000.0 -> initCfg[('pulse', 'start')] = 1000.0

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2, 2.0]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]


	params['ihGbar'] = [0.0, 1.0]


	groupedParams = [] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 1.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -72  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 6   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.8
	initCfg['epas'] = 1.0

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1200.0

	initCfg['IPTGain'] = 2.0
	initCfg['weightNormThreshold'] = 4.0

*** results
- just 2 bursts with almost no spikes - why? compare with batch10
-- all params ok -- IPTGain = 2.0 and with ih=0.0 -> strong PT activation, prob depol block everything else
-- also note just ~140 sims

- v46_batch1 also shows similar pattern in 200+ sims

- checked different PT5B_full_cellParams - was just different because hadn't saved latest

- chekc netpyne

- num conns: 27443049

** v46_batch1 - EI balance, disynBias, IPTGain - (re-running on cm - CHECK disyn BEFORE running)
- BUG all PT ih params wrong! rerun all again!

- error: submitted SUs exceeded available SUs -- should reduce 6hr to 3hr
- running about 50% of jobs (~2270)

- BUG: E->CT L6 wrong bin 0.9-1.0 (very low smat, so not critical)


Note restored IIGain = 1.0 ! (different from prev ones)

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['IPTGain'] = [1.0, 2.0]
	params['IEdisynapticBias'] = [0.25, 0.5]


	groupedParams = [] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1200.0

	initCfg['weightNormThreshold'] = 4.0
*** results
num conns: 27267437
27341541

** v46_batch2 - fI curve for all pops

	params[('IClamp1', 'pop')] = ['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6', 'PV2', 'SOM2', 'PV5A', 'SOM5A', 'PV5B', 'SOM5B', 'PV6', 'SOM6']
	params[('IClamp1', 'amp')] = list(np.arange(0.0, 6.5, 0.5)/10.0)
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

# User specific aliases and functionsi
source /projects/ps-nsg/home/nsguser/.bashrc
module load gsl

module load python
module load scipy

#export MODULEPATH=/share/apps/compute/modulefiles/mpi:$MODULEPATH
#module unload mvapich2_ib
#module unload openmpi_ib/1.8.4
#module load openmpi_ib/1.8.4npmi

export SITE=/home/lytton/site
export PATH=/home/salvaodrd/site/nrniv/local/bin:$SITE/bin:/home/lytton/arch/nrn/x86_64/bin:$PATH
export NEURON_INIT_MPI=0
export LIBS=-ldl

export N=$SITE/nrniv
export CPU=`uname -p`
export NSRC=$N/nrn$NSUF # current source
export IVB=$N/iv
export NB=$N/nrn$NSUF$CPU

export ND=/home/lytton/arch/nrn
#if (! $?LD_LIBRARY_PATH) setenv LD_LIBRARY_PATH ""

export MODL_INCLUDE=/home/salvadord/site/nrniv/local/mod
export HOC_LIBRARY_PATH=/home/salvadord/site/nrniv/local/hoc:/home/salvadord/site/nrniv/simctrl/hoc
export PYTHONPATH=/home/salvadord/site/nrniv/local/python:/home/salvadord/site/nrniv/local/python/netpyne:$PYTHONPATH

alias lsl='ls -lrtah'
alias upnp='cd ~/site/nrniv/local/python/netpyne/; git pull; cd ~/m1/sim'
alias sq='squeue -u $USER; squeue -u $USER | wc -l'
alias sqr='squeue -u $USER -t RUNNING; squeue -u $USER -t RUNNING | wc -l'
alias sqra='squeue -t RUNNING; squeue -t RUNNING | wc -l'
alias sqp='squeue -u $USER -t PENDING; squeue -u $USER -t PENDING | wc -l'
alias sqpa='squeue -t PENDING --partition=compute -o "%.18i %.9P %.8j %.8u %.2t %.10M %.6D %R %p"; squeue -t PENDING --partition=compute | wc -l'
alias sdetail='scontrol show job'
alias tarc='tar -zcvf'

	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['addIClamp'] = True
	initCfg['addNetStim'] = False
	initCfg[('IClamp1','sec')] = 'soma'
	initCfg[('IClamp1','loc')] = 0.5
	initCfg[('IClamp1','start')] = 500
	initCfg[('IClamp1','dur')] = 1000
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1500]

** v46_batch3 - EI balance, with params from v45_tune91 + wnorm, IPTGain=[1.0,2.0] - rerun on scm - bugs
*** issues
**** ihLkcBelowSoma instead of ihlkcBelowSoma !!! - not having effect why?!?!
-- didn't have secList belowSoma !!
- PT ih params don't match v45_batch10 -- but issue of v45_batch10

**** rerun with fixed prams and IPTGain=[1.0,2.0]




**** Still getting bursts (similar to v45_batch14, but not v45_batch13 -- why??
- difference with v45_batch13 is clk below soma not implemented! -- all clk = 0.45
- makes PT fire less (eg. 23 -> 18 hz) with ih (see v46_batch3 vs 4)
- but doesn't seem so critical as to affect the whole network oscillations (in fact prev bug was that and same output)

**** weightNorm?
- unlikely based on m1 commits

**** maybe related with IIGain?
- test by running 0000000 with IIGain=0.8  (Submitted batch job 11079228)
- practically identical; even less firing with IIGain=0.8

**** netpyne changes?
- rerun v46_batch3 using old netpyne (27a01f1)
 sbatch ../data/v46_batch3/v46_batch3_0_0_0_0_0_0_0.sbatch
Submitted batch job 11079976
-- SAME BURSTS

- compared locally 30x30 um with different netpyne versions - identical!!!!
-- v46_tune10 (6ec09cd)
  Connections: 35264 (4.97 per cell)
  Synaptic contacts: 132151 (18.62 per cell)

-- v46_tune11 (9ff475f)
  Connections: 35264 (4.97 per cell)
  Synaptic contacts: 132151 (18.62 per cell)

-- v46_tune12 (27a01f1)
  Connections: 35264 (4.97 per cell)
  Synaptic contacts: 132151 (18.62 per cell)

- test doesn't depend on netpyne changes, by rerunning v45_batch13 sim with current netpyne (on zn)
-- test by rerunning with old netpyne (remove disyn code in netParams? don't need) (27a01f1)
 sbatch ../data/v45_batch13/v45_batch13_1_3_1_0_2.sbatch
Submitted batch job 11080013
-- CAN'T REPLICAE!!! NOW BURSTS! WHY??!

**** CHANGES IN CENTRAL REPO??? - NO
- haven't updated on cm since mid July; and x86_64 folder compiled Jul 8

**** New netpyne, new m1 changeset, old params+cfg ../data/v45_batch13/v45_batch13_1_3_1_0_2, on zn
-- v46_batch13_1_3_1_0_2_checkNetpyne
-- SAME BURSTS, BUT DIFFERENT FROM npOld

compare: 'v46_manualTune/v46_batch13_1_3_1_0_2_checkNetpyne.json' with 'v45_batch13/v45_batch13_1_3_1_0_2_npOld.json':
- net, netParams and simConfig identical, but different spikes!!! (though both quite similar)
- 1st diff spikes after 117ms from IT5B cell
- All Exc different after 1st 0.1 ms
- SOM2 identical for ~180 ms

-- num cores?
-- different netpyne version? 0.7.2 vs 0.7.3
-- different NEURON?
-- different python?
**** Can't replicate even using same netpyne version
Compare v45_batch13/v45_batch13_1_3_1_0_2_npOld.json with v45_batch13/v45_batch13_1_3_1_0_2_orig.json:
-- some changes in conn (since using netParams.py which reads from conn.py files):
--- rounding errors in subconn grid values and some prob+weights -- don't think significant (< 10e-7)
--- EE_HH_[full,reduced,simple]_4_[0-8]_1 ynorm : [0.558,0.62] -> [0.9, 1.0] (E->CT, minor diff since low weight+prob!)
--- EE_HH_full_4_7_0 : 0.033 -> 0.040 (increased E->CT, minor diff)
--- EE_HH_full_4_8_1 : 0.022 -> 0.026 (increased E->CT, minor)
-- checking simData:
--- first 426 spk times are same! up to 60ms (fid 3735, SOM5A)
--- first different spk = cell gid 3735  (in orig sim) - up to then all bkg noise
--- E cells after 0.1 ms:  V_soma - changes after 1st 0.1ms (7 spks < 1ms; but delay = 5ms) -- RED FLAG!
---- IT2 (50)
---- IT4 (2131)
---- PT5B (5198)
---- CT (8431)
---- IT6 (6966)
---- IT5A (3136)
---- IT5B (4043)
--- Interneurons after ~9 ms ((could be cause by different conn)
---- PV5A (3861) same for 8.8ms;
---- PV6 (10031) same for 9.2ms;
---- SOM2 (1816) ~9ms
---- SOM5B (6353)

**** TO DO check- run with old conn.py etc. just to check thats not cause (running on cm) - WORKED
hg revert -r 1089 conn.pkl conn_long.pkl conn_dend_IT.json conn_dend_PT.json
sbatch ../data/v45_batch13/v45_batch13_1_3_1_0_2.sbatch
Submitted batch job 11084042

change netpyne to 1625e7 (easly 0.7.1 - no synMechWeightFactor)

WORKED!!!!!

**** v45_batch13_rep1 - run with old m1 changeset -- maybe something to do with cells params? (running on zn)
- maybe netpyne version not having effect, cause using saved netParams.pkl (new version)
-- no, but difference would show up in netParams
-- perhaps related to how netpyne is setting the params?

- use old netpyne (27a01f1) and old m1 changeset (1092)
- run 1 sec only
- hg revert; set params in cfg.py (can't use batch on zn) -- call v45_batch13_rep1
- change zn .tcshrc to set netpyne from models/netpyne_repo
- netpyne/cell.py
-- fixedInterval = np.full(((1+1.5*noise)*(end-start)/interval), [(1.0-noise)*interval]) -- added int() manually
- screen -L nrniv -np 48 -python -mpi init.py

- different spkts (after 2nd spk); and Exc V_soma (after 0.1ms)

- do same in comet -- maybe using orig batch

**** v45_batch13_rep2 - test locally on laptop different changesets, with reduced net (30x30), 0.1sec, compare cell V_soma
- 1: netpyne - 27a01f1 (+int()), m1 - 1092 (batch->cfg), 30x30, 0.5 sec (dur: 75 sec - great!)

- 2: reran conn.py, conn_long.py, conn_dend.py, cellDensity.py
-- identical simData
-- EE_HH_[full,reduced,simple]_2_0_5, probbality+weight (< 1e-10)
-- density grid values (< 1e-5)

- 3: netpyne - 6ec09c (latest)
-- identical simData, net, cfg

- 4: on zn
-- many diffs (including spkt) but all <9 sig figures (< 1e-9)

**** NOTE penny's reproducibility error happened same day (Aug 21) -- netpyne+python libs interaction?
**** FIXED!!!!!!! v45_batch13_rep1 - orig was using netpyne 0.7.1 !!!
- which changeset?
-- had implemented initCfg - 27a360 - THIS ONE!!!!!
-- not sure if after fixed synMechWeightFactor - 1625e7

**** matplotlib version
- saved on laptop

*** params

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['IPTGain'] = [1.0, 2.0]

	groupedParams = [] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1200.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEdisynapticBias'] = None

** v46_manualTune
	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihGbar'] = 1.0
	initCfg['ihlkc'] = 1.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -72  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.25  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 6   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.8
	initCfg['epas'] = 1.0


	## 20 22 20
	# L2
	initCfg[('IEweights',0)] = 1.2 #
	initCfg[('IIweights',0)] = 0.8 #
	# L5
	initCfg[('IEweights',1)] = 1.2 #
	initCfg[('IEweights',1)] = 1.2 #
	# L6
	initCfg[('IEweights',2)] = 1.2 #
	initCfg[('IIweights',2)] = 0.8 #

	initCfg['IPTGain'] =       1.0 #

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellConns'] = True

*** v46_tune1 - disynapticBias=None - rerun to save full .json
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17171
  Done; cell creation time = 311.14 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 0: 7389937
  Number of synaptic contacts on node 0: 27572869
  Done; cell connection time = 8900.09 s.
  Number of stims on node 0: 0
  Done; cell stims creation time = 0.01 s.
Recording 15 traces of 1 types on node 0

Gathering data...
  Done; gather time = 1093.69 s.

Analyzing...
  Cells: 17171
  Connections: 7389937 (430.37 per cell)
  Synaptic contacts: 27572869 (1605.78 per cell)

Saving output as ../data/v46_manualTune/v46_tune1.json  ...
Finished saving!
  Done; saving time = 0.45 s.
Plotting raster...
No spikes available to plot raster
  Total disynaptic connections: 14233729 (51.62%)
Plotting connectivity matrix...
  Done; plotting time = 29613.22 s

Total time = 39933.62 s

from netpyne import sim; sim.analysis.calculateDisynaptic(includePost = ['PT5B'], includePre =
['SOM5A','SOM5B','PV5A','PV5B'], includePrePre = ['PT5B'], tags=None, conns=None,
tagsFile='../data/v46_manualTune/v46_tune1_3085_6915_tags.json', connsFile='../data/v46_manualTune/v46_tune1_3085_6915.json')

Total disynaptic connections: 671610 / 1011310 (66.41%)


*** v46_tune2 - disynapticBias=0.2
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17171
  Done; cell creation time = 297.48 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 0: 7320489
  Number of synaptic contacts on node 0: 27341541
  Done; cell connection time = 8866.63 s.
  Number of stims on node 0: 0
  Done; cell stims creation time = 0.01 s.
Recording 15 traces of 1 types on node 0

Gathering data...
  Done; gather time = 1131.41 s.

Analyzing...
  Cells: 17171
  Connections: 7320489 (426.33 per cell)
  Synaptic contacts: 27341541 (1592.31 per cell)
Saving output as ../data/v46_manualTune/v46_tune2.json  ...
Finished saving!
  Done; saving time = 1139.77 s.
Plotting raster...
No spikes available to plot raster
  Total disynaptic connections: 14002401 (51.21%)
Plotting connectivity matrix...
  Done; plotting time = 30768.47 s

Total time = 42225.08 s

  Total disynaptic connections: 609230 / 913270 (66.71%)
  time ellapsed (s):  22369.17693
*** v46_tune3 - disynapticBias=0.4
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17171
  Done; cell creation time = 316.53 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 0: 7196403
  Number of synaptic contacts on node 0: 26984789
  Done; cell connection time = 8848.82 s.
  Number of stims on node 0: 0
  Done; cell stims creation time = 0.01 s.
Recording 15 traces of 1 types on node 0

Gathering data...
  Done; gather time = 1107.10 s.

Analyzing...
  Cells: 17171
  Connections: 7196403 (419.10 per cell)
  Synaptic contacts: 26984789 (1571.53 per cell)
Saving output as ../data/v46_manualTune/v46_tune3.json  ...
Finished saving!
  Done; saving time = 1039.11 s.
Plotting raster...
No spikes available to plot raster
  Total disynaptic connections: 13645649 (50.57%)
Plotting connectivity matrix...
  Done; plotting time = 27108.99 s

Total time = 38435.21 s

Calculating disynaptic connections...
  Total disynaptic connections: 497195 / 738045 (67.37%)
  time ellapsed (s):  17901.998713


*** v46_tune4 - disynapticBias=0.5




*** v46_tune5 - rerun sim of v45_batch13 to check if can replicate or any issue with netpyne
- update netpyne
- set saveCellConns=0 so no error
- set save to v46_tune5

screen -L mpiexec -np 32 nrniv -mpi -python init.py simConfig=../data/v45_manualTune/v45_batch13_1_3_1_0_2_checkNetpyne_cfg.json netParams=../data/v45_manualTune/v45_batch13_netParams.py

- implemented netClamp:
cfg.netClampConnsFile = '../data/v45_manualTune/v45_batch13_1_3_1_0_2.json'
cfg.netClampSpikesFile = '../data/v45_batch13/v45_batch13_1_3_1_0_2.json'
cfg.netClampPop = ['PT5B_1']
cfg.netClampGid = 5198

- trace different
-- need to set same PT ih params
-- still different

- only reason is that conns are different? compare
-- ../data/v45_manualTune/v45_batch13_1_3_1_0_2.json
  Connections: 7325027 (426.59 per cell)
  Synaptic contacts: 27443049 (1598.22 per cell)
-- ../data/v45_manualTune/v45_batch13_1_3_1_0_2.json
 syn conns: 27443049

- netClamp code wrong?


*** v46_tune8-... - check if AMPA/NMDA ratio can improve netClamp; check also epsp amps
tune8 - 1.0:1.0 netClamp -- great, got back plateau and spikes!
tune9 - 0.5:0.5 netClamp -- smaller amplitude as expected -- just need to retune weightNorm
tune10 - 1.0:1.0 epsp 0.5 -- 0.491mV
tune11 - 0.5:0.5 epsp 0.5 -- 0.246mV
tune12 - 1.0:0.1 epsp 0.5 -- 0.483mV
tune13 - 0.0:1.0 epsp 0.5 -- 0.043mV
-- NMDA extend duration/shape of epsp but contributes little to amplitude
-- perhaps in other dends it has greater effect (or at different RMP)
-- could tune separately AMPA and NMDA since paper seems to show similar current/V; however that would complicate
implementation and its not clear that such high NMDA weights required make sense
-- Both synapses weights correspond to uS
-- If tune together (0.5:0.5) can use most of the existing results

*** v46_tune14 - GABAA:GABAB ratio
tune14 - 1:7.5 ipsp 5.0 -- -0.977
tune15 - 1:0.0 ipsp 5.0 -- -0.977
tune16 - 0:7.5 ipsp 5.0 -- -0.007 (RMP)
tune18 - with exp2syn 0.9:0.1 ipsp 0.5 -- -0.332 (Iclamp 0.3nA)
tune18 - with exp2syn 0.9:0.0 ipsp 0.5 -- -0.276 (Iclamp 0.3nA)

** v47_batch1 - PT wnorm with AMPA/NMDA ratio 0.5:0.5


cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = None # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihlkcBasal = 1.0
cfg.ihlkcBelowSoma = 1.0 #0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	#initCfg[('GroupNetStimW1', 'pop')] = 'None'
	initCfg[('NetStim1', 'delay')] = 1
	initCfg['addIClamp'] = 0

** v47_batch2 - IT5A_full wnorm with AMPA/NMDA 0.5:0.5
	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	#initCfg[('GroupNetStimW1', 'pop')] = 'None'
	initCfg[('NetStim1', 'delay')] = 1
	initCfg['addIClamp'] = 0


b = weightNormE(pops=['IT5A'], rule='IT5A_full')

** v47_batch3 - IT2,IT4,IT5B,IT6,CT6_reduced wnorm with AMPA/NMDA 0.5:0.5
	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	#initCfg[('GroupNetStimW1', 'pop')] = 'None'
	initCfg[('NetStim1', 'delay')] = 1
	initCfg['addIClamp'] = 0

zn% screen -L ipython -i wscale.py (create _allData.json)

Pavos-MBP% scp no:/$PWD/v47_batch3/v47_batch3_allData.json v47_batch3/. ; scp no:/$PWD/v47_batch3/v47_batch3_batch.json v47_batch3/.
v47_batch3_allData.json                                                                                                  100%  162MB   6.8MB/s   00:23
v47_batch3_batch.json

Pavos-MBP% ipy wscale.py (calculate wnorm)

Pavos-MBP% ipy netParams_cell.py (save cell .pkls)

** v47_batch4 - SOM2,PV2 wnorm with AMPA/NMDA 0.5:0.5
	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	#initCfg[('GroupNetStimW1', 'pop')] = 'None'
	initCfg[('NetStim1', 'delay')] = 1
	initCfg['addIClamp'] = 0


b = weightNormE(pops=['IT2','IT4','IT5B', 'IT6', 'CT6'], rule='IT2_reduced')
** v47_batch5 - EI balance, PT ih from v45_tune91, wnorm, new synMech ratios
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio

	params['IEGain'] = [0.5, 1.0]
	params['IIGain'] = [0.5, 1.0]
python scancel_nodes.py 12516411 12516849
	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	groupedParams = ['IEGain', 'IIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1200.0

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IPTGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


*** no depol with good raster
- 00 20 10 20
- 00 21 00 10

- 11 20 00 10
- 11 20 00 22
- 11 20 11 10 - good - v47_batch6
- 11 20 11 21
- 11 20 22 21 - good - v47_batch7
- 11 21 00 12

** v47_batch6 - long stim, v47_batch5 11 20 11 10

	params['ihGbar'] = [0.0, 0.25, 0.5, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]
	params[('pulse', 'end')] = [1700, 1900]


	# initial config
	initCfg = {}
	initCfg['duration'] = 3.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1500.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] =  1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results
None:
- ihGbar:
-- 0.0, 0.25: PT too high (9.5hz, 6.7hz), osc (~30hz); other pops mostly silent
-- 0.5: reasonable PT (4.4hz), beta osc (~24 hz); L2/3,4,5A - very low; layers 5B,6 - ok
-- 1.0: good low PT (0.8hz); higher in other regions

TPO:
- ih 0.5: prev osc in deep; IT5A very high (similar for longer/stronger stims); stim dec PT (IT5A->PV5->PT; +depol block); -bad
- ih 1.0: prev osc in all; stim inc; IT5A very high

TVL:
- ih 0.5: osc in deep; low in upper: stim inc -- good
- ih 1.0: prev osc in all; stim inc but less;

S1: same as TPO

S2: same as TPO

M2:
- ih 0.5: slight increase in PT; low upper (similar for longer/stronger) - ok

OC:
- ih 0.5: slight decrease in PT
- ih 1.0: no change in PT

*** Conclusions
- sensory-mediated stims overstimulate PT
-- seems related to IT5A - very high rate -> inc PV5A+PV5B -> dec PT
-- but not clear why doesn't happen with ih=1.0! netClamp PT?
-- try reducing IT5A; dysinBias should help;
-- try reducing effect of ih

** v47_batch7 - long stim, v47_batch5 11 20 22 21
NOTE: update netpyne from 0.7.3 to 0.7.4 -- shoudlnt affect

	params['ihGbar'] = [0.0, 0.25, 0.5, 1.0, 2.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC']# ['cM1']
	params[('pulse', 'rate')] = [15, 20]
	params[('pulse', 'end')] = [1700, 1900]


	# initial config
	initCfg = {}
	initCfg['duration'] = 3.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1500.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] =  1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results
None:
- ih 0.0, 0.25: PT too high (9.4hz, 6.2hz), osc (~30hz); other pops mostly silent
- ih 0.5: reasonable PT (3.5hz), beta osc (~24 hz); L2/3,4,5A - very low; layers 5B,6 - ok
- ih 1.0: good low PT (0.9hz); higher in other regions

TPO:
- 0.5: IT5A very high; stim dec PT (IT5A->PV5->PT; +depol block)
- 1.0: ok, brief PT depblock

TVL:
- 0.5, 1.0: good, stim inc PT, more with low ih

S1: similar to TPO; triggers ongoing activity in upper layers

S2: similar to TPO; triggers ongoing activity in upper layers

M2: ih 0.5: slight increase in PT; low upper (similar for longer/stronger) - ok

OC:
- ih 0.5: slight decrease in PT
- ih 1.0: no change in PT

*** Conclusions
- PRACTICALLY IDENTICAL RESULTS TO v47_batch6 (qualitatively)

- ih 1.0 - slightly less IT2 and IT5A activity than batch6

** v47_batch8 - EI balance, PT ih from v45_tune91, wnorm, new synMech ratios, disynpatic=1.0 - analyze
NOTE!!! - missing some, rerun batch - only 3 missing - reran

cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio


	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 20.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1200.0

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['IEdisynapticBias'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
- overall much less synchrony; less clear osc in all layers; more noise
- no example with IT2 activity before stim
- num conns:
- run on zn to test conn -- v47_batch9

** v47_batch9 - v47_batch5 11 20 11 10; save/explore conns; disynaptic = [None, 0.9, 1.0]; enable netClamp
- check effect of disynaptic on conns (conn bar chart + netClamp on PT)
- check border effect perform netClamp

- batch custom():
	params = specs.ODict()

	params['IEdisynapticBias'] = [0.0, 0.9, 1.0]

	# initial config
	initCfg = {}

	initCfg['saveDataInclude'] = ['simData', 'simConfig', 'netParams', 'net']
	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = True
	inifCfg[('analysis','plotRaster')] = False
	inifCfg[('analysis','plotRaster')] = False
	initCfg[('analysis', 'calculateDisynaptic')] = True

	allpops = ['IT2','PV2','SOM2','IT4','IT5A','PV5A','SOM5A','IT5B','PT5B','PV5B','SOM5B','IT6','CT6','PV6','SOM6']
	initCfg[('analysis', 'plotConn')] = {'includePre': allpops,
										'includePost': allpops,
										'feature': 'numConns',
										'figSize': (10,10),
										'groupBy': 'pop',
 										'graphType': 'bar',
 										'synOrConn': 'conn',
 										'synMech': None,
 										'saveData': None,
 										'saveFig': 1,
 										'showFig': 0}

	initCfg['duration'] = 20 #3.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar']
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] =  1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results IT5A border effect
- artifact due to binning != L5A borders -- ok

*** results disynapticBias
In [4]: connfile='../data/v47_batch9/v47_batch9_0.json'

In [5]: connsFile='../data/v47_batch9/v47_batch9_0_conns_full.json'

In [6]: tagsFile='../data/v47_batch9/v47_batch9_0_tags_full.json'

In [7]: sim.ijsonLoad(connfile, tagsGidRange=None, connsGidRange=None, loadTags=True, loadConns=True, tagFormat=['pop', 'y', 'ynorm'], connFormat=['loc', 'weight', 'preGid', 'delay', 'sec', 'synMech'], saveTags=tagsFile, saveConns=connsFile)


In [4]: sim.analysis.plotConn(includePost=['IT4', 'IT5A','IT5B', 'PT5B'],tagsFile=tagsFile, connsFile=connsFile, saveFig='../data/v47_batch9/v47_batch9_0_conn.png')

- conn matrices
    combs = [0, 1, 2]
    post = ['IT4', 'IT5A', 'IT5B', 'IT5B', 'PT5B']
    pre = ['PV5A', 'PV5B', 'SOM5A', 'SOM5B'] ## include IT2 ?
    feature = 'numConns'
    graphType = 'bar'

- None and 0.9 identical; but 1.0 more inh to IT4 and less to IT5B

- NOTE: weird that proportion of inh5A:inh5B is identical for IT5A, but higher inh5A->IT4 and higher inh5B->IT5B (as as
  should be!)
-- check inh -> IT5A
-- ah, numConns same, but weight decreased -- still contribution of inh5B->IT5A > inh5a->IT5B; but now inh5A->IT5A >
-- inh5B->IT5A (~3-4x)
-- actually prob is func of distance, so weight should be same, but numConns different!!
-- checking if cell locs are ok via plot2Dnet (loading from json file with x,y,z):
tagsFile='../data/v47_batch9/v47_batch9_0_tags_fullpos.json'
sim.ijsonLoad(connfile, tagsGidRange=None, connsGidRange=None, loadTags=True, loadConns=False, tagFormat=['pop', 'x', 'y', 'z'], saveTags=tagsFile, saveConns=None)


- strength comparison also shows almost identical for 3 cases - despite hugely diff dynamics 0.9 vs 1.0 !

** v47_batch10 - Explore disynaptic, ihgbar and IEWeight_s0 - BUG!
IT5A without weighNorm!

	params = specs.ODict()

	params['IEdisynapticBias'] = [None, 0.7, 0.8, 0.9, 1.0]
	params['ihGbar'] = [0.5, 1.0]
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]

	# initial config
	initCfg = {}

	initCfg['saveDataInclude'] = ['simData', 'simConfig', 'netParams']#, 'net']
	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False
	initCfg[('analysis','plotRaster')] = False
	initCfg[('analysis','plotRaster')] = False
	initCfg[('analysis', 'calculateDisynaptic')] = False

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4

	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 15
	initCfg[('pulse', 'end')] = 1600

*** results
- radical change in spk pattern between 1.0 vs <1.0 -- not gradual
- check that disyn implementation ok - ok
- test values closer to 1.0 -- 0.95, 0.96, 0.97, 0.98, 0.99

** v47_batch11 - explore disynaptic closer to 1.0 (dynamics) - analyse
- MPI ERROR WHEN GATHERING - too many cores
- LOWERED to 12 CORES - also error when gathering!
-- .run: orterun noticed that process rank 4 with PID 31318 on node comet-16-43 exited on signal 9 (Killed).
-- .err: slurmstepd: Exceeded step memory limit at some point.
- REPEAT BUT DON'T SAVE DATA
- Had bug - IT5A no weightNorm - rerunning

params['IEdisynapticBias'] = [None, 0.8, 0.9, 0.95, 0.96, 0.97, 0.98, 0.99, 0.999, 1.0]
	#params['ihGbar'] = [0.5, 1.0]
	#params[('IEweights',0)] =  [0.8, 1.0, 1.2]

	# initial config
	initCfg = {}

	initCfg['saveDataInclude'] = ['simData', 'simConfig', 'netParams']#, 'net']
	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = True
	pre = ['PV5A', 'PV5B', 'SOM5A', 'SOM5B']
	post = ['IT4', 'IT5A', 'IT5B', 'IT5B', 'PT5B']
	initCfg[('analysis', 'calculateDisynaptic')] = {'includePost': post, 'includePre': pre, 'includePrePre': post}
	initCfg[('analysis', 'plotConn')] = {'showFig': False, 'saveFig': True,
							            'includePost': post,
							            'includePre': pre,
							            'feature': 'strength',
							            'graphType': 'bar'}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihGbar'] = 1.0
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 15
	initCfg[('pulse', 'end')] = 1600

*** results
- no clear pattern

** v47_batch12 - explore disynaptic closer to 1.0 (conn)
- run on zn with 1 core
- save conn, plot conn, calculate disyn
- save conn using compact format (list vs dict)
- crashed on zn but running on mac
-- implemente load from compact conn -- takes 30 mins (10 min on zn) vs ~4 hours to create net

- ran on zn manually - took 2.5 days


	params['IEdisynapticBias'] = [None, 0.9, 0.95, 0.97,  0.99, 1.0]

	# initial config
	initCfg = {}

	initCfg['saveDataInclude'] = ['simData', 'simConfig', 'netParams', 'net']
	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = True
	pre = ['PV5A', 'PV5B', 'SOM5A', 'SOM5B']
	post = ['IT4', 'IT5A', 'IT5B', 'IT5B', 'PT5B']
	initCfg[('analysis', 'calculateDisynaptic')] = {'includePost': post, 'includePre': pre, 'includePrePre': post}
	initCfg[('analysis', 'plotConn')] = {'showFig': False, 'saveFig': True,
							            'includePost': post,
							            'includePre': pre,
							            'feature': 'strength',
							            'graphType': 'bar'}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihGbar'] = 1.0
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 15
	initCfg[('pulse', 'start')] = 1000
	initCfg[('pulse', 'end')] = 1100

*** results
v47_batch12_0
- disyn=None:

    Total disynaptic connections: 1330238 / 1775633 (74.92%)
    time ellapsed (s):  221892.105064 (2.5 days)

v47_batch12_1
- disyn=0.9

    Total disynaptic connections: 1330238 / 1775633 (74.92%)
    time ellapsed (s):  206568.465438

v47_batch12_2
- disyn=1.0?
    Total disynaptic connections: 1330238 / 1775633 (74.92%)
    time ellapsed (s):  251967.016435

?? - not sure whats going on and why all identical

** v47_batch13 - long stim, v47_batch5 11 20 11 10, shorter+weaker stims - analyse
BUG: using wrong PT

- v47_batch13_1_0_3_1_1 finished before completing (3h -> 2.3 sec; many spikes) - rerun?

	params['ihGbar'] = [0.25, 0.5, 1.0]
	params['weightNormThreshold'] = [4.0, 5.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC'] # 'cM1',
	params[('pulse', 'rate')] = [10, 15]
	params[('pulse', 'end')] = [1550, 1600]


	# initial config
	initCfg = {}
	initCfg['duration'] = 3.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1500.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results
NOTE: 10 Hz with 50 ms duration has no effect since too low+short

None: osc in all layers, good modulation of ih (0.5 vs 1.0) - good!

TPO: good!
- 0.5 - upper inc -> PT inc (~3 hz) (some depol blockade)
- 1.0 - upper inc -> no PT inc (stays ~0.13 hz)
- wnorm=5 - more depol block and ih=1.0 too high

TVL: good!
- 0.5 - PT inc (1.5 - 2hz); upper some small effect (due to inh?)
- 1.0 - little effect on PT (< 0.5 hz)

S1: good!
- 0.5 - upper strong inc -> PT inc (~2.6 hz for 15hz, 50ms) (possible dep block)
- 1.0 - upper strong inc -> not PT inc; except for 15hz, 100ms -> triggers osc

S2: good!
- 0.5 - upper strong inc -> PT inc (~3 hz) (no dep block)
- 1.0 - upper strong inc -> no/very low PT inc;

M2:
- 0.5 - PT inc; upper dec (IT2 silenced!) (due to ihn?)
- 1.0 - little effect on PT; some on IT5B

OC:
- 0.5 - L6 inc; some PT inc; IT5B inc; upper lower (IT2 silenced); high input triggers deep osc
- 1.0 - similar but lower PT

*** chose stim to get stats (5x5 seeds)
ih 0.5 PT/upperIT - ih 1.0 PT/upperIT peak rates (hz)

0_0 (10hz, 50ms) - N/A

0_1 (10hz, 100ms): no depol block; good - chosen!

-- TPO: 20/95 - 0.5/17.5
-- TVL: 20/20 - 2/10
-- S1:  10/70 - 0/40
-- S2:  10/65 - 1/23
-- M2:  22/12 - 1/12
-- OC:  10/25 - 3/40

1_0 (15hz, 50ms):  1 depol block; good

-- TPO: 55/125 (depol) - 0.5/26
-- TVL: 40/30 - 11/1
-- S1:  35/110 - 0.5/60
-- S2:  40/110 - 3/36
-- M2:  48/40 - 1/11
-- OC:  15/45 - 8/50


1_1 (10hz, 100ms):

** v47_batch14 - long stim, v47_batch5 11 20 11 10, shorter+weaker stims, IEdisyn=[0.8,0.99] - run on cm (test zn)
- BUG: using wrong PT
- rerunning becasue sim.runSim commented out
- testing in zn to make sure no errors

	params['ihGbar'] = [0.5, 1.0]
	params['IEdisynapticBias'] = [0.8, 0.99]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S1', 'S2', 'M2', 'OC'] # 'cM1',
	params[('pulse', 'rate')] = [10, 15]
	params[('pulse', 'end')] = [1550, 1600]


	# initial config
	initCfg = {}
	initCfg['duration'] = 3.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.45 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -80  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.6
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1500.0

	initCfg['weightNormThreshold'] = 4.0

	#initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results
- ih 0.5 leads to very high PT which inhibits L2 - no spikes
- TPO, TVL, S1, S2 - ih 1.0 > 0.5

** v47_manualTune
tune1 - PT epsp 0.5 - 0.5 mV
tune3 - PT ipsp 0.5 - 0.669 mV (twice as bfore PT tune) -- so need to reduce I weights by 2

tune10 - netClamp: conns=v47_batch9_2, spks=v47_batch8_2_0_1_1_1_0; cell=3481"
tune12 - netClamp: conns=v47_batch9_0, spks=v47_batch8_2_0_1_1_1_0; cell=3571" (edge)
tune13 - netClamp: conns=v47_batch9_0, spks=v47_batch8_2_0_1_1_1_0; cell=3597" (center)

*** tune15 - 21 - fixing bug due to ih ehd global
*** tune22 - 36 -  retuning PT ih (effect of different params)
- starting params:
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihlkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

--------------------------------------------
cfg.simLabel : v47_tune22
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 36.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 12.85 - 13.22
Sub 0.1nA    : 3.99 - 20.21% sag
--------------------------------------------

- *AIM IS ~:
--------------------------------------------
cfg.simLabel : v47_tune22
fI 0.3-0.4-0.6nA :8.00 - 19.00 - 38.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -80 - -90
Peak ih-zd   : 35 - 25
Sub 0.1nA    : 12(sam), 6(suter) - 20% sag
--------------------------------------------


- *Effect of inc ihlkc*:
-- fI: dec fI (low+)  4-2
-- stim: dec ih  4
-- RMP: dec ih
-- peak: inc ih
-- sub: dec + inc sag

tune23: ihlkc=0.4
--------------------------------------------
cfg.simLabel : v47_tune23
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 37.00
stim ih-zd   : 18.00 - 63.00 (45.00)
RMP ih-zd    : -74.51 - -84.90
Peak ih-zd   : 12.83 - 13.22
Sub 0.1nA    : 4.06 - 20.10% sag
--------------------------------------------

tune24: ihlkc=0.5
--------------------------------------------
cfg.simLabel : v47_tune24
fI 0.3-0.4-0.6nA : 0.00 - 11.00 - 35.00
stim ih-zd   : 14.00 - 63.00 (49.00)
RMP ih-zd    : -74.86 - -84.90
Peak ih-zd   : 12.75 - 13.22
Sub 0.1nA    : 3.92 - 20.29% sag
--------------------------------------------

- *Effect of inc (neg) ihlke*:
-- fI: dec (low+)  17-8
-- stim: dec ih  11
-- RMP: dec ih
-- peak: inc
-- sub: dec (inc sag)

tune25: ihlke=-75
--------------------------------------------
cfg.simLabel : v47_tune25
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 40.00
stim ih-zd   : 22.00 - 63.00 (41.00)
RMP ih-zd    : -73.32 - -84.90
Peak ih-zd   : 12.94 - 13.22
Sub 0.1nA    : 4.17 - 15.72% sag
--------------------------------------------

tune26: ihlke=-85
--------------------------------------------
cfg.simLabel : v47_tune26
fI 0.3-0.4-0.6nA : 0.00 - 2.00 - 32.00
stim ih-zd   : 11.00 - 63.00 (52.00)
RMP ih-zd    : -75.87 - -84.90
Peak ih-zd   : 12.71 - 13.22
Sub 0.1nA    : 3.82 - 24.46% sag
--------------------------------------------

- *Effect of inc ihSlope*:
-- fI: dec (low+)  5 - 3
-- stim: dec ih  6
-- RMP: inc ih
-- peak: inc ih
-- sub: inc (dec sag)

tune27: ihSlope=14*1.5
--------------------------------------------
cfg.simLabel : v47_tune27
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 37.00
stim ih-zd   : 19.00 - 63.00 (44.00)
RMP ih-zd    : -74.81 - -84.90
Peak ih-zd   : 12.99 - 13.22
Sub 0.1nA    : 4.20 - 19.43% sag
--------------------------------------------

tune28: ihSlope=14*2.5
--------------------------------------------
cfg.simLabel : v47_tune28
fI 0.3-0.4-0.6nA : 0.00 - 10.00 - 34.00
stim ih-zd   : 13.00 - 63.00 (50.00)
RMP ih-zd    : -74.52 - -84.90
Peak ih-zd   : 12.71 - 13.22
Sub 0.1nA    : 3.76 - 21.35% sag
--------------------------------------------

- *Effect of inc dendNa*:
-- fI: dec (high+)  0 - 1
-- stim: same  1
-- RMP: same
-- peak: inc
-- sub: same

tune29: dendNa=0.35
--------------------------------------------
cfg.simLabel : v47_tune29
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 36.00
stim ih-zd   : 16.00 - 64.00 (48.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 12.35 - 12.64
Sub 0.1nA    : 3.99 - 20.20% sag
--------------------------------------------

tune30: dendNa=0.45
--------------------------------------------
cfg.simLabel : v47_tune30
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 35.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 13.28 - 13.80
Sub 0.1nA    : 3.99 - 20.21% sag
--------------------------------------------


- *Effect of inc axonNa*:
-- fI: rot clockwise  2 - -2
-- stim: dec zd  -8
-- RMP: same
-- peak: inc
-- sub: same

tune31: axonNa=6
--------------------------------------------
cfg.simLabel : v47_tune31
fI 0.3-0.4-0.6nA : 0.00 - 12.00 - 37.00
stim ih-zd   : 16.00 - 68.00 (52.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 11.45 - 11.66
Sub 0.1nA    : 3.99 - 20.19% sag
--------------------------------------------

tune32: axonNa=8
--------------------------------------------
cfg.simLabel : v47_tune32
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 35.00
stim ih-zd   : 16.00 - 60.00 (44.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 14.02 - 14.49
Sub 0.1nA    : 3.99 - 20.22% sag
--------------------------------------------


- *Effect of inc gpas*:
-- fI: dec (low+)   4 - 2
-- stim: dec both  0
-- RMP: inc ih, dec zd
-- peak: dec ih / same
-- sub: dec (inc sag)


tune33: gpas=0.5
--------------------------------------------
cfg.simLabel : v47_tune33
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 37.00
stim ih-zd   : 17.00 - 64.00 (47.00)
RMP ih-zd    : -74.57 - -85.32
Peak ih-zd   : 12.86 - 13.25
Sub 0.1nA    : 4.07 - 20.08% sag
--------------------------------------------

tune34: gpas=0.7
--------------------------------------------
cfg.simLabel : v47_tune34
fI 0.3-0.4-0.6nA : 0.00 - 11.00 - 35.00
stim ih-zd   : 15.00 - 62.00 (47.00)
RMP ih-zd    : -74.81 - -84.57
Peak ih-zd   : 12.78 - 13.23
Sub 0.1nA    : 3.91 - 20.31% sag
--------------------------------------------


- *Effect of inc epas*:
-- fI: dec (low+)   12 - 6
-- stim: dec (zd+)  -5
-- RMP: dec
-- peak: dec (zd x 10)
-- sub: dec (inc sag)


tune35: epas=0.8
--------------------------------------------
cfg.simLabel : v47_tune35
fI 0.3-0.4-0.6nA : 0.00 - 17.00 - 39.00
stim ih-zd   : 19.00 - 68.00 (49.00)
RMP ih-zd    : -73.71 - -79.01
Peak ih-zd   : 12.94 - 13.19
Sub 0.1nA    : 4.09 - 17.33% sag
--------------------------------------------

tune36: epas=1.0
--------------------------------------------
cfg.simLabel : v47_tune36
fI 0.3-0.4-0.6nA : 0.00 - 5.00 - 33.00
stim ih-zd   : 13.00 - 57.00 (44.00)
RMP ih-zd    : -75.65 - -91.43
Peak ih-zd   : 12.72 - 13.14
Sub 0.1nA    : 3.88 - 23.25% sag
--------------------------------------------



*** tune37 -   - retuning PT ih (balance fI curve, sheets fig11 effect, RMP, spk peak)
tune 37 - axonNa=8, ihlkc=0.4
--------------------------------------------
cfg.simLabel : v47_tune37
fI 0.3-0.4-0.6nA : 0.00 - 16.00 - 36.00
stim ih-zd   : 18.00 - 60.00 (42.00)
RMP ih-zd    : -74.51 - -84.90
Peak ih-zd   : 14.09 - 14.49
Sub 0.1nA    : 4.07 - 20.11% sag
--------------------------------------------

tune 38 - axonNa=8, ihSlope=14*1
--------------------------------------------
cfg.simLabel : v47_tune38
fI 0.3-0.4-0.6nA : 0.00 - 17.00 - 37.00
stim ih-zd   : 21.00 - 60.00 (39.00)
RMP ih-zd    : -74.90 - -84.90
Peak ih-zd   : 14.17 - 14.49
Sub 0.1nA    : 4.38 - 18.83% sag
--------------------------------------------

tune39 - axonNa=8, gpas=0.7
--------------------------------------------
cfg.simLabel : v47_tune39
fI 0.3-0.4-0.6nA : 0.00 - 16.00 - 36.00
stim ih-zd   : 20.00 - 59.00 (39.00)
RMP ih-zd    : -75.03 - -84.57
Peak ih-zd   : 14.13 - 14.47
Sub 0.1nA    : 4.28 - 18.99% sag
--------------------------------------------


tune40 - axonNa=9, gpas=0.7
--------------------------------------------
cfg.simLabel : v47_tune40
fI 0.3-0.4-0.6nA : 0.00 - 17.00 - 35.00
stim ih-zd   : 20.00 - 57.00 (37.00)
RMP ih-zd    : -75.03 - -84.57
Peak ih-zd   : 15.07 - 15.50
Sub 0.1nA    : 4.28 - 19.01% sag
--------------------------------------------

tune41 - axonNa=8, ihSlope=14, gpas=0.55
--------------------------------------------
cfg.simLabel : v47_tune41
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 38.00
stim ih-zd   : 22.00 - 61.00 (39.00)
RMP ih-zd    : -74.84 - -85.10
Peak ih-zd   : 14.16 - 14.51
Sub 0.1nA    : 4.43 - 18.73% sag
--------------------------------------------

tune42 - ihSlope=14
--------------------------------------------
cfg.simLabel : v47_tune42
fI 0.3-0.4-0.6nA : 0.00 - 17.00 - 39.00
stim ih-zd   : 22.00 - 63.00 (41.00)
RMP ih-zd    : -74.90 - -84.90
Peak ih-zd   : 13.06 - 13.22
Sub 0.1nA    : 4.38 - 18.81% sag
--------------------------------------------

tune43 - ihSlope=14, epas=0.85
--------------------------------------------
cfg.simLabel : v47_tune43
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 40.00
stim ih-zd   : 23.00 - 66.00 (43.00)
RMP ih-zd    : -74.35 - -81.86
Peak ih-zd   : 13.03 - 13.18
Sub 0.1nA    : 4.44 - 17.19% sag
--------------------------------------------


tune44 - ihSlope=14, gpas=0.5
--------------------------------------------
cfg.simLabel : v47_tune44
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 40.00
stim ih-zd   : 23.00 - 64.00 (41.00)
RMP ih-zd    : -74.77 - -85.32
Peak ih-zd   : 13.00 - 13.25
Sub 0.1nA    : 4.48 - 18.62% sag
--------------------------------------------


tune45 -  ihlke=-75, axonNa=8
--------------------------------------------
cfg.simLabel : v47_tune45
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 39.00
stim ih-zd   : 21.00 - 60.00 (39.00)
RMP ih-zd    : -73.32 - -84.90
Peak ih-zd   : 14.06 - 14.49
Sub 0.1nA    : 4.18 - 15.73% sag
--------------------------------------------


tune46 - ihlke=-75, ihSlope=14,
--------------------------------------------
cfg.simLabel : v47_tune46
fI 0.3-0.4-0.6nA : 1.00 - 21.00 - 42.00
stim ih-zd   : 26.00 - 63.00 (37.00)
RMP ih-zd    : -73.65 - -84.90
Peak ih-zd   : 13.15 - 13.22
Sub 0.1nA    : 4.55 - 14.86% sag
--------------------------------------------


tune47 - ihlke=-75, epas=0.85,
--------------------------------------------
cfg.simLabel : v47_tune47
fI 0.3-0.4-0.6nA : 0.00 - 20.00 - 42.00
stim ih-zd   : 23.00 - 66.00 (43.00)
RMP ih-zd    : -72.81 - -81.86
Peak ih-zd   : 12.97 - 13.18
Sub 0.1nA    : 4.22 - 14.38% sag
--------------------------------------------


tune48 - ihlke=-75, gpas=0.55,
--------------------------------------------
cfg.simLabel : v47_tune48
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 41.00
stim ih-zd   : 22.00 - 64.00 (42.00)
RMP ih-zd    : -73.25 - -85.10
Peak ih-zd   : 12.97 - 13.21
Sub 0.1nA    : 4.22 - 15.60% sag
--------------------------------------------

tune49 - ihSlope=14, ihlke=-75, gpas=0.5,
--------------------------------------------
cfg.simLabel : v47_tune49
fI 0.3-0.4-0.6nA : 7.00 - 22.00 - 43.00
stim ih-zd   : 28.00 - 64.00 (36.00)
RMP ih-zd    : -73.48 - -85.32
Peak ih-zd   : 13.19 - 13.25
Sub 0.1nA    : 4.66 - 14.55% sag
--------------------------------------------

tune50 - ihSlope=14, ihlke=-75, gpas=0.5, epas=0.85
--------------------------------------------
cfg.simLabel : v47_tune50
fI 0.3-0.4-0.6nA : 11.00 - 23.00 - 45.00
stim ih-zd   : 29.00 - 67.00 (38.00)
RMP ih-zd    : -72.99 - -82.42
Peak ih-zd   : 13.22 - 13.24
Sub 0.1nA    : 4.71 - 13.28% sag
--------------------------------------------

tune51 - ihlke=-75, gpas=0.5, epas=0.85
--------------------------------------------
cfg.simLabel : v47_tune51
fI 0.3-0.4-0.6nA : 1.00 - 21.00 - 42.00
stim ih-zd   : 24.00 - 67.00 (43.00)
RMP ih-zd    : -72.73 - -82.42
Peak ih-zd   : 13.05 - 13.24
Sub 0.1nA    : 4.31 - 14.33% sag
--------------------------------------------

tune52 - ihlke=-75, gpas=0.5, epas=0.85, ihlkc=0.5
--------------------------------------------
cfg.simLabel : v47_tune52
fI 0.3-0.4-0.6nA : 0.00 - 20.00 - 42.00
stim ih-zd   : 22.00 - 67.00 (45.00)
RMP ih-zd    : -72.84 - -82.42
Peak ih-zd   : 12.95 - 13.24
Sub 0.1nA    : 4.24 - 14.30% sag
--------------------------------------------

tune53 - ihlke=-75, ihlkc=0.5, gpas=0.5
--------------------------------------------
cfg.simLabel : v47_tune53
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 40.00
stim ih-zd   : 21.00 - 64.00 (43.00)
RMP ih-zd    : -73.27 - -85.32
Peak ih-zd   : 12.98 - 13.25
Sub 0.1nA    : 4.20 - 15.41% sag
--------------------------------------------


tune54 - ihlke=-75, ihlkc=0.5, gpas=0.5, axonNa=8
--------------------------------------------
cfg.simLabel : v47_tune54
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 39.00
stim ih-zd   : 21.00 - 61.00 (40.00)
RMP ih-zd    : -73.27 - -85.32
Peak ih-zd   : 14.12 - 14.52
Sub 0.1nA    : 4.20 - 15.43% sag
--------------------------------------------

tune55 - ihlke=-75, ihlkc=0.5, gpas=0.5, axonNa=6
--------------------------------------------
cfg.simLabel : v47_tune55
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 42.00
stim ih-zd   : 22.00 - 69.00 (47.00)
RMP ih-zd    : -73.27 - -85.32
Peak ih-zd   : 11.56 - 11.59
Sub 0.1nA    : 4.19 - 15.40% sag
--------------------------------------------

tune56 - ihlke=-72, ihlkc=0.5, gpas=0.5
--------------------------------------------
cfg.simLabel : v47_tune56
fI 0.3-0.4-0.6nA : 6.00 - 22.00 - 43.00
stim ih-zd   : 25.00 - 64.00 (39.00)
RMP ih-zd    : -72.28 - -85.32
Peak ih-zd   : 13.05 - 13.25
Sub 0.1nA    : 4.31 - 12.56% sag
--------------------------------------------

tune57 - ihlke=-72, ihlkc=0.5, gpas=0.5, axonNa=6
--------------------------------------------
cfg.simLabel : v47_tune57
fI 0.3-0.4-0.6nA : 0.00 - 22.00 - 45.00
stim ih-zd   : 26.00 - 69.00 (43.00)
RMP ih-zd    : -72.28 - -85.32
Peak ih-zd   : 11.61 - 11.59
Sub 0.1nA    : 4.31 - 12.54% sag
--------------------------------------------

tune58 - ihlke=-72, ihlkc=0.5, gpas=0.5, axonNa=6, dendNa=0.45

- NEED TO PARAMETRIZE somaNa vs dendNa --> netParams v48

** v48_manualTune
*** tune1 - 71 - Tuning PT ih after parametrizing somaNA (followed from v47_manualTune)
somaNa values (S/cm2) and dend ratio:
- PT_full (Neym17): 0.0153 (1:1)
- PT_6comp (Neym17): 0.0345 (1:1)
- PT_6comp (JoeGraham): 0.0345 (10:1)
- PT_full (Hay11): 2.0 (20:1)
- PYR_full (Srdjan/Penny): 0.09 (6-12:1)

- Starting params:
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.45 # ih leak param (used in Migliore)
cfg.ihlkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -80  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = False  # simulate TTX; set gnabar=0s
cfg.somaNa = 1.0
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

--------------------------------------------
cfg.simLabel : v47_tune22
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 36.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 12.85 - 13.22
Sub 0.1nA    : 3.99 - 20.21% sag
--------------------------------------------

- *AIM IS ~:
--------------------------------------------
cfg.simLabel : v47_tune22
fI 0.3-0.4-0.6nA :8.00 - 19.00 - 38.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -80 - -90
Peak ih-zd   : 35 - 25
Sub 0.1nA    : 12(sam), 6(suter) - 20% sag
--------------------------------------------


tune1 - ihlke=-72, ihlkc=0.5, gpas=0.5
--------------------------------------------
cfg.simLabel : v48_tune1
fI 0.3-0.4-0.6nA : 6.00 - 22.00 - 43.00
stim ih-zd   : 25.00 - 64.00 (39.00)
RMP ih-zd    : -72.28 - -85.32
Peak ih-zd   : 13.05 - 13.25
Sub 0.1nA    : 4.31 - 12.56% sag
--------------------------------------------

- *Effect of inc somaNa*:
-- fI: rot clockwise  1 - -1
-- stim: dec zd  3
-- RMP: same
-- peak: inc both strong
-- sub: same

tune2 - somaNa=2.0
--------------------------------------------
cfg.simLabel : v48_tune2
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 35.00
stim ih-zd   : 16.00 - 60.00 (44.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 17.14 - 17.50
Sub 0.1nA    : 3.99 - 20.22% sag
--------------------------------------------

tune4 - somaNa=3.0
--------------------------------------------
cfg.simLabel : v48_tune4
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 34.00
stim ih-zd   : 16.00 - 58.00 (42.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 20.32 - 20.77
Sub 0.1nA    : 3.99 - 20.23% sag
--------------------------------------------

tune5 - somaNa=4.0
--------------------------------------------
cfg.simLabel : v48_tune5
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 34.00
stim ih-zd   : 16.00 - 56.00 (40.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 22.91 - 23.29
Sub 0.1nA    : 3.99 - 20.24% sag
--------------------------------------------

tune6 - somaNa=2.0, dendNa=0.3
--------------------------------------------
cfg.simLabel : v48_tune6
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 36.00
stim ih-zd   : 16.00 - 61.00 (45.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 16.35 - 16.61
Sub 0.1nA    : 3.99 - 20.21% sag
--------------------------------------------


tune7 - somaNa=3.0, dendNa=0.3
--------------------------------------------
cfg.simLabel : v48_tune7
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 35.00
stim ih-zd   : 16.00 - 59.00 (43.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 19.70 - 20.04
Sub 0.1nA    : 3.99 - 20.22% sag
--------------------------------------------

tune8 - somaNa=4.0, dendNa=0.3
--------------------------------------------
cfg.simLabel : v48_tune8
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 34.00
stim ih-zd   : 16.00 - 56.00 (40.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 22.34 - 22.71
Sub 0.1nA    : 3.99 - 20.23% sag
--------------------------------------------


tune9 - somaNa=2.0, dendNa=0.2
--------------------------------------------
cfg.simLabel : v48_tune9
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 37.00
stim ih-zd   : 16.00 - 62.00 (46.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 15.49 - 15.71
Sub 0.1nA    : 3.99 - 20.20% sag
--------------------------------------------


tune10 - somaNa=3.0, dendNa=0.2
--------------------------------------------
cfg.simLabel : v48_tune10
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 36.00
stim ih-zd   : 16.00 - 59.00 (43.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 19.09 - 19.28
Sub 0.1nA    : 3.99 - 20.21% sag
--------------------------------------------


tune11 - somaNa=4.0, dendNa=0.2
--------------------------------------------
cfg.simLabel : v48_tune11
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 35.00
stim ih-zd   : 16.00 - 57.00 (41.00)
RMP ih-zd    : -74.69 - -84.90
Peak ih-zd   : 21.88 - 22.09
Sub 0.1nA    : 3.99 - 20.22% sag
--------------------------------------------

%% ihlke=-72, ihlkc=0.5, gpas=0.5
- tune12 - somaNa=3.0, dendNa=0.3, gpas=0.5
--------------------------------------------
cfg.simLabel : v48_tune12
fI 0.3-0.4-0.6nA : 0.00 - 16.00 - 36.00
stim ih-zd   : 17.00 - 60.00 (43.00)
RMP ih-zd    : -74.57 - -85.32
Peak ih-zd   : 19.81 - 20.05
Sub 0.1nA    : 4.08 - 20.10% sag
--------------------------------------------

- tune13 - somaNa=3.0, dendNa=0.3, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune13
fI 0.3-0.4-0.6nA : 9.00 - 22.00 - 41.00
stim ih-zd   : 25.00 - 59.00 (34.00)
RMP ih-zd    : -72.40 - -84.90
Peak ih-zd   : 19.87 - 20.04
Sub 0.1nA    : 4.29 - 13.02% sag
--------------------------------------------

- tune14 - somaNa=3.0, dendNa=0.3, ihlkc=0.5
--------------------------------------------
cfg.simLabel : v48_tune14
fI 0.3-0.4-0.6nA : 0.00 - 13.00 - 34.00
stim ih-zd   : 14.00 - 59.00 (45.00)
RMP ih-zd    : -74.86 - -84.90
Peak ih-zd   : 19.62 - 20.04
Sub 0.1nA    : 3.92 - 20.30% sag
--------------------------------------------

- tune15 - somaNa=3.0, dendNa=0.3, ihlke=-72, ihlkc=0.5
--------------------------------------------
cfg.simLabel : v48_tune15
fI 0.3-0.4-0.6nA : 5.00 - 21.00 - 41.00
stim ih-zd   : 23.00 - 59.00 (36.00)
RMP ih-zd    : -72.45 - -84.90
Peak ih-zd   : 19.88 - 20.04
Sub 0.1nA    : 4.23 - 12.87% sag
--------------------------------------------

- tune16 - somaNa=3.0, dendNa=0.3, gpas=0.5, ihlkc=0.5
--------------------------------------------
cfg.simLabel : v48_tune16
fI 0.3-0.4-0.6nA : 0.00 - 14.00 - 35.00
stim ih-zd   : 16.00 - 60.00 (44.00)
RMP ih-zd    : -74.74 - -85.32
Peak ih-zd   : 19.65 - 20.05
Sub 0.1nA    : 4.00 - 20.20% sag
--------------------------------------------

- tune17 - somaNa=3.0, dendNa=0.3, gpas=0.5, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune17
fI 0.3-0.4-0.6nA : 11.00 - 23.00 - 42.00
stim ih-zd   : 26.00 - 60.00 (34.00)
RMP ih-zd    : -72.21 - -85.32
Peak ih-zd   : 19.91 - 20.05
Sub 0.1nA    : 4.39 - 12.72% sag
--------------------------------------------

- tune18 - somaNa=3.0, dendNa=0.3, gpas=0.5, ihlkc=0.5, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune18
fI 0.3-0.4-0.6nA : 10.00 - 22.00 - 42.00
stim ih-zd   : 24.00 - 60.00 (36.00)
RMP ih-zd    : -72.28 - -85.32
Peak ih-zd   : 19.83 - 20.05
Sub 0.1nA    : 4.32 - 12.58% sag
--------------------------------------------

- tune19 - somaNa=3.0, dendNa=0.3, gpas=0.5, ihlkc=0.5, ihlke=-74
--------------------------------------------
cfg.simLabel : v48_tune19
fI 0.3-0.4-0.6nA : 1.00 - 20.00 - 40.00
stim ih-zd   : 22.00 - 60.00 (38.00)
RMP ih-zd    : -72.95 - -85.32
Peak ih-zd   : 19.82 - 20.05
Sub 0.1nA    : 4.24 - 14.47% sag
--------------------------------------------

- tune20 - somaNa=3.0, dendNa=0.3, gpas=0.5, ihlkc=0.55, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune20
fI 0.3-0.4-0.6nA : 7.00 - 22.00 - 41.00
stim ih-zd   : 23.00 - 60.00 (37.00)
RMP ih-zd    : -72.33 - -85.32
Peak ih-zd   : 19.83 - 20.05
Sub 0.1nA    : 4.26 - 12.44% sag
--------------------------------------------

- tune21 - somaNa=4.0, dendNa=0.3, ihlke=-72, ihlkc=0.5
--------------------------------------------
cfg.simLabel : v48_tune21
fI 0.3-0.4-0.6nA : 9.00 - 21.00 - 40.00
stim ih-zd   : 23.00 - 56.00 (33.00)
RMP ih-zd    : -72.45 - -84.90
Peak ih-zd   : 22.47 - 22.71
Sub 0.1nA    : 4.23 - 12.88% sag
--------------------------------------------


- tune22 - somaNa=4.0, dendNa=0.3, gpas=0.5, ihlkc=0.55, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune22
fI 0.3-0.4-0.6nA : 10.00 - 22.00 - 40.00
stim ih-zd   : 23.00 - 57.00 (34.00)
RMP ih-zd    : -72.33 - -85.32
Peak ih-zd   : 22.45 - 22.71
Sub 0.1nA    : 4.26 - 12.46% sag
--------------------------------------------

- tune23 - somaNa=4.0, dendNa=0.3, ihlke=-72, ihlkc=0.55
--------------------------------------------
cfg.simLabel : v48_tune23
fI 0.3-0.4-0.6nA : 5.00 - 21.00 - 39.00
stim ih-zd   : 22.00 - 56.00 (34.00)
RMP ih-zd    : -72.50 - -84.90
Peak ih-zd   : 22.42 - 22.71
Sub 0.1nA    : 4.17 - 12.73% sag
--------------------------------------------

- tune24 - somaNa=4.5, dendNa=0.3, gpas=0.5, ihlkc=0.55, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune24
fI 0.3-0.4-0.6nA : 10.00 - 22.00 - 40.00
stim ih-zd   : 23.00 - 57.00 (34.00)
RMP ih-zd    : -72.33 - -85.32
Peak ih-zd   : 23.56 - 23.83
Sub 0.1nA    : 4.26 - 12.46% sag
--------------------------------------------

- tune25 - somaNa=4.5, dendNa=0.3, gpas=0.5, ihlkc=0.6, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune25
fI 0.3-0.4-0.6nA : 9.00 - 21.00 - 39.00
stim ih-zd   : 21.00 - 57.00 (36.00)
RMP ih-zd    : -72.38 - -85.32
Peak ih-zd   : 23.62 - 23.83
Sub 0.1nA    : 4.20 - 12.33% sag
--------------------------------------------

- tune26 - somaNa=4.5, dendNa=0.3, gpas=0.6, ihlkc=0.6, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune26
fI 0.3-0.4-0.6nA : 4.00 - 20.00 - 39.00
stim ih-zd   : 21.00 - 56.00 (35.00)
RMP ih-zd    : -72.54 - -84.90
Peak ih-zd   : 23.47 - 23.82
Sub 0.1nA    : 4.11 - 12.60% sag
--------------------------------------------

- tune27 - somaNa=4.5, dendNa=0.3, gpas=0.6, ihlkc=0.6, ihlke=-74
--------------------------------------------
cfg.simLabel : v48_tune27
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 37.00
stim ih-zd   : 18.00 - 56.00 (38.00)
RMP ih-zd    : -73.25 - -84.90
Peak ih-zd   : 23.48 - 23.82
Sub 0.1nA    : 4.04 - 14.54% sag
--------------------------------------------

- tune28 - somaNa=4.5, dendNa=0.3, gpas=0.5, ihlkc=0.6, ihlke=-74
--------------------------------------------
cfg.simLabel : v48_tune28
fI 0.3-0.4-0.6nA : 0.00 - 19.00 - 38.00
stim ih-zd   : 19.00 - 57.00 (38.00)
RMP ih-zd    : -73.10 - -85.32
Peak ih-zd   : 23.54 - 23.83
Sub 0.1nA    : 4.12 - 14.31% sag
--------------------------------------------

- tune29 - somaNa=4.5, dendNa=0.3, gpas=0.5, ihlkc=0.65, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune29
fI 0.3-0.4-0.6nA : 6.00 - 21.00 - 39.00
stim ih-zd   : 21.00 - 57.00 (36.00)
RMP ih-zd    : -72.42 - -85.32
Peak ih-zd   : 23.49 - 23.83
Sub 0.1nA    : 4.15 - 12.21% sag
--------------------------------------------


- tune30 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.65, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune30
fI 0.3-0.4-0.6nA : 8.00 - 21.00 - 39.00
stim ih-zd   : 20.00 - 56.00 (36.00)
RMP ih-zd    : -72.42 - -85.32
Peak ih-zd   : 24.59 - 24.81
Sub 0.1nA    : 4.15 - 12.21% sag
--------------------------------------------

- tune31 - somaNa=5, dendNa=0.25, gpas=0.5, ihlkc=0.65, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune31
fI 0.3-0.4-0.6nA : 7.00 - 21.00 - 39.00
stim ih-zd   : 21.00 - 56.00 (35.00)
RMP ih-zd    : -72.42 - -85.32
Peak ih-zd   : 24.32 - 24.56
Sub 0.1nA    : 4.15 - 12.21% sag
--------------------------------------------

- tune32 - somaNa=5, dendNa=0.4, gpas=0.5, ihlkc=0.65, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune32
fI 0.3-0.4-0.6nA : 9.00 - 21.00 - 38.00
stim ih-zd   : 20.00 - 55.00 (35.00)
RMP ih-zd    : -72.42 - -85.32
Peak ih-zd   : 24.97 - 25.37
Sub 0.1nA    : 4.15 - 12.22% sag
--------------------------------------------

- tune33 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.7, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune33
fI 0.3-0.4-0.6nA : 5.00 - 20.00 - 38.00
stim ih-zd   : 20.00 - 56.00 (36.00)
RMP ih-zd    : -72.45 - -85.32
Peak ih-zd   : 24.56 - 24.81
Sub 0.1nA    : 4.10 - 12.09% sag
--------------------------------------------

- tune34 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.5, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune34
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 34.00
stim ih-zd   : 16.00 - 56.00 (40.00)
RMP ih-zd    : -74.74 - -85.32
Peak ih-zd   : 24.43 - 24.81
Sub 0.1nA    : 4.01 - 20.22% sag
--------------------------------------------

- tune35 - somaNa=5, dendNa=0.4, gpas=0.5, ihlkc=0.7, ihlke=-72
--------------------------------------------
cfg.simLabel : v48_tune35
fI 0.3-0.4-0.6nA : 7.00 - 20.00 - 37.00
stim ih-zd   : 20.00 - 55.00 (35.00)
RMP ih-zd    : -72.45 - -85.32
Peak ih-zd   : 24.96 - 25.37
Sub 0.1nA    : 4.10 - 12.10% sag
--------------------------------------------

- tune36 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.4, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune36
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 36.00
stim ih-zd   : 19.00 - 56.00 (37.00)
RMP ih-zd    : -74.38 - -85.32
Peak ih-zd   : 24.53 - 24.81
Sub 0.1nA    : 4.16 - 19.99% sag
--------------------------------------------

- tune37 - somaNa=5, dendNa=0.*25*, gpas=0.5, ihlkc=0.5, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune37
fI 0.3-0.4-0.6nA : 0.00 - 15.00 - 34.00
stim ih-zd   : 16.00 - 56.00 (40.00)
RMP ih-zd    : -74.74 - -85.32
Peak ih-zd   : 24.23 - 24.56
Sub 0.1nA    : 4.01 - 20.21% sag
--------------------------------------------

- tune38 - somaNa=5, dendNa=0.4, gpas=0.5, ihlkc=0.7, ihlke=-72, epas=1.0 ?!
--------------------------------------------
cfg.simLabel : v48_tune38
fI 0.3-0.4-0.6nA : 0.00 - 18.00 - 36.00
stim ih-zd   : 17.00 - 51.00 (34.00)
RMP ih-zd    : -73.28 - -91.56
Peak ih-zd   : 24.95 - 25.26
Sub 0.1nA    : 4.03 - 14.06% sag
--------------------------------------------


- tune39 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.3, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune39
fI 0.3-0.4-0.6nA : 4.00 - 20.00 - 38.00
stim ih-zd   : 23.00 - 56.00 (33.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 24.59 - 24.81
Sub 0.1nA    : 4.35 - 19.63% sag
--------------------------------------------

- tune40 - somaNa=5, dendNa=0.25, gpas=0.5, ihlkc=0.3, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune40
fI 0.3-0.4-0.6nA : 4.00 - 20.00 - 38.00
stim ih-zd   : 23.00 - 56.00 (33.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 24.40 - 24.56
Sub 0.1nA    : 4.35 - 19.63% sag
--------------------------------------------


- tune41 - somaNa=5, dendNa=0.4, gpas=0.5, ihlkc=0.3, ihlke=-80 *
--------------------------------------------
cfg.simLabel : v48_tune41
fI 0.3-0.4-0.6nA : 6.00 - 20.00 - 37.00
stim ih-zd   : 22.00 - 55.00 (33.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 25.13 - 25.37
Sub 0.1nA    : 4.35 - 19.65% sag
--------------------------------------------


- tune42 - somaNa=5, dendNa=0.5, gpas=0.5, ihlkc=0.3, ihlke=-80 *
--------------------------------------------
cfg.simLabel : v48_tune42
fI 0.3-0.4-0.6nA : 8.00 - 20.00 - 36.00
stim ih-zd   : 22.00 - 56.00 (34.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 25.61 - 25.84
Sub 0.1nA    : 4.35 - 19.66% sag
--------------------------------------------

- tune43 - somaNa=6, dendNa=0.3, gpas=0.5, ihlkc=0.3, ihlke=-80 *
--------------------------------------------
cfg.simLabel : v48_tune43
fI 0.3-0.4-0.6nA : 7.00 - 20.00 - 37.00
stim ih-zd   : 22.00 - 54.00 (32.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 26.36 - 26.53
Sub 0.1nA    : 4.35 - 19.65% sag
--------------------------------------------

- tune44 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-82 *
--------------------------------------------
cfg.simLabel : v48_tune44
fI 0.3-0.4-0.6nA : 11.00 - 22.00 - 39.00
stim ih-zd   : 27.00 - 56.00 (29.00)
RMP ih-zd    : -73.64 - -85.32
Peak ih-zd   : 24.82 - 24.81
Sub 0.1nA    : 4.54 - 20.33% sag
--------------------------------------------

- tune45 - somaNa=6, dendNa=0.4, gpas=0.5, ihlkc=0.3, ihlke=-80
--------------------------------------------
cfg.simLabel : v48_tune45
fI 0.3-0.4-0.6nA : 9.00 - 20.00 - 36.00
stim ih-zd   : 22.00 - 54.00 (32.00)
RMP ih-zd    : -73.92 - -85.32
Peak ih-zd   : 26.75 - 26.96
Sub 0.1nA    : 4.35 - 19.66% sag
--------------------------------------------


- tune46 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-84
--------------------------------------------
cfg.simLabel : v48_tune46
fI 0.3-0.4-0.6nA : 9.00 - 21.00 - 38.00
stim ih-zd   : 26.00 - 56.00 (30.00)
RMP ih-zd    : -73.97 - -85.32
Peak ih-zd   : 24.80 - 24.81
Sub 0.1nA    : 4.48 - 21.57% sag
--------------------------------------------


- * tune47 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-86 *
--------------------------------------------
cfg.simLabel : v48_tune47
fI 0.3-0.4-0.6nA : 5.00 - 20.00 - 38.00
stim ih-zd   : 24.00 - 56.00 (32.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 24.80 - 24.81
Sub 0.1nA    : 4.42 - 22.77% sag
--------------------------------------------


- tune48 - somaNa=6, dendNa=0.4, gpas=0.5, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune48
fI 0.3-0.4-0.6nA : 9.00 - 20.00 - 36.00
stim ih-zd   : 24.00 - 54.00 (30.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 26.86 - 26.96
Sub 0.1nA    : 4.42 - 22.81% sag
--------------------------------------------


- tune49 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-87
--------------------------------------------
cfg.simLabel : v48_tune49
fI 0.3-0.4-0.6nA : 3.00 - 20.00 - 37.00
stim ih-zd   : 23.00 - 56.00 (33.00)
RMP ih-zd    : -74.44 - -85.32
Peak ih-zd   : 24.75 - 24.81
Sub 0.1nA    : 4.39 - 23.36% sag
--------------------------------------------


- tune50 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-85
--------------------------------------------
cfg.simLabel : v48_tune50
fI 0.3-0.4-0.6nA : 8.00 - 20.00 - 38.00
stim ih-zd   : 25.00 - 56.00 (31.00)
RMP ih-zd    : -74.13 - -85.32
Peak ih-zd   : 24.77 - 24.81
Sub 0.1nA    : 4.45 - 22.18% sag
--------------------------------------------


- tune51 - somaNa=5.5, dendNa=0.4, gpas=0.5, ihlkc=0.2, ihlke=-86 *
--------------------------------------------
cfg.simLabel : v48_tune51
fI 0.3-0.4-0.6nA : 8.00 - 20.00 - 36.00
stim ih-zd   : 24.00 - 55.00 (31.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 26.07 - 26.22
Sub 0.1nA    : 4.42 - 22.80% sag
--------------------------------------------


- tune52 - somaNa=5.5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune52
fI 0.3-0.4-0.6nA : 6.00 - 20.00 - 37.00
stim ih-zd   : 24.00 - 55.00 (31.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 25.64 - 25.73
Sub 0.1nA    : 4.42 - 22.78% sag
--------------------------------------------


- tune53 - somaNa=4.5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune53
fI 0.3-0.4-0.6nA : 4.00 - 20.00 - 38.00
stim ih-zd   : 25.00 - 57.00 (32.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 23.76 - 23.83
Sub 0.1nA    : 4.42 - 22.76% sag
--------------------------------------------

- tune54 - somaNa=5, dendNa=0.4, gpas=0.5, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune54
fI 0.3-0.4-0.6nA : 6.00 - 20.00 - 37.00
stim ih-zd   : 24.00 - 55.00 (31.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 25.10 - 25.37
Sub 0.1nA    : 4.42 - 22.79% sag
--------------------------------------------

- tune55 - somaNa=5, dendNa=0.25, gpas=0.5, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune55
fI 0.3-0.4-0.6nA : 4.00 - 20.00 - 38.00
stim ih-zd   : 25.00 - 56.00 (31.00)
RMP ih-zd    : -74.29 - -85.32
Peak ih-zd   : 24.51 - 24.56
Sub 0.1nA    : 4.42 - 22.77% sag
--------------------------------------------

- tune56 - somaNa=5, dendNa=0.3, gpas=0.55, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune56
fI 0.3-0.4-0.6nA : 3.00 - 20.00 - 37.00
stim ih-zd   : 24.00 - 55.00 (31.00)
RMP ih-zd    : -74.36 - -85.10
Peak ih-zd   : 24.76 - 24.83
Sub 0.1nA    : 4.37 - 22.85% sag
--------------------------------------------

- tune57 - somaNa=5, dendNa=0.3, gpas=0.45, ihlkc=0.2, ihlke=-86
--------------------------------------------
cfg.simLabel : v48_tune57
fI 0.3-0.4-0.6nA : 9.00 - 20.00 - 38.00
stim ih-zd   : 25.00 - 56.00 (31.00)
RMP ih-zd    : -74.22 - -85.58
Peak ih-zd   : 24.81 - 24.83
Sub 0.1nA    : 4.47 - 22.69% sag
--------------------------------------------

- tune58 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-90
 --------------------------------------------
cfg.simLabel : v48_tune58
fI 0.3-0.4-0.6nA : 14.00 - 23.00 - 41.00
stim ih-zd   : 36.00 - 56.00 (20.00)
RMP ih-zd    : -73.44 - -85.32
Peak ih-zd   : 25.10 - 24.81
Sub 0.1nA    : 4.76 - 22.29% sag
--------------------------------------------

- tune59 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-92
--------------------------------------------
cfg.simLabel : v48_tune59
fI 0.3-0.4-0.6nA : 13.00 - 23.00 - 40.00
stim ih-zd   : 34.00 - 56.00 (22.00)
RMP ih-zd    : -73.64 - -85.32
Peak ih-zd   : 25.18 - 24.81
Sub 0.1nA    : 4.71 - 23.07% sag
--------------------------------------------

- tune60 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-96
--------------------------------------------
cfg.simLabel : v48_tune60
fI 0.3-0.4-0.6nA : 12.00 - 22.00 - 39.00
stim ih-zd   : 31.00 - 56.00 (25.00)
RMP ih-zd    : -74.03 - -85.32
Peak ih-zd   : 24.94 - 24.81
Sub 0.1nA    : 4.63 - 24.56% sag
--------------------------------------------


- tune61 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-98
--------------------------------------------
cfg.simLabel : v48_tune61
fI 0.3-0.4-0.6nA : 11.00 - 21.00 - 39.00
stim ih-zd   : 30.00 - 56.00 (26.00)
RMP ih-zd    : -74.21 - -85.32
Peak ih-zd   : 25.01 - 24.81
Sub 0.1nA    : 4.59 - 25.28% sag
--------------------------------------------

- tune62 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-100
--------------------------------------------
cfg.simLabel : v48_tune62
fI 0.3-0.4-0.6nA : 10.00 - 21.00 - 38.00
stim ih-zd   : 29.00 - 56.00 (27.00)
RMP ih-zd    : -74.39 - -85.32
Peak ih-zd   : 24.93 - 24.81
Sub 0.1nA    : 4.55 - 25.98% sag
--------------------------------------------


- tune63 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-102
--------------------------------------------
cfg.simLabel : v48_tune63
fI 0.3-0.4-0.6nA : 9.00 - 20.00 - 38.00
stim ih-zd   : 28.00 - 56.00 (28.00)
RMP ih-zd    : -74.56 - -85.32
Peak ih-zd   : 24.95 - 24.81
Sub 0.1nA    : 4.51 - 26.66% sag
--------------------------------------------

- tune64 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-104
--------------------------------------------
cfg.simLabel : v48_tune64
fI 0.3-0.4-0.6nA : 5.00 - 20.00 - 37.00
stim ih-zd   : 27.00 - 56.00 (29.00)
RMP ih-zd    : -74.72 - -85.32
Peak ih-zd   : 24.89 - 24.81
Sub 0.1nA    : 4.48 - 27.32% sag
--------------------------------------------

- tune65 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-106
--------------------------------------------
cfg.simLabel : v48_tune65
fI 0.3-0.4-0.6nA : 3.00 - 20.00 - 37.00
stim ih-zd   : 26.00 - 56.00 (30.00)
RMP ih-zd    : -74.89 - -85.32
Peak ih-zd   : 24.80 - 24.81
Sub 0.1nA    : 4.44 - 27.97% sag
--------------------------------------------

- tune66 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-108
--------------------------------------------
cfg.simLabel : v48_tune66
fI 0.3-0.4-0.6nA : 1.00 - 19.00 - 37.00
stim ih-zd   : 25.00 - 56.00 (31.00)
RMP ih-zd    : -75.04 - -85.32
Peak ih-zd   : 24.89 - 24.81
Sub 0.1nA    : 4.41 - 28.60% sag
--------------------------------------------


- tune67 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.1, ihlke=-110
--------------------------------------------
cfg.simLabel : v48_tune67
fI 0.3-0.4-0.6nA : 1.00 - 19.00 - 36.00
stim ih-zd   : 24.00 - 56.00 (32.00)
RMP ih-zd    : -75.19 - -85.32
Peak ih-zd   : 24.78 - 24.81
Sub 0.1nA    : 4.38 - 29.22% sag
--------------------------------------------

- tune68 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-86, epas=0.85
--------------------------------------------
cfg.simLabel : v48_tune68
fI 0.3-0.4-0.6nA : 10.00 - 21.00 - 39.00
stim ih-zd   : 26.00 - 57.00 (31.00)
RMP ih-zd    : -73.83 - -82.42
Peak ih-zd   : 24.75 - 24.84
Sub 0.1nA    : 4.48 - 21.28% sag
--------------------------------------------

- tune69 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-90, epas=0.85
--------------------------------------------
cfg.simLabel : v48_tune69
fI 0.3-0.4-0.6nA : 2.00 - 19.00 - 37.00
stim ih-zd   : 23.00 - 57.00 (34.00)
RMP ih-zd    : -74.44 - -82.42
Peak ih-zd   : 24.74 - 24.84
Sub 0.1nA    : 4.37 - 23.55% sag
--------------------------------------------

- tune70 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-92, epas=0.85
--------------------------------------------
cfg.simLabel : v48_tune70
fI 0.3-0.4-0.6nA : 1.00 - 19.00 - 36.00
stim ih-zd   : 21.00 - 57.00 (36.00)
RMP ih-zd    : -74.72 - -82.42
Peak ih-zd   : 24.69 - 24.84
Sub 0.1nA    : 4.32 - 24.64% sag
--------------------------------------------

- tune71 - somaNa=5, dendNa=0.3, gpas=0.5, ihlkc=0.2, ihlke=-90, epas=0.87
--------------------------------------------
cfg.simLabel : v48_tune71
fI 0.3-0.4-0.6nA : 1.00 - 19.00 - 37.00
stim ih-zd   : 22.00 - 57.00 (35.00)
RMP ih-zd    : -74.61 - -83.56
Peak ih-zd   : 24.72 - 24.86
Sub 0.1nA    : 4.34 - 24.15% sag
--------------------------------------------

*** tune72 - 84 - Weight reversal
cfg.GroupNetStimEPT = {'nstype': 'pop', 'numStims': 100, 'pop': ['PT5B','PT5B_ZD'], 'cellRule': 'PT5B_full', 'secList': 'alldend', 'allSegs': True, \
 						'synMech': 'AMPA', 'start': 300, 'interval': 1000/cfg.groupRate, 'noise': 0.25, 'number': 1, 'weight': 0.05, 'delay': 0}


- tune83: w=0.25
-61.2682805978
-58.2914097617

- tune84: w=0.05
ih: -70.9047122236
zd: -71.8825221656
*** tune85-90 - comparing epsp with and w/o removeNa

difference of < 0.002 mV  -- not significant

*** tune91-136 - check BAP + BAC (HayS11)
v47_tune135
- can get BAP easily
- to get BAC need to:
-- increase hotspot ca gbar_cal*1e5 and gbar_can*1e6
-- move hotspot to main trunk (100-300)
-- set proximal=~150 and distal~=300um

*** tune137-175 - Sheets fig 11 (sfn17 poster)
*** tune176- - George fig 2 (sfn17 poster)

** v48_batch1 - weightNorm PT after retuning PT (v48_tune47)
NOTE: removeNa = True (not sig diff: ~0.002 mV)

- bug - missing cfg.addNetStim=1 -- rerun on zn

cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0 # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 0.2 # ih leak param (used in Migliore)
cfg.ihlkcBasal = 1.0
cfg.ihlkcBelowSoma = 0.01
cfg.ihlke = -86  # ih leak param (used in Migliore)
cfg.ihSlope = 14*2

cfg.removeNa = 1# False  # simulate TTX; set gnabar=0s
cfg.somaNa = 5
cfg.dendNa = 0.3
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.5  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

	params = specs.ODict()
	params[('NetStim1', 'pop')] = pops
	params[('NetStim1', 'sec')] = secs
	params[('NetStim1', 'loc')] = locs
	params[('NetStim1', 'weight')] = weights

	groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')]

	initCfg = {}
	initCfg['duration'] = 1.0*1e3
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
	initCfg['weightNorm'] = False
	initCfg['stimSubConn'] = False
	initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
	initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
	initCfg[('NetStim1', 'start')] = 700
	initCfg[('NetStim1', 'interval')] = 1000
	initCfg[('NetStim1', 'noise')] = 0
	initCfg[('NetStim1', 'number')] = 1
	initCfg[('NetStim1', 'delay')] = 1
	#initCfg[('GroupNetStimW1', 'pop')] = 'None'
	initCfg[('NetStim1', 'delay')] = 1
	initCfg['addIClamp'] = 0

*** results
- should have used higher weight values -- to low so had to interpolate most and low precision
- wnorm in tufts goes to > 1e6

** v48_batch2 - fI curve for all pops after retuning PT

	params[('IClamp1', 'pop')] = ['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6', 'PV2', 'SOM2', 'PV5A', 'SOM5A', 'PV5B', 'SOM5B', 'PV6', 'SOM6']
	params[('IClamp1', 'amp')] = list(np.arange(0.0, 6.5, 0.5)/10.0)
	#params['ihGbar'] = [0.0, 1.0, 2.0]
	# params['axonNa'] = [5, 6, 7, 8]
	# params['gpas'] = [0.6, 0.65, 0.70, 0.75]
	# params['epas'] = [1.0, 1.05]
	# params['ihLkcBasal'] = [0.0, 0.01, 0.1, 0.5, 1.0]

	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['addIClamp'] = True
	initCfg['addNetStim'] = False
	initCfg[('IClamp1','sec')] = 'soma'
	initCfg[('IClamp1','loc')] = 0.5
	initCfg[('IClamp1','start')] = 500
	initCfg[('IClamp1','dur')] = 1000
	initCfg[('analysis','plotTraces','timeRange')] = [0, 1500]

	groupedParams = []

	b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)

** v48_batch4 - EIbalance after retuning PT, with disyn=[None, 0.99] - bug somaNa
- rerunning 272 missing ones
- still more missing but not enough SUs on m1 alloc -- rerun after complete
- rerunning 400+ missing ones
- BUG somaNA not implemented in netParams.py

	initCfg['IEdisynapticBias'] = [None, 0.99]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	groupedParams = []# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
filtered:
- no depol block
- E rates [0.2/1.5, 40/1.5], I rates [0.05/1.5, 130/1.5]  % 1.5 leftover from fI curve sims = 1.5sec
- E5>E6>E2

look manually for high IT2, low PT5B

Good candidates:
- 0 20 02 12 - IT5A too high
- 0 20 02 22
*- 0 22 01 01 - good IT2, PT
*- 1 10 01 01 - good
- 1 10 02 01
- 1 10 02 12 - good

** v48_batch5 - long stim, v47_batch5 11 20 11 10, short dur
NOTE: ran batch as v48_batch5 and renamed manually
- BUG somaNA not implemented in netParams.py

	params['IEdisynapticBias'] = [None, 0.99]
	params['ihGbar'] = [0.0, 0.25, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	#initCfg['IEdisynapticBias'] = None

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

*** results
- ih=1.0 - good, low PT, high others
- ih=0.0 and 0.25 - PT too high, silences all other layers

- interesting that stim to upper triggers osc - so maybe can get going by providing init stim

- ih=1.0 ok with pop stims,  rest not

** v48_batch6 - EPSP weight reversal (George 09 fig2)

	params['groupWeight'] = [x*0.1 for x in np.arange(1, 11, 1)]
	params['ihGbar'] = [0.0, 1.0]


	# initial config
	initCfg = {}
	initCfg['duration'] = 0.5*1e3
	initCfg['addIClamp'] = False
	initCfg['addNetStim'] = True
	initCfg[('GroupNetStimW1', 'pop')] = 'PT5B'
	initCfg[('analysis','plotTraces','timeRange')] = [0, 500]
	initCfg['excTau2Factor'] = 1.0
	initCfg['weightNorm'] = True
	initCfg['stimSubConn'] = False
	initCfg['ihGbarZD'] = None

** v48_batch7 - long stim with v48_batch4 0 22 01 01 - bug somaNa
- BUG somaNA not implemented in netParams.py

	params['ihGbar'] = [0.25, 0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 0 22 01 01
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

** v48_batch8 - long stim with v48_batch4 1 10 01 01 - bug somaNa
- BUG somaNA not implemented in netParams.py

	params['ihGbar'] = [0.25, 0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 10 01 01
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

** v49_batch1 - stim with v48_batch4 0 22 01 01 - bug dendNa
- after fixing somaNA bug
- assumed EIbalance ok

	params['ihGbar'] = [0.25, 0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 0 22 01 01
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

*** results - bad
no IT2 spks when ih low

** v49_batch2 - stim with v48_batch4 1 10 01 01 - bug dendNa
- after fixing somaNA bug

	params['ihGbar'] = [0.25, 0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 10 01 01
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

*** results - bad
no IT2 spks when ih low

** v49_batch3 - IT2 freq stim with v48_batch4 1 10 01 01 - bug dendNa
	params[('NetStim1', 'interval')] = [1000.0/f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'number')] = [f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'start')] = [500, 550]
	params['ihGbar'] = [0.25, 0.5, 1.0]

	# initial config
	initCfg = {}
	initCfg['addNetStim'] = True
	initCfg[('NetStim1', 'pop')] = 'IT2'
	initCfg[('NetStim1', 'ynorm')] = [0.12, 0.12+(0.31-0.12)/2] # ~50% of cells
	initCfg[('NetStim1', 'weight')] = 30.0
	initCfg[('NetStim1', 'noise')] = 0.2

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['dendNa'] = 0.4  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 10 01 01
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] =  1.0
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

*** results
IT2 activity very difuse - reduce noise to 0.0?
IT5A and PT5B very high -> IT4 and IT5B = 0 Hz

** v49_batch4 - EIbalance after retuning and fix somaNa bug
- run 'v49_batch4_1' with params[('IEweights',0)] =  [1.0]
	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	groupedParams = []# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0

	initCfg['IEdisynapticBias'] = 0.99

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False
*** results
- 00 01 02 - IT2 a bit low
- 20 01 01 - modified from v48_batch4
- 20 02 01 - modified from v48_batch4
- 20 12 01 - modified from v48_batch4

bad:
10 01 01
00 01 02
all starting with 0
20 02 01
22

- try 4hz, 250ms, with one with high IT2, and ~high PT:
00 00 00 - 80hz
00 00 11 - 80hz
00 00 22 - 80hz
00 10 20 - 75hz
00 11 00 - 80hz
00 11 10 - 75hz
00 11 11 - 75hz *
00 11 22 - 80hz
00 22 10 - 75hz *
00 22 21 - 75hz

- starting with 2:
20 00 10
20 00 20
20 00 21
20 00 22
20 01 00
20 01 11
20 01 11
20 02 00
20 02 11
20 12 21
21 00 00
21 01 01

** v49_batch5 - long v49_batch4 - 00 01 02 - 4 nodes - BUG
dendNa=0.4

** v49_batch6 - long v49_batch4 - 20 02 01 - 4 nodes - BUG
dendNa=0.4

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']

** v49_batch7 - long v49_batch4 - 00 11 11 - 4 nodes, 4hz 250ms - BUG
dendNa=0.4

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']
** v49_batch8 - long v49_batch4 - 00 22 21 - 4 nodes, 4hz 250ms - BUG
dendNa=0.4

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']

** v49_batch9 - long - several from v49_batch4, 2 nodes, 4hz, 250ms

	# 22 01 01
	# 10 01 01
	# 00 01 02
	# 20 02 01
	# 00 11 11
	# 00 22 21
	# 10 02 12
	# 12 20 12

	# # L2/3+4
	params[('IEweights',0)] =  [1.2, 1.0, 0.8, 1.2, 0.8, 0.8, 1.0, 1.0]
	params[('IIweights',0)] =  [1.2, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 1.2]
	# L5
	params[('IEweights',1)] =  [0.8, 0.8, 0.8, 0.8, 1.0, 1.2, 0.8, 1.2]
	params[('IIweights',1)] =  [1.0, 1.0, 1.0, 1.2, 1.0, 1.2, 1.2, 0.8]
	# L6
	params[('IEweights',2)] =  [0.8, 0.8, 0.8, 0.8, 1.0, 1.2, 1.0, 1.0]
	params[('IIweights',2)] =  [1.0, 1.0, 1.2, 1.0, 1.0, 1.0, 1.2, 1.2]


	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']

	#params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 4
	initCfg[('pulse', 'end')] = 1250
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 00 22 21
	initCfg['IEdisynapticBias'] = 0.99

	groupedParams = [('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

** v49_batch10 - longsq - several from v49_batch4_2, 2 nodes, 10 hz, 100ms
0- 20 00 10
1- 20 00 20
2- 20 00 21
3- 20 00 22
4- 20 01 00
5- 20 01 11
6- 20 01 11
7- 20 02 00
8- 20 02 11
9- 20 12 21
10- 21 00 00
11- 21 01 01

	# # L2/3+4
	params[('IEweights',0)] =  [1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]
	params[('IIweights',0)] =  [0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 1.0, 1.0]
	# L5
	params[('IEweights',1)] =  [0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 1.0, 0.8, 0.8]
	params[('IIweights',1)] =  [0.8, 0.8, 0.8, 0.8, 1.0, 1.0, 1.0, 1.2, 1.2, 1.2, 0.8, 1.0]
	# L6
	params[('IEweights',2)] =  [1.0, 1.2, 1.2, 1.2, 0.8, 1.0, 1.0, 0.8, 1.0, 1.2, 0.8, 0.8]
	params[('IIweights',2)] =  [0.8, 0.8, 1.0, 1.2, 0.8, 1.0, 1.0, 0.8, 1.0, 1.0, 0.8, 1.0]


	params['ihGbar'] = [0.25, 0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']

	#params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 00 22 21
	initCfg['IEdisynapticBias'] = 0.99

	groupedParams = [('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2),
	('IIweights',2)]

*** results
- 0 - ih 0.5 - good but low PT
- 1 - S2 ih 1 higher - bad
- 2 - bad
- 3 - ok but low PT effect
- 4 - bad
- 5 - good strong PT clear ih diff; only thing is IT2 too low
- 6 - similar to 5
- 7 - bad
- 8 - bad
- 9 - bad

** v49_batch11 - freq stim with v49_batch10 20 00 10, noise 0.05, 33% IT2, reserv
params = specs.ODict()

	params[('NetStim1', 'interval')] = [1000.0/f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'number')] = [f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'start')] = [500, 550]
	params['ihGbar'] = [0.5, 1.0]

	# initial config
	initCfg = {}
	initCfg['addNetStim'] = True
	initCfg[('NetStim1', 'pop')] = 'IT2'
	initCfg[('NetStim1', 'ynorm')] = [0.12, 0.12+(0.31-0.12)/3] # ~50% of cells
	initCfg[('NetStim1', 'weight')] = 30.0
	initCfg[('NetStim1', 'noise')] = 0.05

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 20 00 10
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 0.8
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	groupedParams = [('NetStim1', 'interval'), ('NetStim1', 'number')]

*** notes
- S2 or directly to L23 (avoid inh)
- fraction of cells or smaller weight
- 1 sec duration
- inc rate 2:2:60
- dec fraction 1/f ?
- measure amp of osc
-- input arg = approx freq
-- find 1st peak, measur amp
-- from 1st peak use est amp ton find 2nd
-- calculate avg peak amp
-- overall rate can be misleading -- unless use 1/f ?
- psd before and after --> overlap, dotted vs solid lines
- measure spec granger

- batch:
-- ih
-- interval / number grouped
-- background - on/off (addLongConn)
-- weight? fixed - to 30

** v49_batch12 - long v49_batch10 20 00 10 (0), ih=0.4,0.5,1.0, 25 seeds (no reserv)

	params['ihGbar'] = [0.4, 1.0, 0.5]
	params[('pulse', 'pop')] = ['S2', 'M2']
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	#params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 20 00 10
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 0.8
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	groupedParams = [('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]
*** results
0.4 - not good in some

good seeds:
- 0 2 - ok'ish, PT not so clear
- 1 2 - 90/25, 20/8
- 2 0 - 90/25, 12/12
- 2 4 - 65/20, 10/17 - BAD 1_0
-- stat_rate - pre- good except CT
-- stat_isi - "
-- sync - PT dec
-- psd - pre - beta+gamma
-- granger - pre IT2->IT5A
- 3 0 - 50/14, 12/20  - BAD 1_0
-- stats - pre- all good
-- sync - PT ~dec, IT5A ~inc
-- psd - pre - beta+gamma
-- granger - pre - IT2->IT5A/PT5B
- 3 4 - 50/15, 15/30 *
-- stats - pre all good

** v49_batch13 - long - v49_batch10 20 00 10 (0), ih=0.4, reserv

	params['ihGbar'] = [0.4]
	params[('pulse', 'pop')] = ['S2', 'M2']
	# params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	# params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	#params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 20 00 10
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 0.8
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	groupedParams = [('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

** v49_batch14 - long v49_batch10 (6), ih=0.5, 1.0, 25 seeds (no reserv)
	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['S2', 'M2']
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	#params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 1 20 01 11
	initCfg['IEdisynapticBias'] = 0.99

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

** v49_batch15 - EIBalance with disyn=None
	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.5, 1.0]

	groupedParams = []# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbar'] = 1.0
	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results manual
both ih no depol:
both ih no depol+selected_0:
02 20 12 - no ih diff
10 01 22 - good ih diff, but strong osc after 1.2sec
21 12 11 - small ih diff

*** results automated
match these conds:
          if (avgsPT5Bzd[1] > 1.5*avgsPT5Bih[1] and
            avgsPT5BzdInc > 1.5*avgsPT5BihInc and
            avgsPT5BzdInc > 0 and
            abs(avgsPT5BihInc) < 0.30 and

            peaksPT5Bzd[1] > 1.75*peaksPT5Bih[1] and
            peaksPT5BzdInc > 1.75*peaksPT5BihInc and
            peaksPT5BzdInc > 0 and
            abs(peaksPT5BihInc) < 0.30):

- 00 11 12
- 12 11 02
- 12 12 01

** v49_batch16 - long - v49_batch15 00 01 12 (don't match v49_batch15)

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 00 01 12
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 0.8
	initCfg[('IIweights',0)] =  0.8
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.2

*** results
okish but don't match v49_batch15 -- probably because of netpyne version
note: initCfg[('pulse', 'noise')] = 0.8 in v49_batch15

** v49_batch17 - long - v49_batch15 12 12 01 (don't match v49_batch15)

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}
	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'end')] = 1100
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'start')] = 1000.0

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0

	# 12 12 01
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.2
	# L6
	initCfg[('IEweights',2)] =  0.8
	initCfg[('IIweights',2)] =  1.0

	groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

*** results
okish but don't match v49_batch15 -- probably because of netpyne version

** v49_batch18 - EI and long input balance
	params = specs.ODict()

	params[('ratesLong', 'TPO', 1)] = [2,4]
	params[('ratesLong', 'TVL', 1)] = [2,4]
	params[('ratesLong', 'S1', 1)] = [2,4]
	params[('ratesLong', 'cM1', 1)] = [2,4]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	#params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	#params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	#params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.5, 1.0]

	groupedParams = []# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

** v49_batch19 - EI and long input balance with IIweights=[1,1,1]
	params = specs.ODict()

	params[('ratesLong', 'TPO', 1)] = [2,4]
	params[('ratesLong', 'TVL', 1)] = [2,4]
	params[('ratesLong', 'S1', 1)] = [2,4]
	params[('ratesLong', 'cM1', 1)] = [2,4]

 	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	#params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	#params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	#params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.5, 1.0]

	groupedParams = []# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
1101 122 - good
1101 222 - ok, PT a bit too low
0011 121 - ok, IT2 and PT a bit low

** v49_batch20 - long - v49_batch19 1101 122
	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 122
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0
*** results
all good

** v49_batch21 - long - v49_batch19 1101 222

	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

*** results
all good

** v49_batch22 - long - v49_batch19 0011 121
	params['ihGbar'] = [0.5, 1.0]
	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 0011 121
	initCfg[('ratesLong', 'TPO', 1)] = 2
	initCfg[('ratesLong', 'TVL', 1)] = 2
	initCfg[('ratesLong', 'S1', 1)] = 4
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

** v49_batch23 - long - v49_batch19 1101 122 - 5*5 seeds
	params['ihGbar'] = [0.5, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 122
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0
*** results
all good

** v49_batch24 - long - v49_batch19 1101 222 - 5*5 seeds

	params['ihGbar'] = [0.5, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2', 'OC'] # 'S1','cM1',
	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

*** results
all good

** v49_batch25 - freq stims with noise=0.05 (1101 222)
def freqStims():
	params = specs.ODict()

	params[('NetStim1', 'interval')] = [1000.0/f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'number')] = [f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'start')] = [500, 550]
	params['ihGbar'] = [0.5, 1.0]
	params[('NetStim1', 'ynorm', 1)] = [0.15+x*(0.31-0.12) for x in [0.1, 0.2, 0.3]]  # 10, 20, 30% of cells, 0.12+]


	# initial config
	initCfg = {}
	initCfg['addNetStim'] = True
	initCfg[('NetStim1', 'pop')] = 'IT2'
	initCfg[('NetStim1', 'ynorm', 0)] = 0.15
	initCfg[('NetStim1', 'weight')] = 30.0
	initCfg[('NetStim1', 'noise')] = 0.05

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	groupedParams = [('NetStim1', 'interval'), ('NetStim1', 'number')]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

	return b

** v49_batch26 - freq stims with noise=0.01 (1101 222)
NOTE: didn't run last 3 due to not enough resources on comet (shs100):
v49_batch26_9_9_1_1_0
v49_batch26_9_9_1_1_1
v49_batch26_9_9_1_1_2
- can rerun manually via .sbatch file

def freqStims():
	params = specs.ODict()

	params[('NetStim1', 'interval')] = [1000.0/f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'number')] = [f for f in [4,8,12,16,20,24,28,32,36,40]]
	params[('NetStim1', 'start')] = [500, 550]
	params['ihGbar'] = [0.5, 1.0]
	params[('NetStim1', 'ynorm', 1)] = [0.15+x*(0.31-0.12) for x in [0.1, 0.2, 0.3]]  # 10, 20, 30% of cells, 0.12+]


	# initial config
	initCfg = {}
	initCfg['addNetStim'] = True
	initCfg[('NetStim1', 'pop')] = 'IT2'
	initCfg[('NetStim1', 'ynorm', 0)] = 0.15
	initCfg[('NetStim1', 'weight')] = 30.0
	initCfg[('NetStim1', 'noise')] = 0.05

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0
	initCfg[('IIweights',2)] =  0.8

	groupedParams = [('NetStim1', 'interval'), ('NetStim1', 'number')]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

	return b

** v49_batch27 - simult long inputs

-- record more PT cells and sections (to explore integration of inputs)

cfg.cellsrec = 4
if cfg.cellsrec == 0:  cfg.recordCells = ['all'] # record all cells
elif cfg.cellsrec == 1: cfg.recordCells = [(pop,50) for pop in allpops] # record one cell of each pop
elif cfg.cellsrec == 2: cfg.recordCells = [('IT2',10), ('IT5A',10), ('PT5B',10), ('PV5B',10), ('SOM5B',10)] # record selected cells
elif cfg.cellsrec == 3: cfg.recordCells = [('IT5A',100), ('PT5B',100)] # record selected cells
elif cfg.cellsrec == 4: cfg.recordCells = [(pop,50) for pop in ['IT2', 'IT4', 'IT5A', 'PT5B']]+[('PT5B',x) for x in [393,447,579,19,104,214,1138,979,799]] # record selected cells

cfg.recordTraces = {'V_soma': {'sec':'soma', 'loc':0.5, 'var':'v'},
					'V_apic_23': {'sec':'apic_23', 'loc':0.5, 'var':'v', 'conds':{'pop': 'PT5B'}},
					'V_apic_26': {'sec':'apic_26', 'loc':0.5, 'var':'v', 'conds':{'pop': 'PT5B'}},
					'V_dend_5': {'sec':'dend_5', 'loc':0.5, 'var':'v', 'conds':{'pop': 'PT5B'}}}



def simultLongPopStims():
	params = specs.ODict()

	params[('pulse', 'pop')] = ['TPO', 'TVL', 'TVL', 'S2', 'S2', 'M2']
	params[('pulse2', 'pop')] = ['TVL', 'TPO', 'S2', 'TVL', 'M2', 'S2']
	params[('pulse2', 'start')] = np.arange(1000, 1220, 20)
	params['ihGbar'] = [0.5, 1.0]

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg[('pulse2', 'rate')] = 10
	initCfg[('pulse2', 'duration')] = 100.0
	initCfg[('pulse2', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	groupedParams = [('pulse', 'pop'),('pulse2', 'pop'), ('pulse2', 'start'), ('pulse2', 'end')]
	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

	return b

*** results
- peak of S2+M2 constant because highest is right at the beginning due to S2
- M2 first prevents S2 activation due to higher PT rate -> interneuron

** v49_batch28 - long - v49_batch19 1101 222 - 5*5 seed; ih=[0.3, 0.4]


	params['ihGbar'] = [0.3, 0.4]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 10
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

** v49_batch29 - long - v49_batch19 1101 222 - 5*5 seeds; 15hz; ih=[0.3,0.4,0.5,1.0]

	params['ihGbar'] = [0.3, 0.4, 0.5, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'rate')] = 15
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None


	# 1101 222
	initCfg[('ratesLong', 'TPO', 1)] = 4
	initCfg[('ratesLong', 'TVL', 1)] = 4
	initCfg[('ratesLong', 'S1', 1)] = 2
	initCfg[('ratesLong', 'cM1', 1)] = 4

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

*** results
0.3 good!

** v49_manualTune -
tune4 - netClamp for plotShape
tune5 - shapePlot with num syns
**** tune21 - check IT5A wnorm with multiple inputs
- summation of up to 100 input along dends is slightly supralinear for AMPA: 100 * 0.1 -> 8.71 mV EPSP amp (~87%)
- for NMDA its strongly supralinear: 100 *  0.1 -> 1.33  (~13%)
- combined AMPA,NMDA at 0.5,0.5 is mid supralinear: 100*0.1 -> 4.71 mV  (~47%)
- with noise=0.5 -> AMPA+NMDA: 100*0.1 -> 3.21 mV
- noise=0.1 -> 4.33mV
- temp summation, 50ms interval: 4.71, 6.53, 7.48 mV
- 200 inputs, temp sum 50ms: [[9.058868676520262], [12.489676577804147], [14.47870500133152]]
- 300 inputs, temp sum 50ms: [[13.048148024152198], [97.04518337749879], [13.345757278645237]]
- 1000 -> 10 spks
**** tune31 - check IT2 with multiple inputs
- AMPA+NMDA, 0.5-0.5, noise=0
- 100 inputs * 0.1 weight, temp summation, 50ms interval: [4.752359279496815], [5.434314734786696], [5.749423016563867]
- 300 inputs: [[12.987203081315712], [15.407442718997842], [17.19875639535158]]
- 1000 -> 9 spks

** v50_batch1 - long - v49_batch19 1101 222 - 5 sec, patterned stim (crcns ssc-3)

NOTE: 8,9,10 parameter sets not ran due to not enough SUs - run manually on csd403 (by editing .sbatch files)

def recordedLongPopStims():
	params = specs.ODict()

	high = 'cells/ssc-3_spikes.json'
	low  = 'cells/ssc-3_lowrate_spikes.json'
	low2 = 'cells/ssc-3_lowrate2_spikes.json'

	# 1) normal, 2) S2high+lowbkg, 3) S2low+bkg0.1, 4) S2low2+bkg0.1, 5) S2low2+M2low+bkg0.1, 6) S2low,
	# 7) S2high, 8) S1high, 9) S1low, 10) M2low, 11) M2high
	params[('ratesLong','S2')] =  [[0,2], high,    low,     low2,	 low2,		high, 	low,   [0,2], [0,2], [0,2], [0,2]]
	params[('ratesLong','S1')] =  [[0,2], [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,2], 	[0,2], high,  low,   [0,2], [0,2]]
	params[('ratesLong','M2')] =  [[0,2], [0,0.1], [0,0.1], [0,0.1], low, 		[0,2], 	[0,2], [0,2], [0,2], high, 	low]
	params[('ratesLong','TPO')] = [[0,4], [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
	params[('ratesLong','TVL')] = [[0,4], [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
	params[('ratesLong','cM1')] = [[0,4], [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
	params[('ratesLong','OC')] =  [[0,2], [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,2], 	[0,2], [0,2], [0,2], [0,2], [0,2]]

	params['ihGbar'] = [0.3, 0.4, 0.5, 1.0]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('analysis','plotRaster','timeRange')] = [500, 5500]

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	groupedParams = [('ratesLong','S2'), ('ratesLong','S1'), ('ratesLong','M2'),
					('ratesLong','TPO'), ('ratesLong','TVL'), ('ratesLong','cM1'), ('ratesLong','OC')]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

	return b

*** results
- Best exc rate stats: 1, 2
- Best exc isi stats: all good
- Best inh rate stats: only 2 and 3 plotted -- error with 1 and 2?
- Best inh isi stats:
- Best spike PSD: all good (beta peak), but 3 weird
- Best rasters: 1,2,0,3
- Best granger: 1,0,2,3


** v50_batch2 - long - v49_batch19 1101 222 - 5 sec, bkg, with LFP
*** results not identical - why? rerun
- cfg and netParams identical
- different netpyne versions:
-- v0.7.7 - a1a8212
-- v0.7.5 - 9829860

- possible diffs:
-- cell.py line 1189: synMechSecs and synMechLocs random from list

*** v50_batch2b - rerun without recording LFP -- different than the other 2!!!
check if LFP is affecting output
- use same netpyne v: a1a8212

- different than the previous 2!!

*** v50_batch2c - rerun with recording LFP (same as v50_batch2) - ok
- use netpyne: a1a8212
- same as v50_batch2
- but if set LFP recording on, then different
- so LFP recording is affecting output!! like quantum measurements!
- tested locally lfp_cell, lfp_net, and m1 (30x30um) - all identical with and withou lfp recording

*** v50_batch2d - rerun without new synMechLocs and without LFP
- use netpyne: e0b75ae
- trying to reproduce v50_batch1 -- worked!!
- so issue was the new synMechLocs code (added in lascon to make dentate gyrus model work)

*** v50_batch2e - test with fix for synMechLocs without LFP (2 sec)
- netpyne e6efc9059
- different from all prev
- possibly due to:
-- duration? 2 to 6 sec (rerun as v50_batch2e2) - yes!!
-- synMechLocs = params['loc'] if isinstance(params['loc'], list) else [params['loc']]
- DURATION also affects! (shouldn't really, should check netpyne)

*** v50_batch2f - test with fix for synMechLocs with LFP (2 sec)
- netpyne e6efc9059
- different from all prev!

*** v50_batch2g - check if sim.net.defineCellShapes() is causing difference
- rerun after updating netpyne - f001858
- compare with v50_batch2e and v50_batch2d (ideally!)
- different ... not much but different
- also different than v50_batch2c
-- maybe lfp  differences due to >1 factor eg. cellshape + something else
-- could be latest netpyne version changes! argg

*** v50_batch2h - recheck that without cellShapes is same as 2d
- netpyne f001858
- if different, then netpyne version!
- SAME AS 2d !! great
- So cellShapes is affecting
- Maybe try with NEURON 7.5!

*** v50_batch2i - compare with recording LFP as well
- if same as 2g, then difference caused by cellShapes
- if differet than 2g, then something additional LFP-related is causing
- same as 2g! so cellShapes causing
- but why not same as 2c?? oh because of synMechLocs!

*** v50_batch2j - with LFP + NEURON 7.5
- netpyne 8718760 (shouldn't affect)
- maybe shape is affecting because old version does in different way (can't reproduce locally)
- or maybe because morphologies more complex? tried PT detail and simple
- SEG FAULT!

*** v50_batch2k - withOUT LFP + NEURON 7.5
- SEG FAULT!

- rerun without pythonpaths
- needed to compile /mod !
*** v50_bathchl - without LFP + NEURON 7.5 (after compiling)
- copied and manually changed from batch2k - retrying
- using ~/.bashrc_7.5

*** single cell with NEURON 7.5, pythonpath, pythonhome, scipy
    seg fault
**** bashrc_7.5
[salvadord@comet-ln3 sim]$ cat ~/.bashrc_7.5
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

# User specific aliases and functionsi
source /projects/ps-nsg/home/nsguser/.bashrc
module load gsl

module load python
module load scipy

#export MODULEPATH=/share/apps/compute/modulefiles/mpi:$MODULEPATH
#module unload mvapich2_ib
#module unload openmpi_ib/1.8.4
#module load openmpi_ib/1.8.4npmi

# update scipy
export MODULEPATH=/share/apps/compute/modulefiles/applications:$MODULEPATH
module load python/2.7.13
export PYTHONPATH=/share/apps/compute/python-2.7.13/lib/python/site-packages:$PYTHONPATH

export SITE=/home/lytton/site

# NEURON 7.5
export PATH=/home/salvadord/site/nrniv/local/bin:/projects/ps-nsg/home/nsguser/applications/neuron7.5/installdir/x86_64/bin:$PATH

# NEURON 7.4
#export PATH=/home/salvadord/site/nrniv/local/bin:/home/lytton/arch/nrn/x86_64/bin:$PATH

export NEURON_INIT_MPI=0
export LIBS=-ldl

#export N=$SITE/nrniv
export CPU=`uname -p`
#export NSRC=$N/nrn$NSUF # current source
#export IVB=$N/iv
#export NB=$N/nrn$NSUF$CPU

#export ND=/home/lytton/arch/nrn
#if (! $?LD_LIBRARY_PATH) setenv LD_LIBRARY_PATH ""

export MODL_INCLUDE=/home/salvadord/site/nrniv/local/mod
export HOC_LIBRARY_PATH=/home/salvadord/site/nrniv/local/hoc:/home/salvadord/site/nrniv/simctrl/hoc

# NEURON 7.5
export PYTHONPATH=/projects/ps-nsg/home/nsguser/applications/neuron7.5/installdir/lib/python:$PYTHONPATH
export NEURONHOME=/projects/ps-nsg/home/nsguser/applications/neuron7.5/installdir

export PYTHONPATH=/home/salvadord/site/nrniv/local/python:/home/salvadord/site/nrniv/local/python/netpyine:$PYTHONPATH

alias huc='hg pull; hg up -C'
alias lsl='ls -lrtah'
alias upnp='cd ~/site/nrniv/local/python/netpyne/; git pull; cd ~/m1/sim'
alias sq='squeue -u $USER; squeue -u $USER | wc -l'
alias sqr='squeue -u $USER -t RUNNING; squeue -u $USER -t RUNNING | wc -l'
alias sqrr='squeue -u $USER -t RUNNING --reservation=salva1; squeue -u $USER -t RUNNING --reservation=salva1 | wc -l'
alias sqra='squeue -t RUNNING; squeue -t RUNNING | wc -l'
alias sqp='squeue -u $USER -t PENDING; squeue -u $USER -t PENDING | wc -l'
alias sqpa='squeue -t PENDING --partition=compute -o "%.18i %.9P %.8j %.8u %.2t %.10M %.6D %R %p"; squeue -t PENDING --partition=compute | wc -l'
alias sdetail='scontrol show job'
alias tarc='tar -zcvf'

*** NEURON7.5 SEG FAUL WAS DUE TO NOT RECOMPILING /mod !!! d'oh!
*** tested locally with interneurons if difference with and w/o LFP
- tested net with 1500 PV and SOM 2-comp
- IDENTICAL

*** INTERACTIVELY checking on comet
- srun --partition=compute --pty --nodes=1 --ntasks-per-node=24 -t 04:00:00 --wait=0 -A CSD403 -X --export=ALL /bin/bash

- Test m1 with 50x50, 0.5sec on 24 cores:
-- NEURON 7.4 with and w/o defineCellShapes (later h.defineShape())
-- NEURON 7.5 with w/o defineCellShapes (later h.defineShape())



*** FIGURE IT OUT!! DUE TO SHAPE CHANGE + SUBCONN!!
- v50_version_shape_subconn
- check that defineCellShapes before conn has same effect

*** only IT5B,SOM5B,PV5B cells, neuron 7.5, check subconn
noshape
shape
shape_nosubconn
noshape_nosubconn

[salvadord@comet-ln3 sim]$ sbatch init_noshape.sbatch
Submitted batch job 15377251
[salvadord@comet-ln3 sim]$ sbatch init_shape.sbatch
Submitted batch job 15377257
[salvadord@comet-ln3 sim]$ sbatch init_noshape_nosubconn.sbatch
Submitted batch job 15377262
[salvadord@comet-ln3 sim]$ sbatch init_shape_nosubconn.sbatch
Submitted batch job 15377263

*** only IT5B,SOM5B, 0.5 sec, size=100um, neuron 7.5

*** CONCLUSIONS
**** h.define_shape also fixes existing 3d points
h.define_shape not only adds 3d pts but fixes existing ones — eg. if x,y,z locs don’t match topology (see example above):

from neuron import h

soma = h.Section()
dend = h.Section()
dend.connect(soma, 1.0, 0.0)

# soma x from 0 to 10
h.pt3dadd(0, 0, 0, 5, sec=soma)
h.pt3dadd(10, 0, 0, 5, sec=soma)

# dend x set from 0 to 20
# but since connected to soma at 1.0
# x should go from 10 to 30
h.pt3dadd(0, 0, 0, 1, sec=dend)
h.pt3dadd(20, 0, 0, 1, sec=dend)

print h.x3d(0, sec=dend) # --> 0

# define_shape fixes 3d pts based on topology
h.define_shape()
print h.x3d(0, sec=dend) # --> 10

**** 3d pts of simplified cell models were wrong
-eg. dends didn't respect locations where connected to soma
I had set the 3d pts of simplified cells wrong (dend 1st point didn’t consider soma L)
with LFP I called h.define_shape (to convert any stylized geoms to 3d pt) and so it modified the existing 3d pts of simplfiied cells
it was also relevant in my sim since I place synapes based on yfrac, so this affected syn locations … most sims wouldn’t be affected I guess
was hard to pin down! but very glad to finally have it figured out

https://www.neuron.yale.edu/neuron/static/py_doc/modelspec/programmatic/topology/geometry.html?highlight=h%20define_shape#define_shape
**** fix
if cfg.reduced3DGeom: # set 3D pt geom
            offset, prevL = 0, 0
            somaL = netParams.cellParams[label]['secs']['soma']['geom']['L']
            for secName, sec in netParams.cellParams[label]['secs'].iteritems():
                sec['geom']['pt3d'] = []
                if secName in ['soma', 'Adend1', 'Adend2', 'Adend3']:  # set 3d geom of soma and Adends
                    sec['geom']['pt3d'].append([offset+0, prevL, 0, sec['geom']['diam']])
                    prevL = float(prevL + sec['geom']['L'])
                    sec['geom']['pt3d'].append([offset+0, prevL, 0, sec['geom']['diam']])
                if secName in ['Bdend']:  # set 3d geom of Bdend
                    sec['geom']['pt3d'].append([offset+0, somaL, 0, sec['geom']['diam']])
                    sec['geom']['pt3d'].append([offset+sec['geom']['L'], somaL, 0, sec['geom']['diam']])
                if secName in ['axon']:  # set 3d geom of axon
                    sec['geom']['pt3d'].append([offset+0, 0, 0, sec['geom']['diam']])
                    sec['geom']['pt3d'].append([offset+0, -sec['geom']['L'], 0, sec['geom']['diam']])
*** params
       	# 1) normal, 2) S2high+lowbkg, 3) S2low+bkg0.1, 4) S2low2+bkg0.1, 5) S2low2+M2low+bkg0.1, 6) S2low,
       	# 7) S2high, 8) S1high, 9) S1low, 10) M2low, 11) M2high
       	params[('ratesLong','S2')] =  [[0,2], high,    low,     low2,	 low2,		high, 	low,   [0,2], [0,2], [0,2], [0,2]]# 1) normal, 2) S2high+lowbkg, 3) S2low+bkg0.1, 4) S2low2+bkg0.1, 5) S2low2+M2low+bkg0.1, 6) S2low,
       	# 7) S2high, 8) S1high, 9) S1low, 10) M2low, 11) M2high
       	params[('ratesLong','S2')] =  [[0,2]]#, high,    low,     low2,	 low2,		high, 	low,   [0,2], [0,2], [0,2], [0,2]]
       	params[('ratesLong','S1')] =  [[0,2]]#, [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,2], 	[0,2], high,  low,   [0,2], [0,2]]
       	params[('ratesLong','M2')] =  [[0,2]]#, [0,0.1], [0,0.1], [0,0.1], low, 		[0,2], 	[0,2], [0,2], [0,2], high, 	low]
       	params[('ratesLong','TPO')] = [[0,4]]#, [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
       	params[('ratesLong','TVL')] = [[0,4]]#, [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
       	params[('ratesLong','cM1')] = [[0,4]]#, [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,4],	[0,4], [0,4], [0,4], [0,4], [0,4]]
       	params[('ratesLong','OC')] =  [[0,2]]#, [0,0.1], [0,0.1], [0,0.1], [0,0.1],	[0,2], 	[0,2], [0,2], [0,2], [0,2], [0,2]]
       	#params['ihGbar'] = [0.3, 0.4, 0.5, 1.0]
       	params['ihGbar'] = [0.3, 1.0]


       	params['ihGbar'] = [0.3, 1.0]

       	# initial config
       	initCfg = {}

       	initCfg['duration'] = 6.0*1e3
       	initCfg['ihModel'] = 'migliore'  # ih model

       	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
       	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
       	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
       	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
       	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
       	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

       	initCfg['somaNa'] = 5.0
       	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
       	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
       	initCfg['axonRa'] = 0.005
       	initCfg['gpas'] = 0.5
       	initCfg['epas'] = 0.9

       	initCfg[('analysis','plotRaster','timeRange')] = [500, 5500]

       	initCfg['weightNormThreshold'] = 4.0

       	initCfg['saveCellSecs'] = False
       	initCfg['saveCellConns'] = False

       	initCfg['IEGain'] = 1.0
       	initCfg['IIGain'] = 1.0
       	initCfg['IEdisynapticBias'] = None

       	# 1101 222

       	# # L2/3+4
       	initCfg[('IEweights',0)] = 1.2
       	initCfg[('IIweights',0)] =  1.0
       	# L5
       	initCfg[('IEweights',1)] = 1.2
       	initCfg[('IIweights',1)] = 1.0
       	# L6
       	initCfg[('IEweights',2)] =  1.2
       	initCfg[('IIweights',2)] =  1.0

** v50_batch3 - long - v49_batch19 1101 222 - 5 sec, just bkg, 5*5 iseeds, without LFP - wrong ratesLong!

- wasn't using the ratesLong from v49_batch19 1101 22 but the default ones instead

	params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('analysis','plotRaster','timeRange')] = [500, 5500]

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0


	groupedParams = []

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

** v50_batch4 - long - v49_batch19 1101 222 - 5 sec, just bkg, 5*5 iseeds, without LFP

- use correct ratesLong by setting in initCfg

	params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('analysis','plotRaster','timeRange')] = [500, 5500]

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,4]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,4]
	initCfg[('ratesLong','cM1')] = [0,4]  # higher from cM1 to account for ipsi M1
	initCfg[('ratesLong','OC')] =  [0,2]

	groupedParams = []

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)
*** results
- correlation between IT5B activity and lower PT5B activity


** v50_batch5 - long - v49_batch19 1101 222 - 5 sec, just bkg, 5*5 iseeds, without LFP, VecStim dur fixed, NEURON7.5
- rerun after fixing bug to ensure duration independence of VecStim random streams
params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,4]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,4]
	initCfg[('ratesLong','cM1')] = [0,4]  # higher from cM1 to account for ipsi M1
	initCfg[('ratesLong','OC')] =  [0,2]
** v50_batch6 - long - v49_batch19 1101 222 - 5 sec, just bkg, 5*5 iseeds, with LFP, VecStim dur fixed, NEURON7.5
params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,4]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,4]
	initCfg[('ratesLong','cM1')] = [0,4]  # higher from cM1 to account for ipsi M1
	initCfg[('ratesLong','OC')] =  [0,2]
** v51_batch1 - long - v49_batch19 1101 222 - 5 sec, just bkg, 5*5 iseeds, with LFP
*** issues reproducing v50_batch6
{'dictionary_item_added': set(["root['params']['defineCellShapes']"]),
 'dictionary_item_removed': set(["root['params']['cellParams']['IT5A_full']['secs']['soma']['weightNorm']",
                                 "root['params']['cellParams']['IT5B_reduced']['globals']['v_init']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['Adend1']['vinit']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['Adend2']['vinit']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['Adend3']['vinit']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['Bdend']['vinit']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['axon']['vinit']",
                                 "root['params']['cellParams']['IT5B_reduced']['secs']['soma']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['globals']['v_init']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['Adend1']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['Adend2']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['Adend3']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['Bdend']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['axon']['vinit']",
                                 "root['params']['cellParams']['IT6_reduced']['secs']['soma']['vinit']"]),

- Fixed v_init and weightNorm

 'values_changed': {"root['params']['cellParams']['CT6_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.006525571237494247,
                                                                                                       'old_value': 0.006616035423613187},
                    "root['params']['cellParams']['IT6_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.0048984211767112125,
                                                                                                       'old_value': 0.005092788059411614},
                    "root['params']['cellParams']['PT5B_reduced']['secs']['Adend3']['weightNorm'][0]": {'new_value': 0.0022622577631087612,
                                                                                                        'old_value':
  0.002919143427909488},

- these weighNorm changes are due to note being updated before -- so will lead to small diffs but are ok

*** params
params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,4]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,4]
	initCfg[('ratesLong','cM1')] = [0,4]  # higher from cM1 to account for ipsi M1
	initCfg[('ratesLong','OC')] =  [0,2]
** v51_batch2 - long, 51 sec, just bkg, 1 seed

- Seg fault while gathering
- Rerun without saving traces

	params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234]#+(17*i) for i in range(25)]


	# initial config
	initCfg = {}

	initCfg['duration'] = 51.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# 1101 222

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.2
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.2
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.2
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,4]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,4]
	initCfg[('ratesLong','cM1')] = [0,4]  # higher from cM1 to account for ipsi M1
	initCfg[('ratesLong','OC')] =  [0,2]

** v51_batch3 - long, 51 sec, just bkg, 1 seed, with LFP
** v51_manualTune -
*** check why IT5B correlated with lowerPT and inv corr with upperPT
- set correct batch params in cfg
- cfg.compactConnFormat = 1
- cfg.saveConns = 1
- running on zn
- copy output to local
- plot conn matrices interactively

- check high-level conn matrices
- play with reduced size sims or with just L5B pops

- HINTS:
-- IT5B->lowerPT5B quite high
-- PT5B->upperPT5B low, but high to lowerPT5B

** v52_batch3 - weightNorm reduced IT cells
wscale.py
** v52_batch2 - Test with new conns, default conn params

	params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

** v52_batch1 - fI curves
** v52_batch4 - Test a couple sim with prev working params
rerun after fixing cell densities
** v52_batch5 - EI,II tuning with new conn (made cM1,M2->L5B change afterwards)
NOTE: made changes after running sim: cM1,M2 -> L5B conn (kept same upper vs lower L5B)

params[('ratesLong', 'TPO', 1)] = [2,4]
	params[('ratesLong', 'TVL', 1)] = [2,4]
	# params[('ratesLong', 'S1', 1)] = [2,4]
	# params[('ratesLong', 'cM1', 1)] = [2,4]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

** TODO - replicate S2, M2, simult, time-varying figs; test 10 secs;
** v52_batch6 - test a couple sims in gcp (8*32 cores)
** v52_batch7 - test a couple sims in gcp (4*32 cores)
** v52_batch8 - test a couple sims in gcp (8*8 cores)
** v52_batch9 - long input balance (3*8 cores)
- 1*8 cores
 --------------------------------------------------------------------------
mpirun noticed that process rank 3 with PID 13527 on node compute185 exited on signal 9 (Killed).
--------------------------------------------------------------------------
- reran with 3*8 cores

	params[('ratesLong', 'TPO', 1)] = [2,4]
	params[('ratesLong', 'TVL', 1)] = [2,4]
	params[('ratesLong', 'S1', 1)] = [2,4]
	params[('ratesLong', 'S2', 1)] = [2,4]
	params[('ratesLong', 'cM1', 1)] = [2,4]
	params[('ratesLong', 'M2', 1)] = [2,4]
	params[('ratesLong', 'OC', 1)] = [2,4]

	#
	params['IEweights'] = [[1.0,1.0,1.0], [1.2,1.2,1.2]]
	params['IIweights'] =  [[1.0,1.0,1.0], [1.2,1.2,1.2]]

	params['ihGbar'] = [0.25, 1.0]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results - VL -> L5B profile has strong effect -- make uniforma as suggested by gordon!


** v52_batch10 - long input balance, fixed S2->L23, TVL->L5B (3*8 cores)
       	params[('ratesLong', 'TPO', 1)] = [2,4]
       	params[('ratesLong', 'TVL', 1)] = [2,4]
       	params[('ratesLong', 'S1', 1)] = [2,4]
       	params[('ratesLong', 'S2', 1)] = [2,4]
       	params[('ratesLong', 'cM1', 1)] = [2,4]
       	params[('ratesLong', 'M2', 1)] = [2,4]
       	params[('ratesLong', 'OC', 1)] = [2,4]

       	#
       	params['IEweights'] = [[0.8,0.8,0.8], [1.0,1.0,1.0], [1.2,1.2,1.2]]
       	params['IIweights'] =  [[0.8,0.8,0.80], [1.0, 1.0, 1.0], [1.2,1.2,1.2]]

       	params['ihGbar'] = [0.25, 1.0]

       	groupedParams = []

       	# initial config
       	initCfg = {}
       	initCfg['duration'] = 2.0*1e3
       	initCfg['ihModel'] = 'migliore'  # ih model

       	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
       	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
       	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
       	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
       	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
       	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

       	initCfg['somaNa'] = 5.0  # somatic Na conduct
       	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
       	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
       	initCfg['axonRa'] = 0.005
       	initCfg['gpas'] = 0.5
       	initCfg['epas'] = 0.9

       	initCfg[('pulse', 'pop')] = 'S2'
       	initCfg[('pulse', 'rate')] = 10.0
       	initCfg[('pulse', 'start')] = 1000.0
       	initCfg[('pulse', 'end')] = 1100.0
       	initCfg[('pulse', 'noise')] = 0.8

       	initCfg['IEdisynapticBias'] = None

       	initCfg['weightNormThreshold'] = 4.0
       	initCfg['IEGain'] = 1.0
       	initCfg['IIGain'] = 1.0
       	initCfg['IPTGain'] = 1.0

       	initCfg['saveCellSecs'] = False
       	initCfg['saveCellConns'] = False

*** issues
lower PTs fire more but:
- num exc conns higher in upper [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_105819.png][fig]]
- num inh conns lower in upper [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_105839.png][fig]]

check projections from individual pops, maybe only subset firing

In [37]: from matplotlib import pyplot as plt; nis = []; ynorms=[]; plt.figure()
    ...: preCells = [c for p in ['S1', 'S2'] for c in sim.net.pops[p].cellGids]
    ...: for i in sim.net.pops['SOM5B'].cellGids: #+sim.net.pops['IT6'].cellGids:
    ...:     cell = sim.net.cells[i]
    ...:     nis.append(len([conn for conn in cell.conns if 'AMPA' in conn['synMech'] and conn['preGid'] in preCells]))
    ...:     ynorms.append(cell.tags['ynorm'])
    ...: plt.scatter(ynorms,nis); plt.ion(); plt.show()

- PT5B -> PT5B - ok [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_105758.png][fig]]
- cM1, M2 -> PT5B - ok [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_112652.png][fig]] (1350)
- S1, S2 -> PT5B - ok [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_112901.png][fig]]
- S1, S2 -> PV5B - maybe?  [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_113200.png][fig]]
- TVL -> PT5B - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180501_113103.png][fig]]

- weights follow same pattern

- Maybe S1,S2 -> PV5B,SOM5B upper is causing more inhibition -- check sim with homog S1,S2

- run with homogeneous S2 input
- netClamp PT5B different depths

** v52_batch11 - check with homog S2 input, record from different PT cells
1 sec
saveCellSecs=1
record cells: [(pop,50) for pop in ['IT2', 'IT4', 'IT5A', 'PT5B']]+[('PT5B',x) for x in [393,447,579,19,104,214,1138,979,799]]

	params['ihGbar'] = [0.3, 1.0]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]


** v52_batch12 - check correctBorderThreshold

	params['ihGbar'] = [0.3]
	params['correctBorderThreshold'] = [0, 150.0, 300.0]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

** v52_batch13 - check bordeqr higher values
	params['ihGbar'] = [0.3]
	params['correctBorderThreshold'] = [300.0, 400.0]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

** v52_batch14 - test uniform probablity
	params['ihGbar'] = [0.3]
	params['correctBorderThreshold'] = [0.3, 0.4, 0.5]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

** v52_batch15 - test uniform PT5B
	params['ihGbar'] = [0.3]
	params['correctBorderThreshold'] = [0, 150]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

** v52_batch16 - reduced recurrent PT5B

	params['ihGbar'] = [0.3, 1.0]
	params['correctBorderThreshold'] = [0, 50, 150]
	params['IEweights'] = [[0.8,0.8,0.8], [1.0,1.0,1.0], [1.2,1.2,1.2]]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	#initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	#initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	#initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

*** results
depol block in PTs!
(2931, 0.42425022781029104) - depol
 (5180, 0.7739594382573945) - no spk
 (5523, 0.737937021593578) - no spk
 (5709, 0.5625388277036746) - depol
 (5149, 0.6233039662350659) - depol
 (5234, 0.5221008940548401) - depol
 (5344, 0.6030785962093904) - small depol
 (6268, 0.645351377866382) - no depol
 (5929, 0.5983156047113436) - depol

upper layer all depol -- so maybe broder effect also due to depol

** v52_batch17 - test L5Brecurrent, ITinter and strength factors
	params['ihGbar'] = [0.3, 1.0]
	params['correctBorderThreshold'] = [0, 100]
	params['L5BrecurrentFactor'] = [0.5, 0.75, 1.0]
	params['ITinterFactor'] = [0.5, 0.75, 1.0]
	params['strengthFactor'] = [0.8, 0.9, 1.0]
	params[('seeds', 'stim')] = [1234, 1234]#+(17*i) for i in range(25)]

	# initial config
	initCfg = {}

	initCfg['duration'] = 1.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg['weightNormThreshold'] = 4.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IEdisynapticBias'] = None

	# # L2/3+4
	#initCfg[('IEweights',0)] = 1.0
	initCfg[('IIweights',0)] =  1.0
	# L5
	#initCfg[('IEweights',1)] = 1.0
	initCfg[('IIweights',1)] = 1.0
	# L6
	#initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	# long-range rates
	initCfg[('ratesLong','S2')] =  [0,2]
	initCfg[('ratesLong','S1')] =  [0,2]
	initCfg[('ratesLong','M2')] =  [0,2]
	initCfg[('ratesLong','TPO')] = [0,2]  # higher from thalamus
	initCfg[('ratesLong','TVL')] = [0,2]
	initCfg[('ratesLong','cM1')] = [0,2]
	initCfg[('ratesLong','OC')] =  [0,2]

*** results
- if input from L2 -> high upper PT
- if no input from L2 (from L5B?) -> high lower PT

- borderEffect=100 reduces PT (less depol block) -> more oscs

- inc L5Brecurr -> reduces PT (why?) (less depol block) -> more osc

- high L5Brecurr + bordereffect 100 -> low PT, no upper layer osc

- ITinterfactor inc -> more IT5A -> PT5B (triggers intrinsic osc) -- undesired effect?

*NOTE: borderEffect should be 200um to match length constant of 100um (~22 % prob for 200)

** v52_batch18 - EIbalance small sample

cfg.L5BrecurrentFactor = 1.0
cfg.ITinterFactor = 1.0
cfg.strengthFactor = 1.0

	params[('ratesLong', 'TPO', 1)] = [2,4]
	params[('ratesLong', 'TVL', 1)] = [2,4]

	params['EEGain'] = [0.8, 1.0, 1.2]
	params['IEweights'] = [[0.8,0.8,0.8], [1.0,1.0,1.0], [1.2,1.2,1.2]]
	params['IIweights'] =  [[0.8,0.8,0.80], [1.0, 1.0, 1.0], [1.2,1.2,1.2]]
	params['ihGbar'] = [0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
- 00 0 10 0
- 00 0 11 0
- 00 0 22 0
- 00 1 21 0
- 11 0 11 0
- 11 0 22 0


** v52_batch19 - EIBalance full

cfg.L5BrecurrentFactor = 1.0
cfg.ITinterFactor = 1.0
cfg.strengthFactor = 1.0
diagScaleFactor = 1.0


	params[('ratesLong', 'TPO', 1)] = [2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2,2,2,4,2,4,4,4]

	params['EEGain'] = [0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
 	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
**** depol block
- 1030/1152 no depol block - great!
**** refine
- EEGain 0.8 - or lower?
- input to T and S = 4Hz; to cM1 and M2 = 2 Hz
-- maybe separate out TVL - group S vs M
- ih values - higher - try 0.3, 0.4, 0.5

** v52_batch20 - EIbalance finetune
params = specs.ODict()

	params[('ratesLong', 'TPO', 1)] = [4, 4]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [4, 2]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [4, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [4, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2, 2]#[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2, 2] #[2,2,2,4,2,4,4,4]

	params['EEGain'] = [0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.3, 0.4, 0.5, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

** v52_batch21 - EIBalance finetune

	params[('ratesLong', 'TPO', 1)] = [2, 4]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [1, 2]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [2, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [2, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [1, 2]#[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [1, 2] #[2,2,2,4,2,4,4,4]

	params['EEGain'] = [0.5,0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.0, 0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
- with ratesLong=0 --> great ih differences, but low IT2 rates
- overall seems IT2->IT5A and IT2->PT5B too strong; or I->E too low (low IT2 rate -> hight IT5A,PT5B rate)

- try 3:1 Hz and 4:1 Hz

- good rates + ih increase (most low IT4):
-- 1_0_0101 (rates=4, EE=0.5, IE_L2=low, IE_L5=low) - small ih increase
-- 1_0_1101 - low PT pre-stim
-- 1_0_2101 - low IT
-- 1_1_0100 -

** v52_batch22 - EIbalance finetune
	params[('ratesLong', 'TPO', 1)] = [3, 4] #[2, 4]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [1, 1] #[1, 2]#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [3, 4] #[2, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [3, 4] #[2, 4] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [1, 1] #[1, 2]#[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [1, 1] #[1, 2] #[2,2,2,4,2,4,4,4]

	params['EEGain'] = [0.5,0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8, 1.0, 1.2]
	params[('IIweights',0)] =  [0.8, 1.0, 1.2]
	# L5
	params[('IEweights',1)] = [0.8, 1.0, 1.2]
	params[('IIweights',1)] =  [0.8, 1.0, 1.2]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params['ihGbar'] = [0.0, 0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1)]# ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
1_0_1_2_1_2 - great, except low IT4+CT6

1_1_1_1_1_1 - good but missing ih=1 -- RERUN!

1_1_1_1_2_2 - good but missing ih=1 -- RERUN!

1_1_1_2_2_1 - good but low PT (and big peak) before stim

** v52_batch23 - long stim with v52_batch21 1_1_0100
params = specs.ODict()

	params[('ratesLong', 'TPO', 1)] = [4,5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2,2] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [4,5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [4,5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2,2] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2,2] #[2,2,2,4,2,4,4,4]

	params['EEGain'] = [0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'pop')] = ['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']

	params['ihGbar'] = [0.0, 0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


*** results
rates 0 - IT2 slightly too low
rates 1 - leads to higher IT rates (good for IT2)

- TPO:
-- rates 0: ih 1,2 -> great
-- rates 1: ih 1,2 -> good (higher IT rate before stim)

- S1:
-- rates 0: ih 1,2 -> higher avg PT, but same peak
-- rates 1: ih 1,2 -> great

- S2:
-- rates 0: ih 1,2 -> great
-- rates 1: ih 1 looks good; missing ih 2

- cM1:
-- rates 0: ih 1,2 -> great
-- rates 1: ih 1,2 -> peak similar, avg higher;

- M2:
-- rates 0: ih 1,2 -> great (big diff!)
-- rates 1: ih 1,2 -> peak similar, avg higher

use rates 0 - but try to get higher IT4 (IT2?) and CT

** v52_batch24 - EIbalance from v52_batch23 to increase IT4 and CT

	params = specs.ODict()

	params[('ratesLong', 'TPO', 1)] = [4,5,5,6, 5,6,6,7] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2,2,2,2, 2,2,2,2] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [4,4,3,2, 5,5,4,3] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [4,4,4,4, 5,5,5,5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2,2,2,2, 2,2,2,2] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2,2,2,2, 2,2,2,2] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [3,3,3,3, 4,4,4,4]

	params['EEGain'] = [0.5,0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6
	# params[('IEweights',2)] =  [0.8, 1.0, 1.2]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'pop')] = ['S2', 'M2'] #['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']

	params['ihGbar'] = [0.25, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'S2'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results
rates 0, EE 0 - low IT4,CT
rates 0, EE 1 - CT

- use CT = 4Hz or 5Hz - ok
- set IEweights[2] = 0.8
- increase local/long -> IT4 - ok
- use EE = 0.6 (good fot IT2)


** v52_manualTune
*** v52_tune3 - netClamp
--> 5180 0.773959438257 - 2spk
5523 0.737937021594 - 4
5709 0.562538827704 - 2
5149 0.623303966235 - 3
--> 5234 0.522100894055 - 2
5344 0.603078596209 - 2
6268 0.645351377866 - 6
5929 0.598315604711 - 2

6305 - 35 spikes -- check ynorm!

*** v52_tune5 - save compact conn format and plot conn figs interactively from gcp controller"




** v53_batch1 - changes to increase IT4 and CT; multiple ih levels; 4 long pops
Note: using old exc -> L4 inputs

	params[('ratesLong', 'TPO', 1)] = [5, 5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 2.5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [5, 5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [5, 5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [5, 5]

	params['EEGain'] = [0.5, 0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6

	params[('IEweights',2)] =  [0.8, 1.0]
	params[('pulse', 'rate')] = [10.0, 15.0]
	params[('pulse', 'pop')] = ['S2', 'M2'] #['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']

	params['ihGbar'] = [0.2, 0.25, 0.3, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'S2'
	#initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


*** results
- long=5,2, EE=0.5, IIweights_0=0.8, IEweights_2=1.0, 10 Hz, M2, ih=0.3 -- great, but ih=1 too low PT
- long=5,2, EE=0.6, IIweights_0=0.8, IEweights_2=0.8, 10 hz, M2, ih=0.25,0.3 -- great
- long=5,2, EE=0.6, IIweights_0=0.8, IEweights_2=0.8, 15 hz, M2, ih=0.25,0.3 -- great
- long=5,2, EE=0.6, IIweights_0=0.8, IEweights_2=1.0, 10 hz, M2, ih=0.3 -- great
- long=5,2, EE=0.6, IIweights_0=0.8, IEweights_2=1.0, 10 hz, M2, ih=0.3 -- great
- long=5,2, EE=0.6, IIweights_0=0.8, IEweights_2=1.0, 10 hz, M2, ih=0.3 -- great
- long=5,2, EE=0.6, IIweights_0=1.0, IEweights_2=0.8, 10 hz, M2, ih=0.2,0.25 -- great
- long=5,2, EE=0.6, IIweights_0=1.0, IEweights_2=0.8, 15 hz, M2, ih=0.2,0.25 -- great

BOTH! - _0_0_0_0_0_0_0_1_0_1_0_0_1_0_pop_ih
- long=5,2, EE=0.6, IIweights_0=1.0, IEweights_2=1.0, 10 hz, S2, ih=0.25,0.3 -- great
- long=5,2, EE=0.6, IIweights_0=1.0, IEweights_2=1.0, 10 hz, M2, ih=0.3 -- great

long=5, 2.5 --> IT2 rates too low; PT higher

- good S2: many with rates 5,2 and 5,2.5




** v53_batch2 - same as v53_batch1 but with new/higher exc->IT4 from Yamawaki


** v53_batch3 - test S2=10% and TPO=15% to provide more input to IT4

	params[('ratesLong', 'TPO', 1)] = [5, 5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 2.5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [5, 5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [5, 5] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [5, 5]

	params['EEGain'] = [0.5, 0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0] #[0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6
	params[('IEweights',2)] =  [0.8] #[0.8, 1.0]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'rate')] = [10.0] #[10.0, 15.0]

	params[('pulse', 'pop')] = ['S2', 'M2'] #['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'S2'
	#initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results

v53_batch3_0_1_ - good! IT2/IT4 a bit too low for M2 input
v53_batch3_1_1_ - good! IT2/IT4 a bit too low for M2 input

** v53_batch4 - check with sesnory long rates = 6 hz (instead of 5)
notE: changed IEweights2 to 1.0

	params[('ratesLong', 'TPO', 1)] = [6] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [6] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [6] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [6]

	params['EEGain'] = [0.5] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0] #[0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6
	params[('IEweights',2)] =  [1.0] #[0.8, 1.0]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'rate')] = [10.0] #[10.0, 15.0]

	params[('pulse', 'pop')] = ['S2', 'M2'] #['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

*** results
still very low IT4 - but good enough

** v53_batch5 - test both S2 and TPO = 15%

	params[('ratesLong', 'TPO', 1)] = [5, 5,   6, 6] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 2.5, 2, 3] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [5, 5,   6, 6] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [5, 5,   6, 6] #[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2, 2.5, 2, 3] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2, 2.5, 2, 3] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [5, 5,   6, 6]

	params['EEGain'] = [0.5, 0.6] #[0.6, 0.8] #[0.8, 1.0]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0] #[0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8]
	params[('IIweights',1)] = [0.8]
	# L6
	params[('IEweights',2)] =  [1.0] #[0.8, 1.0]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'rate')] = [10.0] #[10.0, 15.0]

	params[('pulse', 'pop')] = ['S2'] #['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIG

*** results
- 0_0 - low IT4
- 0_1 - ih1 PT too high
- 1_0 - low IT4
- 1_1 - ih1 PT too high
- 2_0 - low IT4
- 2_1 - ih1 PT too high
- 2_0 - low IT4
- 2_1 - ih1 PT too high


** v53_batch6 - increased TVL->L4 based on yamawaki fig 6F
- first was wrong - M2=2hz, S2=15%

	params[('ratesLong', 'TPO', 1)] = [5, 5] 	#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 2.5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [5, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [5, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [5, 5]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8, 1.0]
	params[('IIweights',1)] = [0.8, 1.0]
	# L6
	params[('IEweights',2)] =  [1.0] # [0.8, 1.0]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'rate')] = [10.0] # [10.0, 15.0]

	params[('pulse', 'pop')] = ['S2', 'M2'] # ['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

	# groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
	# 				('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
	# 				('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
	# 				('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'S2'
	#initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

*** results
- 0_01010_0 - good S2+M2 (S2 ih=1 missing)
- 1_01000_0 - good S2+M2 (M1 ih=0 IT4 too low)
- 1_01010_0 - good S2+M2 (ih=1 PT a bit too high)


** v53_batch7 - v53_batch6 - 0_01010_0 51sec, LFP
	params[('ratesLong', 'TPO', 1)] = [5] #[5, 5] 	#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2] # [2, 2.5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [5] #[5, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [5] #[5, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'cM1', 1)] = [2] #[2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'M2', 1)] =  [2] #[2, 2.5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [5] #[5, 5]

	# # L2/3+4
	params[('IEweights',0)] =  [0.8]
	params[('IIweights',0)] =  [1.0] #[0.8, 1.0]
	# L5
	params[('IEweights',1)] = [0.8] #[0.8, 1.0]
	params[('IIweights',1)] = [1.0] #[0.8, 1.0]
	# L6
	params[('IEweights',2)] =  [1.0] # [0.8, 1.0]
	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

	params[('pulse', 'rate')] = [10.0] # [10.0, 15.0]

	#params[('pulse', 'pop')] = ['S2', 'M2'] # ['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
					('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
					('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
					('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

	# initial config
	initCfg = {}
	initCfg['duration'] = 51.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'None'
	#initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['EEGain'] = 0.5 # [0.6, 0.8] #[0.8, 1.0]

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)


	return b

** v53_batch8 - v53_batch6 - 0_01010_0 with EI_0=0.6, II_0=1.2
       	params[('ratesLong', 'TPO', 1)] = [5, 5] 	#[2,4,2,2,4,2,4,4]
       	params[('ratesLong', 'TVL', 1)] = [2, 2.5] #[2,4,2,2,4,2,4,4]
       	params[('ratesLong', 'S1', 1)] =  [5, 5] 	#[2,2,4,2,4,4,2,4]
       	params[('ratesLong', 'S2', 1)] =  [5, 5] 	#[2,2,4,2,4,4,2,4]
       	params[('ratesLong', 'cM1', 1)] = [2, 2.5] #[2,2,2,4,2,4,4,4]
       	params[('ratesLong', 'M2', 1)] =  [2, 2.5] #[2,2,2,4,2,4,4,4]
       	params[('ratesLong', 'OC', 1)] =  [5, 5]

       	# # L2/3+4
       	params[('IEweights',0)] =  [0.6,0.8]
       	params[('IIweights',0)] =  [1.0,1.2] #[0.8, 1.0]
       	# L5
       	params[('IEweights',1)] = [0.8] #[0.8, 1.0]
       	params[('IIweights',1)] = [1.0] #[0.8, 1.0]
       	# L6
       	params[('IEweights',2)] =  [1.0] # [0.8, 1.0]
       	# params[('IIweights',2)] =  [0.8, 1.0, 1.2]

       	params[('pulse', 'rate')] = [10.0] # [10.0, 15.0]

       	params[('pulse', 'pop')] = ['S2', 'M2'] # ['TPO', 'S1', 'S2', 'TVL', 'cM1', 'M2']


       	params['ihGbar'] = [0.25, 1.0] #[0.2, 0.25, 0.3, 1.0]

       	groupedParams = [('ratesLong', 'TPO', 1), ('ratesLong', 'TVL', 1),
				       	('ratesLong', 'S1', 1), ('ratesLong', 'S2', 1),
				       	('ratesLong', 'cM1', 1), ('ratesLong', 'M2', 1),
				       	('ratesLong', 'OC', 1)] # ['IEGain','IIGain'] #'EEGain', 'EPVGain', 'ESOMGain', 'PVEGain', 'SOMEGain', 'PVIGain', 'SOMIGain']

       	# initial config
       	initCfg = {}
       	initCfg['duration'] = 2.0*1e3
       	initCfg['ihModel'] = 'migliore'  # ih model

       	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
       	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
       	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
       	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
       	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
       	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

       	initCfg['somaNa'] = 5.0  # somatic Na conduct
       	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
       	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
       	initCfg['axonRa'] = 0.005
       	initCfg['gpas'] = 0.5
       	initCfg['epas'] = 0.9

       	#initCfg[('pulse', 'pop')] = 'None'
       	#initCfg[('pulse', 'rate')] = 10.0
       	initCfg[('pulse', 'start')] = 1000.0
       	initCfg[('pulse', 'end')] = 1100.0
       	initCfg[('pulse', 'noise')] = 0.8

       	initCfg['IEdisynapticBias'] = None

       	initCfg['EEGain'] = 0.5 # [0.6, 0.8] #[0.8, 1.0]

       	initCfg['weightNormThreshold'] = 4.0
       	initCfg['IEGain'] = 1.0
       	initCfg['IIGain'] = 1.0
       	initCfg['IPTGain'] = 1.0
       	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

       	initCfg['saveCellSecs'] = False
       	initCfg['saveCellConns'] = False


*** results
- 011 - rates=2, IE_0 = 0.8, II_0 = 1.2 - great, both; IT5A 15-18hz; IT2 0.2-0.4hz
- 111 - ok, but PT too high

** v53_batch9 - same with TPO=10%

*** results
- 010 - ok, but small PT difference; IT5A 12-20hz; IT4 0.15-0.3hz
- 100 - good, IT5A 8-11hz; IT4 0.1-0.4hz

** OPTIONS (10):
- changed S2=15%, TPO=10% -> S2=10%, TPO=15%
v53_batch3_0_1_ - good! IT2/IT4 a bit too low for M2 input -- discard (IT2,IT4,PT5B too low)
v53_batch3_1_1_ - good! IT2/IT4 a bit too low for M2 input -- discard (IT2,IT4,PT5B too low)

- long rates from 2,5;2.5,5 -> 2,6 Hz
v53_batch4 - still very low IT4  -- overall low rates; low IT4, low PT, but good PT difference

- S2=10%, TPO=15% -> S2=15%, TPO=15%
- increased TVL->L4
v53_batch6 - 0_01010_0 - good S2+M2 (S2 ih=1 missing) -- IT5A too high, but potentially good (rerun!)
v53_batch6 - 1_01000_0 - good S2+M2 (M1 ih=0 IT4 too low) -- IT4, PT5 low, but good PT diff
v53_batch6- 1_01010_0 - good S2+M2 (ih=1 PT a bit too high) -- discard

- EI_0=0.6, II_0=1.2
v53_batch8 - 011 - rates=2, IE_0 = 0.8, II_0 = 1.2 - great, both; IT5A 15-18hz; IT2 0.2-0.4hz -- great (IT5A high)
----> v53_batch8 - 111 - ok, but PT a bit too high -- great (IT5A high, but less than prev) --> BEST

- S2=10%; EI_0=0.6, II_0=1.2
v53_batch9 - 010 - ok, but small PT difference; IT5A 12-20hz; IT4 0.15-0.3hz -- good (smaller PT diff, IT5A high)
v53_batch9 - 100 - good, IT5A 8-11hz; IT4 0.1-0.4hz -- good (PT diff good, IT4 a bit low; high IT5A peak; irregular)



** v53_batch10 - v52_batch8_111 - long pop, 5*5 seeds
	params = specs.ODict()

	params['ihGbar'] = [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1'

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

** v53_batch11 - v52_batch8_111 - long pop, 51 sec with LFP
- on 128 cores, 16 non-preeemptible nodes
- memory error during gathering! remove LFP recording

	params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
	#params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	#params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None']# ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 51.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False




** v53_batch12 - v52_batch8_111 - 6 sec, LFP+traces

	params['ihGbar'] = [0.25, 0.3, 1.0] # [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321,4321]#[4321+(17*i) for i in range(5)]
	#params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None']# ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

** v53_batch13 - v52_batch8_111 - 6 sec, LFP, 5*5 seeds

	params['ihGbar'] = [0.25, 0.3, 1.0] # [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321,4321]#[4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None']# ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


** v53_batch14 - v52_batch8_111 - 2 sec, long stim, LFP, 5*5 seeds

	params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321,4321]#[4321+(17*i) for i in range(5)]
	#params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


*** results
- S2:
-- raster/hist: ok
-- stats: okish

- M2: ****
-- raster/hist: good
-- stats: great

- TPO: ****
-- raster/hist: ok (hist slightly better than S2)
-- stats: ok (better than S2)

- TVL:
-- raster/hist: good
-- stats: great

** v53_batch15 - v52_batch8_111 - 2.5sec, stim at 1500, long stim, LFP, 5*5 seeds

- missing 1 json file: v53_batch15_1_1_1_3_0.json - reran on gcp

	params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',

	params[('pulse', 'rate')] = [10.0,15.0]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 2.5*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1500.0
	initCfg[('pulse', 'end')] = 1600.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

*** results

10 Hz
- S2:
-- raster/hist: bad
-- stats: okish

- M2:
-- raster/hist: great
-- stats: great

- TPO:
-- raster/hist:  bad
-- stats: ok

- TVL:
-- raster/hist: great
-- stats: great

15 Hz
- S2:
-- raster/hist: bad
-- stats: okish

- M2: ****
-- raster/hist: great
-- stats: great

- TPO: ****
-- raster/hist: okish
-- stats: ok

- TVL:
-- raster/hist: great
-- stats: great


** v53_batch16 - simult
	params[('pulse', 'pop')] = ['TPO', 'M2', 'TVL', 'S2', 'S2', 'M2']
	params[('pulse2', 'pop')] = ['M2', 'TPO', 'S2', 'TVL', 'M2', 'S2']
	params[('pulse2', 'start')] = list(np.arange(1000, 1220, 20))
	params['ihGbar'] = [0.25, 1.0]


	# initial config
	initCfg = {}
	initCfg['duration'] = 2.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes)
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate)
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	#initCfg[('pulse2', 'start')] = 1500.0
	initCfg[('pulse2', 'rate')] = 10.0
	initCfg[('pulse2', 'duration')] = 100.0
	initCfg[('pulse2', 'noise')] = 0.8


	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2
	# L5
	initCfg[('IEweights',1)] = 0.8
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	groupedParams = [('pulse', 'pop'),('pulse2', 'pop')]
	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

** v53_batch17,20,23,24 - EVOL OPTIM FOR GRANT 
- semi-succesful (batch24)
- 134 generations
- lowered fitness error from 69 to 17

def evolRates():
	# --------------------------------------------------------
	# parameters
	params = specs.ODict()

	# long-range inputs
	params[('ratesLong', 'TPO', 1)] = [2, 5] 	#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 5] #[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'S1', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'M2', 1)] =  [2, 5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [2, 5]	

	# EEgain
	params['EEGain'] = [0.5, 1.0] 

	# IEgain
	## L2/3+4
	params[('IEweights',0)] =  [0.8, 1.2]
	## L5
	params[('IEweights',1)] = [0.8, 1.2] #[0.8, 1.0]   
	## L6
	params[('IEweights',2)] =  [0.8, 1.2] # [0.8, 1.0]  

	# IIGain
	params['IIGain'] = [0.8, 1.2]
	
	# ih
	params['ihGbar'] = [0.1, 0.3] #[0.2, 0.25, 0.3, 1.0]

	groupedParams = []

	# --------------------------------------------------------
	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


	# --------------------------------------------------------
	# fitness function
	fitnessFuncArgs = {}
		
	## complex net
	pops = {} 
	Etune = {'target': 10, 'width': 5, 'min': 0.4}
	pops['IT2'] = Etune
	pops['IT4'] = Etune
	pops['IT5A'] = Etune 
	pops['IT5B'] = Etune  
	pops['PT5B'] = Etune 
	pops['IT6'] =  Etune
	pops['CT6'] =  Etune

	Itune = {'target': 15, 'width': 10, 'min': 0.4}
	pops['PV2'] = Itune
	pops['SOM2'] = Itune
	pops['PV5A'] = Itune
	pops['SOM5A'] = Itune
	pops['PV5B'] = Itune
	pops['SOM5B'] = Itune
	pops['PV6'] = Itune
	pops['SOM6'] = Itune
	
	fitnessFuncArgs['pops'] = pops
	fitnessFuncArgs['maxFitness'] = 1000

	def fitnessFunc(simData, **kwargs):
		import numpy as np
		pops = kwargs['pops']
		maxFitness = kwargs['maxFitness']
		fitness = np.mean([min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
				if simData["popRates"][k]>v['min'] else maxFitness for k,v in pops.iteritems()])
		#print 'fitness = %f'%(fitness)
		return fitness
	
	#from IPython import embed; embed()

	b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

	# Set evol alg configuration
	b.evolCfg = {
		'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
		'fitnessFuncArgs': fitnessFuncArgs,
		'pop_size': 50,
		'num_elites': 5, # keep this number of parents for next generation if they are fitter than children
		'maximize': False, # maximize fitness function?
		'max_generations': 200,
		'time_sleep': 60, # wait this time before checking again if sim is completed (for each generation)
		'maxiter_wait': 25, # max number of times to check if sim is completed (for each generation)
		'default_fitness': 1000 # set fitness value in case simulation time is over
	}


	return b
** v54_batch1 - NetPyNE v0.9.1.1 reproduce v53_batch13 (comet)
Note 1: 27/50 crashed -- rerunning with 4*24 cores
Note2 2: the "10 0" prints in the out file come from python2 + standard_library.install_aliases()


	params = specs.ODict()
	
	params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
	params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
	params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

	params[('pulse', 'pop')] = ['None']# ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
	#params[('pulse', 'end')] = [1100, 1500]

	groupedParams = []

	# initial config
	initCfg = {}
	initCfg['duration'] = 6.0*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	#initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'rate')] = 10.0
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['EEGain'] = 0.5 
	initCfg['IEGain'] = 1.0
	initCfg['IIGain'] = 1.0
	initCfg['IPTGain'] = 1.0

	initCfg[('ratesLong', 'TPO', 1)] = 5 	
	initCfg[('ratesLong', 'TVL', 1)] = 2.5
	initCfg[('ratesLong', 'S1', 1)] = 5
	initCfg[('ratesLong', 'S2', 1)] = 5 
	initCfg[('ratesLong', 'cM1', 1)] = 2.5
	initCfg[('ratesLong', 'M2', 1)] = 2.5
	initCfg[('ratesLong', 'OC', 1)] = 5	

	# # L2/3+4
	initCfg[('IEweights',0)] =  0.8
	initCfg[('IIweights',0)] =  1.2 
	# L5
	initCfg[('IEweights',1)] = 0.8   
	initCfg[('IIweights',1)] = 1.0
	# L6
	initCfg[('IEweights',2)] =  1.0  
	initCfg[('IIweights',2)] =  1.0

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False

	groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

	b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

	return b



** v54_batch2 - 2.5sec, stim at 1500, long stim, LFP, 5*5 seeds (reproduce v53_batch15) (no data) 
not sure if ran on comet or gcp, but there's no data; so maybe didn't run


def longPopStims():
    params = specs.ODict()
    
    params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
    params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
    params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

    params[('pulse', 'pop')] = ['None', 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
    #params[('pulse', 'end')] = [1100, 1500]

    groupedParams = []

    # initial config
    initCfg = {}
    initCfg['duration'] = 2.5*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    #initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'rate')] = 10.0
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['EEGain'] = 0.5 
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    initCfg[('ratesLong', 'TPO', 1)] = 5 	
    initCfg[('ratesLong', 'TVL', 1)] = 2.5
    initCfg[('ratesLong', 'S1', 1)] = 5
    initCfg[('ratesLong', 'S2', 1)] = 5 
    initCfg[('ratesLong', 'cM1', 1)] = 2.5
    initCfg[('ratesLong', 'M2', 1)] = 2.5
    initCfg[('ratesLong', 'OC', 1)] = 5	

    # # L2/3+4
    initCfg[('IEweights',0)] =  0.8
    initCfg[('IIweights',0)] =  1.2 
    # L5
    initCfg[('IEweights',1)] = 0.8   
    initCfg[('IIweights',1)] = 1.0
    # L6
    initCfg[('IEweights',2)] =  1.0  
    initCfg[('IIweights',2)] =  1.0

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

    b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

    return b

# ----------------------------------------------------------------------------------------------
# Simultaenous long-range pop stimulations
# ----------------------------------------------------------------------------------------------
def simultLongPopStims():
    params = specs.ODict()
    
    params[('pulse', 'pop')] = ['TPO', 'M2', 'TVL', 'S2', 'S2', 'M2']
    params[('pulse2', 'pop')] = ['M2', 'TPO', 'S2', 'TVL', 'M2', 'S2']
    params[('pulse2', 'start')] = list(np.arange(1000, 1220, 20))
    params['ihGbar'] = [0.25, 1.0]


    # initial config
    initCfg = {}
    initCfg['duration'] = 2.0*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    #initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'rate')] = 10.0
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    #initCfg[('pulse2', 'start')] = 1500.0
    initCfg[('pulse2', 'rate')] = 10.0
    initCfg[('pulse2', 'duration')] = 100.0
    initCfg[('pulse2', 'noise')] = 0.8


    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['EEGain'] = 0.5 
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    initCfg[('ratesLong', 'TPO', 1)] = 5 	
    initCfg[('ratesLong', 'TVL', 1)] = 2.5
    initCfg[('ratesLong', 'S1', 1)] = 5
    initCfg[('ratesLong', 'S2', 1)] = 5 
    initCfg[('ratesLong', 'cM1', 1)] = 2.5
    initCfg[('ratesLong', 'M2', 1)] = 2.5
    initCfg[('ratesLong', 'OC', 1)] = 5	

    # # L2/3+4
    initCfg[('IEweights',0)] =  0.8
    initCfg[('IIweights',0)] =  1.2 
    # L5
    initCfg[('IEweights',1)] = 0.8   
    initCfg[('IIweights',1)] = 1.0
    # L6
    initCfg[('IEweights',2)] =  1.0  
    initCfg[('IIweights',2)] =  1.0

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    groupedParams = [('pulse', 'pop'),('pulse2', 'pop')] 
    b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

    return b

** v54_batch3 - simult input (no data)
not sure if ran on comet or gcp, but there's no data; so maybe didn't run


   params = specs.ODict()
    
    params[('pulse', 'pop')] = ['TPO', 'M2', 'TVL', 'S2', 'S2', 'M2']
    params[('pulse2', 'pop')] = ['M2', 'TPO', 'S2', 'TVL', 'M2', 'S2']
    params[('pulse2', 'start')] = list(np.arange(1000, 1220, 20))
    params['ihGbar'] = [0.25, 1.0]


    # initial config
    initCfg = {}
    initCfg['duration'] = 2.0*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    #initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'rate')] = 10.0
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    #initCfg[('pulse2', 'start')] = 1500.0
    initCfg[('pulse2', 'rate')] = 10.0
    initCfg[('pulse2', 'duration')] = 100.0
    initCfg[('pulse2', 'noise')] = 0.8


    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['EEGain'] = 0.5 
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    initCfg[('ratesLong', 'TPO', 1)] = 5 	
    initCfg[('ratesLong', 'TVL', 1)] = 2.5
    initCfg[('ratesLong', 'S1', 1)] = 5
    initCfg[('ratesLong', 'S2', 1)] = 5 
    initCfg[('ratesLong', 'cM1', 1)] = 2.5
    initCfg[('ratesLong', 'M2', 1)] = 2.5
    initCfg[('ratesLong', 'OC', 1)] = 5	

    # # L2/3+4
    initCfg[('IEweights',0)] =  0.8
    initCfg[('IIweights',0)] =  1.2 
    # L5
    initCfg[('IEweights',1)] = 0.8   
    initCfg[('IIweights',1)] = 1.0
    # L6
    initCfg[('IEweights',2)] =  1.0  
    initCfg[('IIweights',2)] =  1.0

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    groupedParams = [('pulse', 'pop'),('pulse2', 'pop')] 
    b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

    return b


** v54_batch4 - long dur 51 sec, seeds (comet) (no data)
- sims didnt complete
    params = specs.ODict()
    
    params['ihGbar'] = [0.25, 1.0] # [0.2, 0.25, 0.3, 1.0]
    params[('seeds', 'conn')] = [4321+(17*i) for i in range(5)]
    params[('seeds', 'stim')] = [1234+(17*i) for i in range(5)]

    params[('pulse', 'pop')] = ['None'] #, 'TPO', 'TVL', 'S2', 'M2'] #, 'OC'] # 'S1','cM1',
    #params[('pulse', 'end')] = [1100, 1500]

    groupedParams = []

    # initial config
    initCfg = {}
    initCfg['duration'] = 51*1e3 #2.5*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    #initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'rate')] = 10.0
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['EEGain'] = 0.5 
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    initCfg[('ratesLong', 'TPO', 1)] = 5 	
    initCfg[('ratesLong', 'TVL', 1)] = 2.5
    initCfg[('ratesLong', 'S1', 1)] = 5
    initCfg[('ratesLong', 'S2', 1)] = 5 
    initCfg[('ratesLong', 'cM1', 1)] = 2.5
    initCfg[('ratesLong', 'M2', 1)] = 2.5
    initCfg[('ratesLong', 'OC', 1)] = 5	

    # # L2/3+4
    initCfg[('IEweights',0)] =  0.8
    initCfg[('IIweights',0)] =  1.2 
    # L5
    initCfg[('IEweights',1)] = 0.8   
    initCfg[('IIweights',1)] = 1.0
    # L6
    initCfg[('IEweights',2)] =  1.0  
    initCfg[('IIweights',2)] =  1.0

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    groupedParams = [] #('IEweights',0), ('IIweights',0), ('IEweights',1), ('IIweights',1), ('IEweights',2), ('IIweights',2)]

    b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

    return b


** v54_batch5 - NetPyNE v0.9.1.1 evol optim full net (comet) (no data)
- looks like some error in gen_0 (empty files)

def evolRates():
	# --------------------------------------------------------
	# parameters
	params = specs.ODict()

	# long-range inputs
	params[('ratesLong', 'TPO', 1)] = [2, 5] 	#[2,4,2,2,4,2,4,4]
	params[('ratesLong', 'TVL', 1)] = [2, 5] #[2,4,2,2,4,2,4,4]
	#params[('ratesLong', 'S1', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
	params[('ratesLong', 'S2', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
	#params[('ratesLong', 'cM1', 1)] =  [2, 5] 
    params[('ratesLong', 'M2', 1)] =  [2, 5] #[2,2,2,4,2,4,4,4]
	params[('ratesLong', 'OC', 1)] =  [2, 5]	

	# EEgain
	params['EEGain'] = [0.5, 1.0] 

	# IEgain
	## L2/3+4
	params[('IEweights',0)] =  [0.8, 1.2]
	## L5
	params[('IEweights',1)] = [0.8, 1.2] #[0.8, 1.0]   
	## L6
	params[('IEweights',2)] =  [0.8, 1.2] # [0.8, 1.0]  

	# IIGain
	params['IIGain'] = [0.8, 1.2]
	
	# ih - remove
	#params['ihGbar'] = [0.1, 0.3] #[0.2, 0.25, 0.3, 1.0] 

	groupedParams = []

	# --------------------------------------------------------
	# initial config
	initCfg = {}
	initCfg['duration'] = 1.5*1e3
	initCfg['ihModel'] = 'migliore'  # ih model

	initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
	initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
	initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
	initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
	initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
	initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

	initCfg['somaNa'] = 5.0  # somatic Na conduct
	initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
	initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
	initCfg['axonRa'] = 0.005
	initCfg['gpas'] = 0.5
	initCfg['epas'] = 0.9

	initCfg[('pulse', 'pop')] = 'None'
	initCfg[('pulse', 'start')] = 1000.0
	initCfg[('pulse', 'end')] = 1100.0
	initCfg[('pulse', 'noise')] = 0.8

	initCfg['IEdisynapticBias'] = None

	initCfg['weightNormThreshold'] = 4.0
	initCfg['IEGain'] = 1.0
	initCfg['IPTGain'] = 1.0
	initCfg['IIweights'] =  [1.0, 1.0, 1.0]

	initCfg['saveCellSecs'] = False
	initCfg['saveCellConns'] = False


	# --------------------------------------------------------
	# fitness function
	fitnessFuncArgs = {}
		
	## complex net
	pops = {} 
	Etune = {'target': 10, 'width': 5, 'min': 0.4}
	pops['IT2'] = Etune
	pops['IT4'] = Etune
	pops['IT5A'] = Etune 
	pops['IT5B'] = Etune  
	pops['PT5B'] = Etune 
	pops['IT6'] =  Etune
	pops['CT6'] =  Etune

	Itune = {'target': 20, 'width': 15, 'min': 0.4}
	pops['PV2'] = Itune
	pops['SOM2'] = Itune
	pops['PV5A'] = Itune
	pops['SOM5A'] = Itune
	pops['PV5B'] = Itune
	pops['SOM5B'] = Itune
	pops['PV6'] = Itune
	pops['SOM6'] = Itune
	
	fitnessFuncArgs['pops'] = pops
	fitnessFuncArgs['maxFitness'] = 1000


	def fitnessFunc(simData, **kwargs):
		import numpy as np
		pops = kwargs['pops']
		maxFitness = kwargs['maxFitness']
		popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
				if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.iteritems()]
		fitness = np.mean(popFitness)

		popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
		print('  '+popInfo)
		return fitness
	
	#from IPython import embed; embed()

	b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

	# Set evol alg configuration
	b.evolCfg = {
		'evolAlgorithm': 'krichmarCustom',
		'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
		'fitnessFuncArgs': fitnessFuncArgs,
		'pop_size': 25,
		'num_elites': 2,
		'mutation_rate': 0.4,
		'crossover': 0.5,
		'maximize': False, # maximize fitness function?
		'max_generations': 200,
		'time_sleep': 60*5, # (5 min) wait this time before checking again if sim is completed (for each generation)
		'maxiter_wait': 40, # (3h20) max number of times to check if sim is completed (for each generation)
		'defaultFitness': 1000, # set fitness value in case simulation time is over
		'scancelUser': 'salvadord'
	}


	return b 
** v54_batch6 - simult long 3 sec (start at 1500; duration 200ms; and more intervals) (comet)
- 400 sims
    params[('pulse', 'pop')] = ['TPO', 'M2', 'TVL', 'S2', 'S2', 'M2', 'TVL', 'TPO']
    params[('pulse2', 'pop')] = ['M2', 'TPO', 'S2', 'TVL', 'M2', 'S2', 'TPO', 'TVL']
    params[('pulse2', 'start')] = list(np.arange(1500, 2020, 20))
    params['ihGbar'] = [0.25, 1.0]


    # initial config
    initCfg = {}
    initCfg['duration'] = 3.0*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    #initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'rate')] = 10.0
    initCfg[('pulse', 'start')] = 1500.0
    initCfg[('pulse', 'end')] = 1700.0
    initCfg[('pulse', 'noise')] = 0.8

    #initCfg[('pulse2', 'start')] = 1500.0
    initCfg[('pulse2', 'rate')] = 10.0
    initCfg[('pulse2', 'duration')] = 200.0
    initCfg[('pulse2', 'noise')] = 0.8


    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['EEGain'] = 0.5 
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    initCfg[('ratesLong', 'TPO', 1)] = 5 	
    initCfg[('ratesLong', 'TVL', 1)] = 2.5
    initCfg[('ratesLong', 'S1', 1)] = 5
    initCfg[('ratesLong', 'S2', 1)] = 5 
    initCfg[('ratesLong', 'cM1', 1)] = 2.5
    initCfg[('ratesLong', 'M2', 1)] = 2.5
    initCfg[('ratesLong', 'OC', 1)] = 5	

    # # L2/3+4
    initCfg[('IEweights',0)] =  0.8
    initCfg[('IIweights',0)] =  1.2 
    # L5
    initCfg[('IEweights',1)] = 0.8   
    initCfg[('IIweights',1)] = 1.0
    # L6
    initCfg[('IEweights',2)] =  1.0  
    initCfg[('IIweights',2)] =  1.0

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

    groupedParams = [('pulse', 'pop'),('pulse2', 'pop')] 
    b = Batch(params=params, initCfg=initCfg, groupedParams=groupedParams)

    return b
** v54_batch7 - test reproducibility on diff num cores with netpyne v0.9.3 and py3 (GCP - 32 cores)
- also useful to compare seed 0,0 with v54_batch1 and v53_batch13

** v54_batch8 - test reproducibility on diff num cores with netpyne v0.9.3 and py3 (GCP - 64 cores)
- also useful to compare seed 0,0 with v54_batch1 and v53_batch13

** v54_batch9 - test reproducibility on diff num cores with netpyne v0.9.3 and py3 (GCP - 128 cores)
- also useful to compare seed 0,0 with v54_batch1 and v53_batch13


** v53_manualTune  - plotting conn matrix for paper 
- tried initially with netpyne v0.7.8 but then moved to latest netpyne (>v0.9.1) and py3

tune7:
- hg clone m1 m1_temp (on 'zn')
- set m1 changeset v45_batch13 
- set netpyne changeset "aed422c"
-- zn% cd sim
-- zn% git clone https://github.com/Neurosim-lab/netpyne.git netpyne_repo

- set saveCellConns = True
- change init.py to sim.create(), sim.gatherData(), sim.plotData()
- add plotConn to init:
	allpops = ['IT2','PV2','SOM2','IT4','IT5A','PV5A','SOM5A','IT5B','PT5B','PV5B','SOM5B','IT6','CT6','PV6','SOM6']
	initCfg[('analysis', 'plotConn')] = {'includePre': allpops,
										'includePost': allpops,
										'feature': 'probability',
										'figSize': (10,10),
										'groupBy': 'pop',
 										'graphType': 'matrix',
 										'synOrConn': 'conn',
 										'synMech': None,
 										'saveData': None,
 										'saveFig': 1,
 										'showFig': 0}

In [6]: sim.analysis.plotConn(**{'includePre': allpops,
   ...:                             'includePost': allpops,
   ...:                             'feature': 'strength',
   ...:                             'figSize': (10,10),
   ...:                             'groupBy': 'pop',
   ...:                             'graphType': 'matrix',
   ...:                             'synOrConn': 'conn',
   ...:                             'synMech': None,
   ...:                             'saveData': None,
   ...:                             'saveFig': 1,
   ...:                             'showFig': 0, 'saveFigData':1})
There was an exception in plotConn():
 plotConn() got an unexpected keyword argument 'saveFigData'
Out[6]: -1

In [7]: sim.analysis.plotConn(**{'includePre': allpops,
   ...:                             'includePost': allpops,
   ...:                             'feature': 'strength',
   ...:                             'figSize': (10,10),
   ...:                             'groupBy': 'pop',
   ...:                             'graphType': 'matrix',
   ...:                             'synOrConn': 'conn',
   ...:                             'synMech': None,
   ...:                             'saveData': None,
   ...:                             'saveFig': 1,
   ...:                             'showFig': 0, 'saveData':1})
Plotting connectivity matrix...
Saving figure data as ../data/v53_manualTune/v53_tune7_conn.pkl ...
Out[7]: <Figure size 1000x1000 with 2 Axes>

In [8]: sim.analysis.plotConn(**{'includePre': allpops,
   ...:                             'includePost': allpops,
   ...:                             'feature': 'strength',
   ...:                             'figSize': (10,10),
   ...:                             'groupBy': 'pop',
   ...:                             'graphType': 'matrix',
   ...:                             'synOrConn': 'syn', 
   ...:                             'synMech': 'AMPA',
   ...:                             'saveData': None,
   ...:                             'saveFig': 1,
   ...:                             'showFig': 0, 'saveData':1})    

In [9]: sim.analysis.plotConn(**{'includePre': ['PV2', 'PV5A','PV5B','PV6'],
   ...:                             'includePost': allpops,
   ...:                             'feature': 'strength',
   ...:                             'figSize': (10,10),
   ...:                             'groupBy': 'pop',
   ...:                             'graphType': 'matrix',
   ...:                             'synOrConn': 'syn',
   ...:                             'synMech': 'GABAA',
   ...:                             'saveData': None,
   ...:                             'saveFig': 1,
   ...:                             'showFig': 0, 'saveData':1})  


In [10]: sim.analysis.plotConn(**{'includePre': ['SOM2', 'SOM5A','SOM5B','SOM6'],
    ...:                             'includePost': allpops,
    ...:                             'feature': 'strength',
    ...:                             'figSize': (10,10),
    ...:                             'groupBy': 'pop',
    ...:                             'graphType': 'matrix',
    ...:                             'synOrConn': 'syn',
    ...:                             'synMech': 'GABAASlow',
    ...:                             'saveData': None,
    ...:                             'saveFig': 1,
    ...:                             'showFig': 0, 'saveData':1})

In [11]: sim.analysis.plotConn(**{'includePre': allpops,
                                 'includePost': allpops,
                                 'feature': 'probability',
                                 'figSize': (10,10),
                                 'groupBy': 'pop',
                                 'graphType': 'matrix',
                                 'synOrConn': 'conn',
                                 'synMech': None,
                                 'saveData': None,
                                 'saveFig': '../data/v53_manualTune/v53_tune7_conn_probability_all_py3.png',
                                 'showFig': 0,
                                 'saveData':'../data/v53_manualTune/v53_tune7_conn_probability_all_py3.pkl'})

In [14]: sim.analysis.plotConn(**{'includePre': allpops,
                                 'includePost': allpops,
                                 'feature': 'strength',
                                 'figSize': (10,10),
                                 'groupBy': 'pop',
                                 'graphType': 'matrix',
                                 'synOrConn': 'syn',
                                 'synMech': 'NMDA',
                                 'saveFig': '../data/v53_manualTune/v53_tune7_syn_NMDA_strength_all.png',
                                 'showFig': 0, 
                                 'saveData':'../data/v53_manualTune/v53_tune7_syn_NMDA_strength_all.pkl'})


-- Running on GCP with py3 and latest netpyne:
Note: not clear if results are same since here have slightly more conns and syns (orig conns: 8798358; orig syns: 35870723)
Creating network of 22 cell populations on 1 hosts...
  Number of cells on node 0: 17073 
  Done; cell creation time = 304.70 s.
Making connections...
  Distributing synapses based on subcellular connectivity rules...
  Number of connections on node 0: 8803426 
  Number of synaptic contacts on node 0: 35930974 
  Done; cell connection time = 10404.11 s.

sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='probability', figSize=(10,10), groupBy='pop', graphType='matrix', synOrConn='conn',saveFig='../data/v53_manualTune/v53_tune7_conn_probability_all_py3.png', saveData='../data/v53_manualTune/v53_tune7_conn_probability_all_py3.pkl')


-- Running on zn with py3:

n [3]: sim.analysis.plotConn(includePre=allpops, includePost=allpops, feature='weight', figSize=(10,10), groupBy='pop', graphType='matrix', synOrConn='conn', removeWeightNorm=1, saveFig='../data/v53_manualTune/v53_tune7_conn_weight_not_norm_all_py3.png', saveData='../data/v53_manualTune/v53_tune7_conn_not_norm_all_py3.pkl')

Plotting connectivity matrix...
There was an exception in plotConn(): 
 name 'plt' is not defined 
(<class 'NameError'>, NameError("name 'plt' is not defined",), <traceback object at 0x7f96f7a3fec8>)

to do:
-- multiple syns= [AMPA, NMDA]
-- full single cell matrix
-- by cortical depth (weight, prob, strength)
-- generate net with PT synsPerConn=1

- ssh connection interrupted due to reset; would need to rerun to complete plots; probably not vital for now (paper)

** v55_batch1 - weightNorm VIP cells
def weightNorm(pops=['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6', 'PV2', 'SOM2'], 
    segs = None, allSegs = True, rule = 'IT2_reduced', weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg_cell import cfg
    from netParams_cell import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    initCfg = {}
    initCfg['duration'] = 1.0*1e3
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    initCfg['weightNorm'] = False
    initCfg['stimSubConn'] = False
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 1.0]

    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    #initCfg[('GroupNetStimW1', 'pop')] = 'None'
    initCfg[('NetStim1', 'delay')] = 1
    initCfg['addIClamp'] = 0
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)

    return b


    b = weightNorm(pops=['VIP2'], rule='VIP_reduced')

** v55_batch2 - weightNorm NGF cells  
def weightNorm(pops=['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6', 'PV2', 'SOM2'], 
    segs = None, allSegs = True, rule = 'IT2_reduced', weights=list(np.arange(0.01, 0.2, 0.01)/100.0)):

    # Add params
    from cfg_cell import cfg
    from netParams_cell import netParams

    excludeSegs = ['axon']
    if not segs:
        secs = []
        locs = []
        for secName,sec in netParams.cellParams[rule]['secs'].items():
            if secName not in excludeSegs:
                if allSegs:
                    nseg = sec['geom']['nseg']
                    for iseg in range(nseg):
                        secs.append(secName) 
                        locs.append((iseg+1)*(1.0/(nseg+1)))
                else:
                    secs.append(secName) 
                    locs.append(0.5)

    params = specs.ODict()
    params[('NetStim1', 'pop')] = pops
    params[('NetStim1', 'sec')] = secs
    params[('NetStim1', 'loc')] = locs
    params[('NetStim1', 'weight')] = weights

    groupedParams = [('NetStim1', 'sec'), ('NetStim1', 'loc')] 

    initCfg = {}
    initCfg['duration'] = 1.0*1e3
    initCfg[('analysis','plotTraces','timeRange')] = [0, 1000]
    initCfg['weightNorm'] = False
    initCfg['stimSubConn'] = False
    initCfg['addNetStim'] = True
    initCfg[('NetStim1', 'synMech')] = ['AMPA','NMDA']
    initCfg[('NetStim1','synMechWeightFactor')] = [0.5,0.5]
    initCfg[('NetStim1', 'start')] = 700
    initCfg[('NetStim1', 'interval')] = 1000
    initCfg[('NetStim1','ynorm')] = [0.0, 1.0]

    initCfg[('NetStim1', 'noise')] = 0
    initCfg[('NetStim1', 'number')] = 1
    initCfg[('NetStim1', 'delay')] = 1
    #initCfg[('GroupNetStimW1', 'pop')] = 'None'
    initCfg[('NetStim1', 'delay')] = 1
    initCfg['addIClamp'] = 0
    
    b = Batch(params=params, netParamsFile='netParams_cell.py', cfgFile='cfg_cell.py', initCfg=initCfg, groupedParams=groupedParams)

    return b


    b = weightNorm(pops=['NGF1'], rule='NGF_simple')

** v55_batch3 - Evol optim test (0.25 cell density)
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # long-range inputs
    params[('ratesLong', 'TPO', 1)] = [2, 5] 	#[2,4,2,2,4,2,4,4]
    params[('ratesLong', 'TVL', 1)] = [2, 5] #[2,4,2,2,4,2,4,4]
    #params[('ratesLong', 'S1', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
    params[('ratesLong', 'S2', 1)] =  [2, 5] 	#[2,2,4,2,4,4,2,4]
    #params[('ratesLong', 'cM1', 1)] =  [2, 5] 
    params[('ratesLong', 'M2', 1)] =  [2, 5] #[2,2,2,4,2,4,4,4]
    params[('ratesLong', 'OC', 1)] =  [2, 5]	

    # EEgain
    params['EEGain'] = [0.5, 1.0] 

    # IEgain
    ## L2/3+4
    params[('IEweights',0)] =  [0.8, 1.2]
    ## L5
    params[('IEweights',1)] = [0.8, 1.2] #[0.8, 1.0]   
    ## L6
    params[('IEweights',2)] =  [0.8, 1.2] # [0.8, 1.0]  

    # IIGain
    params['IIGain'] = [0.8, 1.2]
    
    # ih - remove
    #params['ihGbar'] = [0.1, 0.3] #[0.2, 0.25, 0.3, 1.0] 

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 1.5*1e3
    initCfg['ihModel'] = 'migliore'  # ih model

    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9

    initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['IEGain'] = 1.0
    initCfg['IPTGain'] = 1.0
    initCfg['IIweights'] =  [1.0, 1.0, 1.0]

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
        
    ## complex net
    pops = {} 
    Etune = {'target': 10, 'width': 5, 'min': 0.5}
    pops['IT2'] = Etune
    pops['IT4'] = Etune
    pops['IT5A'] = Etune 
    pops['IT5B'] = Etune  
    pops['PT5B'] = Etune 
    pops['IT6'] =  Etune
    pops['CT6'] = Etune
    
    

    Itune = {'target': 20, 'width': 15, 'min': 0.25}
    pops['PV2'] = Itune
    pops['SOM2'] = Itune
    pops['PV5A'] = Itune
    pops['SOM5A'] = Itune
    pops['PV5B'] = Itune
    pops['SOM5B'] = Itune
    pops['PV6'] = Itune
    pops['SOM6'] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 30,
        'num_elites': 2,
        'mutation_rate': 0.4,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 12, # (1h) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'salvadord'
    }


*** results
#gen  pop-size  worst  best  median  average  std-deviation
0, 30, 201.98021058767057, 68.89765595554316, 201.67866284888186, 168.63954372010224, 37.34606142646917
1, 30, 201.92610133577892, 68.89765595554316, 168.6290417939797, 164.1529688482078, 40.885144100566755
2, 30, 201.8508205976558, 68.89765595554316, 135.53032729266602, 150.8682505491377, 40.81947433011977
3, 30, 201.84345899693997, 68.89765595554316, 135.61090786473045, 144.29406717682437, 44.43908478628413
4, 30, 201.84393250657882, 68.89765595554316, 135.57235248446472, 144.29250756262599, 47.59911408156121
5, 30, 201.94607418175366, 68.89765595554316, 135.38107403330815, 142.03400631760437, 39.65425493123081
6, 30, 201.83526152679858, 68.89765595554316, 135.34517484836346, 137.5883748174813, 43.6176040467339
7, 30, 201.89799807990863, 68.87646545897452, 135.28460434197495, 139.76951063100526, 48.270567973850646
8, 30, 201.89180947861556, 68.87646545897452, 135.36655826211495, 146.44423064435497, 42.300275371570635
9, 30, 201.89948678180426, 68.87542112027609, 135.45766743373355, 144.23783673041606, 50.64634084685889
10, 30, 201.9041403904748, 68.87542112027609, 135.38355285968237, 139.82054794810946, 38.07635549524104
11, 30, 201.81148306885336, 68.84708195631627, 135.27294910608236, 133.13706676669466, 40.153754099864614
12, 30, 201.84366239164578, 68.84708195631627, 135.39360337511164, 144.2104773068412, 41.0346285892822
13, 30, 201.81654689822886, 68.84708195631627, 135.35683224156247, 137.59970003723504, 43.654810927712646
14, 30, 201.80509551088082, 68.83462850232556, 135.32283203370145, 133.1437756563719, 43.61055056472088
15, 30, 201.81073636851528, 68.83462850232556, 135.2012942732643, 122.09194532580793, 43.289207394528994
16, 30, 201.87251189770083, 68.83462850232556, 135.41303455530834, 144.21439736139135, 44.441167247856534
17, 30, 201.8866731272491, 68.83462850232556, 135.2622405437629, 133.14565171093503, 36.28058474570233
18, 30, 201.85063976187413, 68.83462850232556, 135.29375291197016, 137.54964284005794, 36.297505335012985
19, 30, 201.71821083313196, 68.83462850232556, 135.2967555068792, 126.52645419230028, 33.10488432117736
20, 30, 201.86924060959413, 68.83462850232556, 135.49879554387783, 144.22685647549497, 44.47990613712675
21, 30, 201.87195662611546, 68.83462850232556, 135.24107061697748, 126.5156213674205, 44.448106219934374
22, 30, 201.760809229686, 68.83462850232556, 135.29821098080896, 126.55161110980508, 37.24003305220777
23, 30, 201.87003365790665, 68.83462850232556, 135.4289484884498, 142.0123581787253, 39.66532227920937
24, 30, 201.92746939311556, 68.83462850232556, 135.43712108853964, 137.60197436356668, 40.16810764901374
25, 30, 201.92303837544287, 68.83462850232556, 135.55521154331385, 155.303762720638, 42.55983793209071
26, 30, 201.84454973676375, 68.83462850232556, 135.5102833194162, 146.44443523883083, 45.594045538790006
27, 30, 201.8321073727975, 68.83462850232556, 135.55234837672796, 146.46182552239196, 42.278453833715595
28, 30, 201.79279147699143, 68.83462850232556, 135.24342688116795, 135.33230915631307, 41.952700906973746
29, 30, 201.8539884757405, 68.83462850232556, 135.47864311981112, 144.23764169831665, 33.12948996415849
30, 30, 201.88421991879596, 68.83462850232556, 135.50011602992376, 146.43571268503686, 38.6515924248224
31, 30, 201.97749427980705, 68.83462850232556, 135.61624954360036, 157.5336405321859, 46.42105839021391
32, 30, 201.83822266998655, 68.83462850232556, 135.44949239777935, 150.83664669009923, 40.83870811175713
33, 30, 201.9244217364884, 68.83462850232556, 135.37648451039632, 141.9859542393485, 43.21060791300197
34, 30, 201.72711511198835, 68.83462850232556, 135.32163425540836, 137.55360436593637, 40.096756127591846
35, 30, 201.71722674428358, 68.83462850232556, 135.28989300559374, 130.89337206316043, 41.750959597993514
36, 30, 201.79722730181126, 68.83462850232556, 135.20902276451653, 137.48927442953658, 36.312537697520284
37, 30, 201.7882222647798, 68.83462850232556, 135.31910471689832, 144.13440125138285, 41.05442940626206
38, 30, 201.85465885328645, 68.82197973772665, 135.3854516237702, 146.38387701581783, 42.290077685300496
39, 30, 201.85059501483096, 68.82197973772665, 135.4682078166969, 142.00030978097092, 43.18188005902391
40, 30, 201.8741962790759, 68.82197973772665, 135.37953295843334, 130.99434161969785, 41.75878146537098


** v100_batch1 - Full evol; dt=0.025
*** datetime error

>>> Traceback (most recent call last):
  File "/usr/local/lib64/python3.6/site-packages/numpy/core/__init__.py", line 17, in <module>
    from . import multiarray
  File "/usr/local/lib64/python3.6/site-packages/numpy/core/multiarray.py", line 14, in <module>
    from . import overrides
  File "/usr/local/lib64/python3.6/site-packages/numpy/core/overrides.py", line 7, in <module>
    from numpy.core._multiarray_umath import (
ImportError: PyCapsule_Import could not import module "datetime"

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "init.py", line 15, in <module>
    import matplotlib; matplotlib.use('Agg')  # to avoid graphics error in servers
  File "/usr/local/lib64/python3.6/site-packages/matplotlib/__init__.py", line 138, in <module>
    from . import cbook, rcsetup
  File "/usr/local/lib64/python3.6/site-packages/matplotlib/cbook/__init__.py", line 31, in <module>
    import numpy as np
  File "/usr/local/lib64/python3.6/site-packages/numpy/__init__.py", line 142, in <module>
    from . import core
  File "/usr/local/lib64/python3.6/site-packages/numpy/core/__init__.py", line 47, in <module>
    raise ImportError(msg)
ImportError: 

IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!

Importing the numpy c-extensions failed.
- Try uninstalling and reinstalling numpy.
- If you have already done that, then:
  1. Check that you expected to use Python3.6 from "/usr/bin/python3",
     and that you have no directories in your PATH or PYTHONPATH that can
     interfere with the Python and numpy version "1.17.2" you're trying to use.
  2. If (1) looks fine, you can open a new issue at
     https://github.com/numpy/numpy/issues.  Please include details on:
     - how you installed Python
     - how you installed numpy
     - your operating system
     - whether or not you have multiple versions of Python installed
     - if you built from source, your compiler versions and ideally a build log

- If you're working with a numpy git repository, try `git clean -xdf`
  (removes all files not under version control) and rebuild numpy.

Note: this error has many possible causes, so please don't comment on
an existing issue about this - open a new one instead.

Original error was: PyCapsule_Import could not import module "datetime"
**** fix by exports (added to bashrc)
export OMP_NUM_THREADS=1
export USE_SIMPLE_THREADED_LEVEL3=1 
*** error calculating fitness func
- missing NGF1 cells (denisty was 0)
- error when no spikes
*** testing first with diam = 100 um to ensure fitness func works
*** bug in batch.py - initCfg not updated so duration = 1sec
*** results
- fixed bug so initCfg updated
- IT2, IT4 and all NGF pops never fire - check why

** v101_batch1 - Full evol; fixed initCfg; tuning long-range weights instead of rates (bug)
*** bug 
I->E only for HH_full cell model (missed most ITs)
I->I only for HH_simple cell model (missed VIPs)
*** changes
- added weightNorm of VIP and NGF cells
- changed from tuning long-range input rates to weights (for all 7 pops) in range [0.25, 0.75] (default 0.5)
- EE, EI, IE, II - changed range from [0.8,1.2] to [0.5, 1.5]
- added initCfg params
- recording cell traces (one per pop)
- pop size from 50 to 100
- num elites from 5 to 2
- mutation_rate from 0.4 to 0.5
*** results
analysis of evol optim params and firing rates reveals:
- parameters are approx uniformly sampled from space
- for each param there is no obvious region of values that lead to better fitness (param degeneracy)
- VIP cells fired in reasonable range in prev sim (withou weightNorm) but now are too high (>100 Hz); reason is likely that before they were in depol blockade so firing was not real
- IT2, IT4 and NGF cells not firing despite larger parameter space explored; and seems homogeneously 
-- NGF weightNorm is weird -- seems to generate a small spike 
-- check voltage traces of IT2, IT4 and NGF from last evol 
-- NGFs generate single spike at beginning and then very low depol -- increase wnorm / inputs?
-- IT2 and IT4 are in depol blockade!! 1st spike not showing cause avg calcualated from 500ms -- decrease wnorm / inputs?
** v101_batch2 - Plot conn of v010_batch1 network to find issues (bug)
- trying to plot conn to examine issues
- seg fault when gathering data
- running manually on 'zn'
*** bug 
I->E only for HH_full cell model (missed most ITs)
I->I only for HH_simple cell model (missed VIPs)
** v101_manualTune (bug)
*** tune2 - running 0.25 scale on macbook to explore connectivity
*** bug 
I->E only for HH_full cell model (missed most ITs)
I->I only for HH_simple cell model (missed VIPs)
** v101_batch3 - Test small param sweep (bug)
*** bug 
I->E only for HH_full cell model (missed most ITs)
I->I only for HH_simple cell model (missed VIPs)

*** changes
- reduce VIP weightNorm
- set params so IT2,IT4 as low as possible
*** params
    # long-range inputs
    params[('weightLong', 'TPO')] = [0.25] 
    params[('weightLong', 'TVL')] = [0.5] 
    params[('weightLong', 'S1')] =  [0.25] 
    params[('weightLong', 'S2')] =  [0.25] 
    params[('weightLong', 'cM1')] = [0.5] 
    params[('weightLong', 'M2')] =  [0.5] 
    params[('weightLong', 'OC')] =  [0.5]	

    # EEgain
    params['EEGain'] = [0.5] 

    # IEgain
    ## L2/3+4
    params[('IEweights',0)] =  [1.0, 1.5, 2.0]
    ## L5
    params[('IEweights',1)] = [1.0] #[0.8, 1.0]   
    ## L6
    params[('IEweights',2)] =  [1.0] # [0.8, 1.0]  

    # IIGain
    params['IIGain'] = [0.5]
** v102_batch1 - Testing single sim after fixing I->E/I bugs; baseline for evol
*** params
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # long-range inputs
    params[('weightLong', 'TPO')] = [0.25, 0.75] 
    params[('weightLong', 'TVL')] = [0.25, 0.75] 
    params[('weightLong', 'S1')] =  [0.25, 0.75] 
    params[('weightLong', 'S2')] =  [0.25, 0.75] 
    params[('weightLong', 'cM1')] = [0.25, 0.75] 
    params[('weightLong', 'M2')] =  [0.25, 0.75] 
    params[('weightLong', 'OC')] =  [0.25, 0.75]	

    # EEgain
    params['EEGain'] = [0.5, 1.5] 

    # IEgain
    ## L2/3+4
    params[('IEweights',0)] =  [0.5, 1.5]
    ## L5
    params[('IEweights',1)] = [0.5, 1.5] #[0.8, 1.0]   
    ## L6
    params[('IEweights',2)] =  [0.5, 1.5] # [0.8, 1.0]  

    # IIGain
    params['IIGain'] = [0.5, 1.5]
    
    # ih - remove
    #params['ihGbar'] = [0.1, 0.3] #[0.2, 0.2, 0.8 1.0] 

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.025

    initCfg['scaleDensity'] = 1.0

    # cell params
    initCfg['ihGbar'] = 0.75  # ih (for quiet/sponti condition)
    initCfg['ihModel'] = 'migliore'  # ih model
    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9
    
    # long-range input params
    initCfg['numCellsLong'] = 1000
    initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    # conn params
    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['IEGain'] = 1.0
    initCfg['IPTGain'] = 1.0
    initCfg['IIweights'] = [1.0, 1.0, 1.0]

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis','plotTraces','timeRange')] = initCfg['printPopAvgRates']

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False

** v102_batch2 - short evol
*** results
- ok except NGF and VIP not firing
** v102_manualTune 
*** tune2 
- full scale
- single NGF1 cell with bkg inputs - 120 Hz
- large inhib might come from conns from same pop - NGF1 inh
- check if depol block in sim?! -- no, high input all the way
*** tune2 (overwrote)
- full scale
- full pop of NGF1 with bkg inputs - to check if self inhib
- low rate of 2hz
*** tune3 test ngf4
- full scale
- ngf4 + bkg -> ngf4 35hz
** v102_batch3 - single full sim to test changes
*** changes
- EtoIprobFactorVIP = 0.5 -> 0.25
- EtoIprobFactorNGF = 0.5 -> 0.75
- I -> I (default) = 1.0 -> weak (0.35) (NGF -> rest, including NGF)
*** use default params
*** results
- some pops very high, many not spiking
** v102_batch4 - single gen evol to test param space
*** changes
EtoIprobFactorVIP = 1.0  # VIP was actually not spiking in last evol (v102_batch2)
EtoIprobFactorNGF = 1.0  # not spiking in last single sims (v102_batch3)
*** results
- 2 gens x 50 cands 
- all pops except NGF2, VIP4 and PV6 fire >0 Hz at least in a couple sims
- check with single sim without local conn, how bkg inputs drives each pop (locally?)
- submit new evol, including II by layer params to have larger param space; use 1 sec sims
** v103_batch1 - test just bkg with different weights for long conn

*** code
def custom():
    params = specs.ODict()
    # long-range inputs
    params[('weightLong', 'TPO')] = [0.25, 0.5, 0.75] 
    params[('weightLong', 'TVL')] = [0.25, 0.5, 0.75] 
    params[('weightLong', 'S1')] =  [0.25, 0.5, 0.75] 
    params[('weightLong', 'S2')] =  [0.25, 0.5, 0.75] 
    params[('weightLong', 'cM1')] = [0.25, 0.5, 0.75] 
    params[('weightLong', 'M2')] =  [0.25, 0.5, 0.75] 
    params[('weightLong', 'OC')] =  [0.25, 0.5, 0.75]	

    # EEgain
    params['EEGain'] = [1.0] 

    # IEgain
    ## L2/3+4
    params[('IEweights',0)] =  [1.0]
    ## L5
    params[('IEweights',1)] = [1.0] #[0.8, 1.0]   
    ## L6
    params[('IEweights',2)] =  [1.0] # [0.8, 1.0]  

    # IIGain
    params['IIGain'] = [1.0]


    groupedParams = [('weightLong', 'TPO'), 
                    ('weightLong', 'TVL'), 
                    ('weightLong', 'S1'), 
                    ('weightLong', 'S2'), 
                    ('weightLong', 'cM1'), 
                    ('weightLong', 'M2'), 
                    ('weightLong', 'OC')] 
    
    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 1000
    initCfg['printPopAvgRates'] = [500, 1000] 
    initCfg['dt'] = 0.025

    initCfg['scaleDensity'] = 1.0

    # cell params
    initCfg['ihGbar'] = 0.75  # ih (for quiet/sponti condition)
    initCfg['ihModel'] = 'migliore'  # ih model
    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9
    
    # long-range input params
    initCfg['numCellsLong'] = 1000
    initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    # conn params
    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['IEGain'] = 1.0
    initCfg['IPTGain'] = 1.0
    initCfg['IIweights'] = [1.0, 1.0, 1.0]

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis', 'plotTraces', 'timeRange')] = initCfg['printPopAvgRates']
    
    initCfg[('analysis', 'plotTraces', 'oneFigPer')] = 'trace'

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    b = Batch(params=params, netParamsFile='netParams.py', cfgFile='cfg.py', initCfg=initCfg, groupedParams=groupedParams)

    return b
*** results
- all pops spiking at 3 levels except NGF
- bkg weight has significant effect on rate; middle value looks reasonable
- NGF not receiving bkg? or too low??
-- receiving bkg but seems like weights too low
-- increased weightNorm x2 -> 2-10hz spiking; x4 -> 4-15Hz
** v103_batch2 - Evol optim after adjusting params
*** changes compared with prev evol
- EtoIprobFactorVIP = 1.0  # VIP was actually not spiking in last evol (v102_batch2)
- EtoIprobFactorNGF = 1.0  # not spiking in last single sims (v102_batch3)
- I -> I (default) = 1.0 -> weak (0.35) (NGF -> rest, including NGF)
- after v103_batch1 - increased weightNorm x4

- added IIweights to increase param space
- increased pop to 100 
*** code
def evolRates():
    # --------------------------------------------------------
    # parameters
    params = specs.ODict()

    # long-range inputs
    params[('weightLong', 'TPO')] = [0.25, 0.75] 
    params[('weightLong', 'TVL')] = [0.25, 0.75] 
    params[('weightLong', 'S1')] =  [0.25, 0.75] 
    params[('weightLong', 'S2')] =  [0.25, 0.75] 
    params[('weightLong', 'cM1')] = [0.25, 0.75] 
    params[('weightLong', 'M2')] =  [0.25, 0.75] 
    params[('weightLong', 'OC')] =  [0.25, 0.75]	

    # EEgain
    params['EEGain'] = [0.5, 1.5] 

    # IEgain
    ## L2/3+4
    params[('IEweights',0)] =  [0.5, 1.5]
    ## L5
    params[('IEweights',1)] = [0.5, 1.5] #[0.8, 1.0]   
    ## L6
    params[('IEweights',2)] =  [0.5, 1.5] # [0.8, 1.0]  

    # IIGain
    ## L2/3+4
    params[('IIweights',0)] =  [0.5, 1.5]
    ## L5
    params[('IIweights',1)] = [0.5, 1.5] #[0.8, 1.0]   
    ## L6
    params[('IIweights',2)] =  [0.5, 1.5] # [0.8, 1.0]  

    groupedParams = []

    # --------------------------------------------------------
    # initial config
    initCfg = {}
    initCfg['duration'] = 1500
    initCfg['printPopAvgRates'] = [500, 1500] 
    initCfg['dt'] = 0.025

    initCfg['scaleDensity'] = 1.0

    # cell params
    initCfg['ihGbar'] = 0.75  # ih (for quiet/sponti condition)
    initCfg['ihModel'] = 'migliore'  # ih model
    initCfg['ihGbarBasal'] = 1.0 # multiplicative factor for ih gbar in PT cells
    initCfg['ihlkc'] = 0.2 # ih leak param (used in Migliore)
    initCfg['ihLkcBasal'] = 1.0 # multiplicative factor for ih lk in PT cells
    initCfg['ihLkcBelowSoma'] = 0.01 # multiplicative factor for ih lk in PT cells
    initCfg['ihlke'] = -86  # ih leak param (used in Migliore)
    initCfg['ihSlope'] = 28  # ih leak param (used in Migliore)

    initCfg['somaNa'] = 5.0  # somatic Na conduct
    initCfg['dendNa'] = 0.3  # dendritic Na conduct (reduced to avoid dend spikes) 
    initCfg['axonNa'] = 7   # axon Na conduct (increased to compensate) 
    initCfg['axonRa'] = 0.005
    initCfg['gpas'] = 0.5
    initCfg['epas'] = 0.9
    
    # long-range input params
    initCfg['numCellsLong'] = 1000
    initCfg[('pulse', 'pop')] = 'None'
    initCfg[('pulse', 'start')] = 1000.0
    initCfg[('pulse', 'end')] = 1100.0
    initCfg[('pulse', 'noise')] = 0.8

    # conn params
    initCfg['IEdisynapticBias'] = None

    initCfg['weightNormThreshold'] = 4.0
    initCfg['IEGain'] = 1.0
    initCfg['IIGain'] = 1.0
    initCfg['IPTGain'] = 1.0

    # plotting and saving params
    initCfg[('analysis','plotRaster','timeRange')] = initCfg['printPopAvgRates']
    initCfg[('analysis','plotTraces','timeRange')] = initCfg['printPopAvgRates']

    initCfg['saveCellSecs'] = False
    initCfg['saveCellConns'] = False


    # --------------------------------------------------------
    # fitness function
    fitnessFuncArgs = {}
    pops = {}
    
    ## Exc pops
    Epops = ['IT2', 'IT4', 'IT5A', 'IT5B', 'PT5B', 'IT6', 'CT6']

    Etune = {'target': 5, 'width': 5, 'min': 0.5}
    for pop in Epops:
        pops[pop] = Etune
    
    ## Inh pops 
    Ipops = ['NGF1', 'PV2', 'SOM2', 'VIP2', 'NGF2',
            'PV4', 'SOM4', 'VIP4', 'NGF4',
            'PV5A', 'SOM5A','VIP5A','NGF5A',
            'PV5B', 'SOM5B','VIP5B','NGF5B',
            'PV6', 'SOM6', 'VIP6', 'NGF6']

    Itune = {'target': 10, 'width': 15, 'min': 0.25}
    for pop in Ipops:
        pops[pop] = Itune
    
    fitnessFuncArgs['pops'] = pops
    fitnessFuncArgs['maxFitness'] = 1000


    def fitnessFunc(simData, **kwargs):
        import numpy as np
        pops = kwargs['pops']
        maxFitness = kwargs['maxFitness']
        popFitness = [min(np.exp(abs(v['target'] - simData['popRates'][k])/v['width']), maxFitness) 
                if simData['popRates'][k] > v['min'] else maxFitness for k,v in pops.items()]
        fitness = np.mean(popFitness)

        popInfo = '; '.join(['%s rate=%.1f fit=%1.f'%(p, simData['popRates'][p], popFitness[i]) for i,p in enumerate(pops)])
        print('  '+popInfo)
        return fitness
    
    #from IPython import embed; embed()

    b = Batch(params=params, groupedParams=groupedParams, initCfg=initCfg)

    # Set evol alg configuration
    b.evolCfg = {
        'evolAlgorithm': 'custom',
        'fitnessFunc': fitnessFunc, # fitness expression (should read simData)
        'fitnessFuncArgs': fitnessFuncArgs,
        'pop_size': 100,
        'num_elites': 2,
        'mutation_rate': 0.5,
        'crossover': 0.5,
        'maximize': False, # maximize fitness function?
        'max_generations': 200,
        'time_sleep': 300, # 5min wait this time before checking again if sim is completed (for each generation)
        'maxiter_wait': 64, # (5h20) max number of times to check if sim is completed (for each generation)
        'defaultFitness': 1000, # set fitness value in case simulation time is over
        'scancelUser': 'ext_salvadordura_gmail_com'
    }


    return b
** v103_batch3 - Evol rerun with NGF only *= 1.5
*** results
68 generations, ~55 cands per gen, 3700 sims

* TODO PAPER 1
** DONE Methods: Add Ca, NMDA and Na spikes to dendrites (added Ca) (16nov20)
*** Chat between Ben and Bill
Ben:
2. At my poster (focus on CSTR) I got critical feedback regarding plans to model the two cell types: "but you don't have
   dendritic recordings". From a big name in the field. I do think that this is now becoming pretty standard, as far as an
   important experimental/modeling camp goes (Stuart, Kole, Spruston, Haeusser, Johnston, Larkum) who have used dendritic
   recordings to constrain L5 (and CA1?) models. Besides the trend, I do think this makes a lot of sense if we want to
   incorporate subcellular dendritic synapse locations. The currently accepted theory for L5 processing is that active
   dendritic processes are very important. bAPs and Calcium spikes and NMDA spikes and Na spikes in the dendrites. And pure
   somatic recordings do not constrain the densities and distributions of the associated ion channels, especially in apical
   arbor. So without dendritic recordings we *must* constrain / set those parameters based on published findings, and not
   leave them as free parameters. The question is, if those measurements were made in other cortical areas / species / cell
   types, are they relevant? Still, the only good argument I have against "you don't have dendritic recordings" is "but
   others do and we're using their findings". This is a good response, I think. But I'm not sure anyone has done those
   recordings in L5-IT (people do them in L5-PT because thick, long apical dendrite).

bAPs and Calcium spikes and NMDA spikes and Na spikes in the dendrites.

I implemented the sCRACM simulation using a model that did not have dendritic recordings and did not have a Ca hot spot, etc.
and that was okay because I specifically blocked NMDARs, Na channels and kept everything subthreshold in the experiments (and
the model).

But to take the next step, namely to run the resulting synaptic distributions in a model that has incorrect apical
membrane properties would be bad.
Bad = wrong conclusions, and disregarding the current state / quality threshold / scientific literature for models of these cells
I don't see the point in making all this effort to get the synaptic distributions right, if the synaptic membrane properties
are wrong.

I would say we are in many ways behind wrt to current state - we're ahead in some ways, and behind in others. Again, I'm
referring to the people who have dendritic recordings and have used these to get better models of the apical membranes for
L5. As long as we incorporate those findings, we are doing what we can (short of dendritic recordings). But if we don't do
that then we're ignoring established findings. We might get past reviewers in some journals, but not if they send it out to
any of those scientists for review.

*Now* I'm saying that before we take the next step, namely to study the effect of the dendritic location of synapses, we need
to bring our models up to speed with regards the dendritic membrane.

things like the Ca hotspot, NMDAR spikes, dendritic Na spikes - these are inherent to apical dendritic processing in L5-PT
neurons, so now that we want to do apical synaptic stuff and make it a major focus of the paper, I think these need to be
revisited. I've sent Salva a bunch of notes from when I developed the synaptic input model and sCRACM simulation, so maybe he
can share references from that as he reads through it?

Bill:
we had ca hotspots in our 1992 hpc paper -- Wathey JC, {\bf Lytton WW}, Jester JM, Sejnowski TJ (1992). Computer
simulations of EPSP-spike (E-S) potentiation in hippocampal CA1 pyramidal cells. {\em J Neurosci}. 12:607-18.

we can consider whether we can incorporate these without totally messing up the models
ie getting something that ends up with depol block or prolonged activation in dends
note that we are also doing sep dend sims for another grant
and will try to icorporate some of this as it moves forward
(assuming we can find a postdoc to do it!! -- a problem at prsent)
so this will have >Ca chans -- but focus is apical oblique and basal

but we also hae tuft data so would be great to do those sims too
yes very relevant to EEE grant so will be reading

Ben:
It was my understanding that Sam intends to use multiple reconstructions and multiple recordings to constrain the CSTR
optimization. And I thought the plan was to re-run this same approach for PT, by using multiple CSP reconstructions and
recordings. For the M1 model we need PTs and ITs at different yfracs, at least 3 (upper, middle, lower L5) - also so that the
IT/PT differences have the best chance of coming out!

it seemed to me that Sam had put quite some effort into automating / making the process systematic. Is re-running on new
experimental datasets a matter of computer time cost, or human time cost? Bill: both

Ben:
we are not planning to rerun PT at this time -- but if can slide it into other grant then would reconsider

Maybe Salvador could come over here for a visit, stay at IST guesthouse (cheap) and we could try to bang out the sCRACM
stuff.  It's not expensive ($500 from Chicago), but I know he's very busy with projects and grants. We always seem to make
good progress in person (aside from SfN this year where I was exhausted).

Shai, A. S., C. A. Anastassiou, M. E. Larkum, and C. Koch (2015, March). Physiology of layer 5 pyramidal neurons in mouse
primary visual cortex: Coincidence detection through bursting. PLOS Computational Biology 11 (3), e1004090+.

https://senselab.med.yale.edu/ModelDB/ShowModel.cshtml?model=180373

Mouse, visual cortex, L5 (PT looks like by eye), dendritic and somatic recordings. Model with synapses in basals and
apicals. Not sure how good, but worth a read.

So maybe Sam & Salva could look at this Shai paper and see whether they used the dendritic recordings to further constrain
the model beyond Hay, or whether Hay already had good dendritic constraints? (I think Hay did already, but am not sure)

Shai reused Hay, but possibly added new constraints. Hay is a nice modeling approach. I think maybe had dendritic recordings
too, I'll check.

"Based on a large body of experimental recordings from both the soma and dendrites of L5b pyramidal cells in adult rats, we
characterized key features of the somatic and dendritic firing and quantified their statistics. We used these features to
constrain the density of a set of ion channels over the soma and dendritic surface via multi-objective optimization with an
evolutionary algorithm, thus generating a set of detailed conductance-based models that faithfully replicate the
back-propagating action potential activated Ca2+ spike firing and the perisomatic firing response to current steps, as well
as the experimental variability of the properties."

But note that Hay was rat S1. And Shai is mouse V1. So worth looking at whether Shai made any adjustments to morph or
membrane to make it "mouse", or not ...

*** Chat Sam
strange, this paper (Physiology of Layer 5 Pyramidal Neurons in Mouse Primary Visual Cortex) mentions they kept Ih density
fixed in apical dends and increased low threshold ca channel density there too
VGCC density increased 100-fold in 200 mcron area around main bifurcation point - in hay 2011 paper

we have nexus @ ~300 microns - could put ca hot zone there but that's much closer than the 600-1000 micron distance mentioned
in hay paper

[2:07]
hay is using rat (not mouse)

[2:07]
"Previous experimental studies [7] indicate that the low threshold
zone for Ca2+ spikes in the apical dendrites might be located
somewhere between 600 and 1000 mm from the soma, roughly
from the main bifurcation to the end of the primary tuft. The main
bifurcation in the reconstructed   typical   L5b PC (see below) that
we used (Figure 1A) was 650 mm away from the soma and the
primary tuft ended around 950 mm away from the soma. CaLVA
and CaHVA were therefore distributed on the apical tree using a
step function, with increased conductance between 685 and
885 mm from the soma. This high density (  hot  ) Ca2+ zone had
100 and 10 times higher density of CaLVA and CaHVA than
anywhere else on the apical tree."

[2:08]
@ben.suter. - any comments for this requested feature?

salvadord [2:17 PM]
guess 300 microns makes sense for our cell — assuming key feature is start of bifurcation and not distance from soma

new messages
samn [2:18 PM]
ok, can put ca hot zone as +/- ~300 microns

[2:18]
as 300 +/- ~100 microns
why not just at bifurcation.  eg 10 mu?

samn [2:36 PM]
+/- 10 microns from the nexus?

[2:36]
or at every bifurcation? this ca hot zone is VGCC density

[2:36]
was basing on ~hay paper

salvadord [2:43 PM]
so on Hay they set hot zone between 685-885 micron right?

samn [2:43 PM]
y

[2:43]
rats

salvadord [2:43 PM]
right, but idea is to set ~from main bifurcation to end of primary tuft

samn [2:44 PM]
end of primary tuft is end of cell

[2:44]
you mean beginning of primary tuft?

[2:44]
where on that figure are you thinking?

salvadord [2:44 PM]
so in our cell woulb something like 350-650 ?

samn [2:44 PM]
so you mean from nexus to beginning of the actual tufts

[2:45]
yeah, maybe around 280 - 600 ?

salvadord [2:45 PM]
just following logic from paragraph you pasted

[2:45]
so they say bifurcation was at 650, but they started hot spot at 685

[2:46]
and their primary tuft ended around 950 but hot spot ends at 885

samn [2:47 PM]
not sure what they mean by 'end of tuft'

[2:47]
must be from top going down

samn [4:53 PM]
added option for ca hot zone to /usr/site/nrniv/local/hoc/PTcell.hoc

[4:53]
(/u/samn/evoizhi/notebook.dol:59455:1414)

[4:53]
doesn't seem to change soma dynamics that much to leave it on

[4:53]
but have to test further

[4:53]
take a look if want to use it - sal

[4:54]
will test more later

salvadord [4:55 PM]
ok thanks!
*** Sam added ca hotspot and similar to before
FI and subthresh resonance at soma looks similar in the PTcell with ca hot zones ... testing synaptic resonance in the apical dendrites to see if gives same pattern

salvadord [11:39 AM]
great! u got figs?

samn [11:40 AM]
uploaded an image: 16dec8_ficompare_a1.png
Add Comment

salvadord [11:40 AM]
nice

samn [11:40 AM]
uploaded an image: 16dec8_a3.png
Add Comment

samn [11:40 AM]
similar peak

billl [11:41 AM]
similar to before?

samn [11:41 AM]
yeah

billl [11:41 AM]
great

turn on ca hot zone:
h.calginc = 10.0
h.canginc = 100.0
h.usecahotzone = 1.0
cell.reconfig()

Hay 2011:"This high density (‘‘hot’’) Ca2+ zone had 100 and 10 times higher density of CaLVA and CaHVA than anywhere else on the apical tree.”

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161208_163955.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161208_164019.png][fig]]
** DONE Methods: Reduce Na
*** chat
salvadord [1:38 PM]
update on reducing dendritic Na detailed PT cell: I’ve managed to remove dend spikes by reducing Na in dends by 0.25

[1:39]
however that lead to no spikes — flat fI curve

[1:40]
so as suggest by Srdjan been playing with axons params to compensate — specifically na_gmax and Ra

billl [1:40 PM]
so need to augment in soma and axon

[1:40]
Ra? - specifically between soma and axon?

salvadord [1:40 PM]
and managed to get new version with very similar voltage shape and fI curve (but no dend spks)

billl [1:41 PM]
so making soma-axon isopot?

salvadord [1:41 PM]
uploaded this image: Old with dedn spks (left) vs new without (right)
Add Comment

salvadord [1:41 PM]
axon Ra

[1:41]
isopot?

billl [1:41 PM]
isopotential

salvadord [1:42 PM]
uploaded this image: old (left) vs new (right)
Add Comment

billl [1:42 PM]
looks great

[1:42]
just wondering what did with the Ra?

salvadord [1:42 PM]
reduced Ra by factor of 200

[1:42]
and increased axon Na by x2

billl [1:42 PM]
reduced so separated so made the AIP fire first?

salvadord [1:42 PM]
approx

billl [1:42 PM]
AIS

salvadord [1:42 PM]
had to play with diff values to get right shape

billl [1:42 PM]
spike in ax before in soma?

salvadord [1:43 PM]
not using the axon in this model at all

[1:43]
so not checking axon response

[1:43]
probably messed up

billl [1:43 PM]
oh that's ok

salvadord [1:43 PM]
can check and see if too bad — but axon wasn’t tuned before either

billl [1:44 PM]
so what is Ra value?

[1:44]
1?

[1:44]
<1?

salvadord [1:44 PM]
137.494564931 * 0.005

billl [1:44 PM]
hmm

[1:44]
everywereh?

salvadord [1:44 PM]
in axon section

billl [1:44 PM]
0.687472824655

salvadord [1:44 PM]
rest original value = 137.494564931

billl [1:44 PM]
"not using the axon in this model at all" -- "in axon section"

[1:44]
i'm confused

salvadord [1:45 PM]
the axon is included in the model, but we are not using it as output of cell — connecting cells via soma

[1:45]
and whole evo sam did was using soma not axon

billl [1:46 PM]
but the spiking is occurring in the axon and prob same as soma except 10 microsec earlier?

[1:46]
so would be == to use and less spooky

[1:47]
~=

[1:47]
bbial

salvadord [1:50 PM]
spking occurring in axon - hmm possible, will check

salvadord [1:51 PM]
uploaded and commented on this image: old vs new
2 Comments
matches very nicely except for last 2-3 points (high freqs > 50hz)

*** figs of new PT cell v2
cfg.nax_gbar_dendm = 0.25 #1.0
cfg.nax_gbar_axonm = 11 #200
cfg.Ra_axon = 137.494564931 * 0.005

0.015 mS / cm2 = 150 pS / mm2 (reasonable values for soma, dend, axon according to Srdjan)

- no dend Na spikes: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_142300.png][fig]]
- voltage trace comparison: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_142340.png][fig]]
- fI curve comparison: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170207_142356.png][fig]]

- current injections in SPI paper only go up to 0.6nA — and those match almost perfectly in new version

- sims: v26_batch4-9, v26_manualTune
*** testing for PT with cahotspot
v26_batch8-10
*** issue saving and loading PT cell - missing params!
**** tried saving cellParams to save time, but not producing same result
- loading PTcell.hoc modifying some param
- ih erev param not imported properly - think because not in RANGE
**** in HOC if access mech variable and its a GLOBAL, its ok and sets the global value

ah seems ernie also got confused with erev_ih since in HOC you can assign it via section (eg. sec.erev_ih=1 or forall
{erev_ih=1}) even though it is a global variable — in Python can only access via h.erev_ih

In [62]: h('sec2 {erev_ih=15.0}')
Out[62]: 1

In [63]: h.erev_ih
Out[63]: 15.0

- but in python cannot access global variable via section

In [65]: h.sec2.erev_ih
---------------------------------------------------------------------------
AttributeError

In [65]: h.sec2(0.5).ih.erev
---------------------------------------------------------------------------
AttributeError


**** delete command useful?

Syntax:
delete varname
Description:
Deletes the variable name from the global namespace. Allows the varname to be declared as another type. It is up to the user to make sure it is safe to execute this statement since the variable may be used in an existing function.

**** questions for robert
@ramcdougal - I was using h.MechanismType and h.MechanismStandard to extract the mech params from an instantiated cell — but
if params are GLOBAL (only declared in PARAMETER), they don’t seem to show up — any way of extracting these for each mech?

salvadord [12:40 PM] also, is there any way of unloading or reloading mechanisms (load_mechanisms() will not load a mech
twice), or resetting global params to their default values?

**** netpyne implementation
- check globals before importing, check globals after, store difference - only float and int; omit nseg
- store in each cellRule
- compare globals for each cellRule -- if diff values for same cell print warning/error!
- after import restore globals to original values

**** code from robert
mt = h.MechanismType(0)
mechname = h.ref('')
mechvars = {}

def find_global_vars(name):
	name = '_' + name
	result = {}
	for n in dir(h):
		if n.endswith(name):
			try:
				result[n] = float(h.__getattribute__(n))
			except:
				pass
	return result

for i in xrange(int(mt.count())):
	mt.select(i)
	mt.selected(mechname)
	mechvars[mechname[0]] = find_global_vars(mechname[0])

from pprint import pprint
pprint(mechvars)

** DONE Methods: Length of 6-comp IT cells for L2/3,4,6
- could adapt length depending on layer, so dendrite always reaches L1
- check if changing L of dends changes the soma firing rate tuning
- changes f-I curve, but check if within experimental range
- very similar and within exp range -- sam agrees ok to change
- wait for new optim results and check appropriate lengths

- use reduced model: "BS1578 yfrac lower than that (close to L5A/B border)” - /u/samn/evoizhi/CSTR6.BS1578.py

- Yamawaki 2015:
-- f-I slope (Hz/nA): L23=63, L4=80, L5A=103
-- Ithresh (pA): L2/3=267, L4=295, L5A=163

- Suter, 2013 (temp 34ºC):
-- CSTR rheobase: 182 (SPI: 341);
-- f-I slope (Hz, nA): CSTR= 61, SPI= 98

- Oswa 2013 (temp 26ºC):
-- fI slope (HZ/nA): CSTR=88, SPI=82, CTh=69, CC (upper layers?)=82
-- max feq (Hz): CSTR 29, SPI=34, CTh=26, CC=30
-- I50%maxfreq (pA): CSTR=214 (15hz), SPI=273 (17hz), CT=486 (13Hz) , CC=332 (15hz)
-- at 34ºC all higher -- CSPI higher rates than rest

***   option 1
- IT2, IT4, CT6 use simple BS1578 with adapted L (higher rheobase/Ithresh, smaller fI slope; Yamwaki 2015, Oswa 2013)
- IT5A, IT5B, IT6 use simple/detailed BS1579 (lower rheo, higher fi slope; Yamawaki 2015, Suter 2013, Oswa 2013)
- (not using detailed BS1578) - differentiate upper (1578) vs lower (1579) ITs; and lower IT (1579) vs CT (1578)

- note length of dend tree = mean cortical depth of layer

*** change basal dendrite length too
IClamp 0.4nA (orig Bdend L):
   IT2 : 13.000 Hz
   SOM2 : 93.000 Hz
   PV2 : 117.000 Hz
   IT4 : 11.000 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 28.000 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.000 Hz
   IT6 : 30.000 Hz
   CT6 : 9.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

IClamp 0.4nA (modified Bdend L=1/3 of layer width):
   IT2 : 18.000 Hz
   SOM2 : 93.000 Hz
   PV2 : 117.000 Hz
   IT4 : 14.000 Hz
   SOM5A : 0.000 Hz
   PV5A : 0.000 Hz
   IT5B : 28.000 Hz
   SOM5B : 0.000 Hz
   PV5B : 0.000 Hz
   IT6 : 28.000 Hz
   CT6 : 7.000 Hz
   SOM6 : 0.000 Hz
   PV6 : 0.000 Hz

** DONE Methods: Two detailed L5 IT cells
- wait for optim results or use sam's best params

*** 17jan10 new cells
sal, these files have decent params and instantiations of the IT cells
/u/samn/evoizhi/CSTR6.BS1578.py
/u/samn/evoizhi/CSTR6.BS1579.py
/u/samn/evoizhi/ITcell.BS1578.py
/u/samn/evoizhi/ITcell.BS1579.py

if I find better versions, will update params in those files

BS1579: "Corticostrial in R M1 L5B, soma depth 711 um below pia, cortical thickness 1336 um, yfrac 0.532"
"BS1578 yfrac lower than that (close to L5A/B border)”

*** 17jan17 bug in CSTR6.BS1579.py -- different in neurosim vs mac (cloning same repo /evoizhi)
- related to mod files
- only works if use parameters.multi but not nrnvimodl
- figure out what mod files causing problem and how to convert mkmod method to nrnvimodl

- reproduce error:
1) compile using mkmod (remove gabab from parameters.multi if error)
2) run and get ok result
3) remove x86_64 folder
4) recompile generated mod files using nrnivmodl
5) run and get wrong result

- to reproduce on 'no' from /u/salvadord/Documents/ISB/Models/evoizhi/:
ipython -i CSTR6.BS1579.py (graph ok)
mv mod/x86_64 mod/x86_64_mkmod
mv mod/x86_64_nrnivmodl mod/x86_64
ipython -i CSTR6.BS1579.py (graph wrong)

*** use 1 for upper layers, and other for lower
- IT2, IT4, CT6 use simple BS1578 with adapted L (higher rheobase/Ithresh, smaller fI slope; Yamwaki 2015, Oswa 2013)
- IT5A, IT5B, IT6 use simple/detailed BS1579 (lower rheo, higher fi slope; Yamawaki 2015, Suter 2013, Oswa 2013)
- (not using detailed BS1578) - differentiate upper (1578) vs lower (1579) ITs; and lower IT (1579) vs CT (1578)
*** use detailed IT only for L5A ??
- strong connections to IT L5A not 5B
- use detailed BS1579 for IT L5A; reduced BS1579 for IT L5B

*** Also adapt Adend and Bdend L of L5B cell (otherwise high rate at IClamp 0.45nA)
- using original L IT5B_reduced produced 75Hz for IClamp 0.45nA !! (0.4= 30hz, 0.5=40hz)
- applied same method to adapt L -- 1/3 of layer = 290.25 = very close to original of 295 adend and 266 for bdend
- very similar FI curve

*** IT4 lower rate than IT2
-yamawaki paper mentions different; significant variability; higher Ithresh than IT2 (295 vs 267); but higher fI (not captured)

** DONE Methods: Tune 6-comp CT cell
*** Chat with sam
the other thing is CT cells, which are currently identical to IT — so we can’t really claim we have a different cell type
(although conn is different)

samn [12:44 PM]
yeah, that issue raised earlier

salvadord [12:45 PM]
do u think maybe we can find some small feature to modify so that can claim different cell type?

[12:45]
maybe check some characteristic of CT cells and tweak something slightly so just a bit different?

samn [12:45 PM]
which feature? cells were optimized to the data ...

[12:46]
think ben said earlier that dynamics of IT and CT similar

salvadord [12:46 PM]
y, but optimized to IT data… so eg. if CT cells fire less, maybe can modify some of the params to make fire less, trying not to mess the rest

[12:46]
ok, but only thing that then we can’t really say they are different cell types

samn [12:46 PM]
if you have a target dynamics for CT i can adjust

[12:49] from ben re yfrac of bs1578 vs bs1579: "BS1578 was from the same animal as BS1579 (the data I previously shared with
you), but in a different slice (more anterior). The soma-to-pia distance is very similar, but because BS1578 is anterior,
cortex is thicker, and yfrac is thus lower. Specifically, BS1578 is close to the L5A/B border."

[12:52]
"BS1579 is an IT L5B neuron (crossed corticostriatal)"

[12:52]
BS1579: "Corticostrial in R M1 L5B, soma depth 711 um below pia, cortical thickness 1336 um, yfrac 0.532"

[12:54]
so that info should be enough to deduce yfrac of BS1578

salvadord [12:59 PM]
ok so they are at slightly different yfracs — close to L5A/B border vs L5B

*** neuroelectro and neuromorpho have data
neuroelectro has some intrinsics for mouse M1 CT cells (although surprisingly supposed to be in L5 — maybe border with L6?):
http://www.neuroelectro.org/data_table/27536/

also some CT morphologies in neuromorpho: http://neuromorpho.org/KeywordResult.jsp?str=corticothalamic%2C%20mouse

several diffs: eg. CT input resistance lower than IT + PT; sag higher than IT + PT; more adaptation than IT+PT ...

- in model, higher rheobase + lower firing rates: evidence in OSwa 2013 (I50% significantly higher ~480pA vs ~250pA; no rheobase values)

*** Use IT BS1758
- higher rheobase, smaller fI slope
** DONE Methods: Long range inputs (rates, conn, subconn)
*** email to Gordon
Hi Gordon,

I've been working with Ben on adding subcellular synaptic distributions for L2/3 IT -> PT connections to the network model,
  based on the sCRACM data from his paper. The network includes the detailed PT and IT models that Sam & Ben have developed.
 Our sfn poster describes the network model and the effect of using different synaptic distributions on the network dynamics:
  www.neurosimlab.org/salvadord/sfn16.pdf

As discussed in our previous meetings, we would now like to incorporate the rest of PT cell sCRACM maps from Ben's
paper for long range inputs: thalamus, S2, M2, contralateral M1 (S1 too although don't have data). For now these regions will
be modeled as simple spike generators. However, for each of the long-range inputs it would be useful to have:

1) overall conn strength, probability of conn, and/or unitary conn strength (to PT cells and if possible to other cell classes too)
2) any information on the presynaptic firing patterns, e.g. avg firing rates, oscillation freq, etc.

We can probably find most of the above for some cortical region (most likely, V1 or S1). However, we wanted to know if you have any data,
insights, and/or suggested refs specific to mouse M1? We could also set a call to discuss.

Many thanks
Salva
**** ben comments
Let me rephrase: certainly it's worth asking (1) and (2), perhaps he knows of some new studies. Do you have any indication
that he has initiated new studies in these directions? I do think that Xiaojian has in vivo extracellular recordings from
contralateral M1 and M1, with multisite silicon probes. When I was in the lab still, though, these data were not very
informative for our purposes - he wasn't doing spike sorting, just multiunit activity, and the mouse was just sitting there -
awake, I believe, but not in a very happy state methinks. But maybe this project has advanced further and they have some
information about firing rates in M1 and cM1, as a function of layer (maybe even cell type), with some real task or movement.

ben.suter [6:15 AM]
I think your email is nicely written, and Gordon knows the literature well, so he can maybe suggest something helpful.

[6:17] A Rabies-virus based retrograde tracing project, from known cell types in M1, to identify their presynaptic partners,
including the approximate # of presynaptic neurons by area, would be helpful. This method doesn't give hard numbers (because
of unknown tracing efficiency), but it does give a better starting point than what we have now - probably. I think that
Catherine was working on something along these lines when she was in the lab.

[6:18]
You could perhaps add something to your email along those lines, not necessarily mentioning those specifics.

[6:18]
For (1), perhaps could phrase it in more experimental terms, rather than modeling terms.

[6:20] (1) # of presynaptic neurons per cortical area; convergence & divergence (for area X into M1 PT, IT, etc.); unitary
synaptic strength

For what it's worth, I like the anatomical approach of counting spines to get an upper limit on # of excitatory contacts. I
have some #'s on this somewhere (check my journal notes?), but might need to be done more carefully for a paper. I have the
2P data, so this could be done - need not even be by me. It's a matter of systematically counting spines in the 2P data,
probably not for the entire arbor, but for randomly selected ~20 micron branch sections, in various parts of the dendritic
arbor. This is what I did for one neuron already. So you get a length-density of spines for different regions of the cell:
first degree basal, 2nd degree basal, and so on; oblique; distal tuft, nexus region, and so on. What's tricky is that spines
are of course 3D, and the imaging resolution is not so good in Z - there are some papers analyzing the geometry and
introducing correction factors to account for "hidden" spines (e.g. below the dendrite in Z), partially occluded spines, and
so on - as a function of dendrite thickness. I've applied these corrections in my estimates.

[11:09] For L5-L5 we know the # of contacts per synapse (4-6 as I recall), from Markram 1997 (?). But I don't think we know
this for L5 cell-type specific connections (e.g. Taro didn't do it). Maybe also for L2/3->L5 from Alex Thompson or similar?
But for long-range I don't know. Well, probably for thalamocortical synapses (at least in barrel cortex, S1) this may be
known.

[11:11] And of course not every spine necessarily contains an active synapse. People have looked at spine dynamics in
neocortex, at least in some cell types (mostly in L1 and L2/3 I think), probably not deep basals in L5. Maybe there is data
on what fraction of spines tend to have active synapses - if not, can estimate this (maybe 10% are in the process of
losing/forming synapses?).

[11:12] Would be nice to know the approximate # of presynaptic L2/3 neurons for a single post-synaptic CSP - this might vary
as a function of CSP soma depth, since input strength from L2/3 varies with CSP soma depth (see Anderson & Sheets). This
could be estimated using Rabies Virus tracing - and maybe Gordon has data on this.

**** response from Gordon
Hi Salvador (et al.) -- all good questions, and all would be good parameters to have quantitative information about, but
unfortunately we don't. For example, unitary connections of any types of long-range connections are extremely rare, and not
done so far for any long-range input to motor cortex neurons (it's something we'd like to do, but will take new methods).

For firing properties of presynaptic neurons -- for cortical neurons, it's mainly the IT's that contribute to long-range
corticocortical projections to M1, so as a reasonable first-order approximation you can just use IT-type intrinsic properties
(i.e., ignore PT and CT). For the inputs of interest (e.g. M2, S2, contra M1) the only recordings I'm aware of are the IT's
in M1 that you already have (i.e., none in S2 or M2). For thalamus, there are some papers on

This article (and coverage) may be helpful to you --

Differential Excitation of Distally versus Proximally Targeting Cortical Interneurons by Unitary Thalamocortical Bursts.
Hu H, Agmon A.
J Neurosci. 2016 Jun 29;36(26):6906-16. doi: 10.1523/JNEUROSCI.0739-16.2016.
PMID: 27358449
Thalamic Bursts and Single Spikes Evoke Distinct Inhibitory States in the Primary Sensory Cortex.
Langberg T.
J Neurosci. 2016 Nov 9;36(45):11496-11497. No abstract available.
PMID: 27911753

**** Ben comments on thalamus inputs
And as I mentioned above, for the thalamocortical I believe there is quite a bit of literature on the synaptic properties
(unitary size perhaps, and facilitation / depression). Maybe also convergence estimates. There is also in vivo data - Randy
Bruno has a paper, in Science I think, from around 2013 or 2014: in vivo recordings in motor cortex L5 pyramidal neurons,
while stimulating thalamus; probably anesthetized, though.

[3:02] Constantinople, C. M. and R. M. Bruno (2013, June). Deep cortical layers are activated directly by thalamus. Science
340 (6140), 1591-1594.

[3:03] Bruno, R. M. and B. Sakmann (2006, June). Cortex is driven by weak but synchronously active thalamocortical
synapses. Science 312 (5780), 1622-1627.

[3:03] The 2006 paper says just 15% of cortical synapses are T->C. I think it also has convergence, divergence, and maybe
dynamics too.
*** Ben on S1->PT, L5+L6 IT/PT/CT->PT
btw meant to ask: in your paper why don’t you have scracm for S1->PT and L5+L6 IT/CT->PT ?

ben.suter [10:28 AM] L5,L6 IT/CT (and PT!)->PT requires one to get ChR2 into those local cell types. RV into spinal cord to
get PTs could work - but Taro did this for his paper, and the expression level / # of presynaptic neurons wasn't strong
enough to get sCRACM to work. But I mostly relied on what he reported, I think I tried it myself briefly, no luck. Paired
recording studies between L5 neurons have been done, including reconstructing the location of synapses. For ITs or CTs same
story, could use RV (Rabies) but this just doesn't seem to be strong enough for sCRACM. That's a vague explanation.

[10:29] Nowadays we could use some cre driver line that is IT specific or PT specific or CT specific, combined with
conditional AAV. This should get ChR2 into a larger population and would likely work for sCRACM. But that wasn't working /
available when I did my project.

[10:30] And note that with RV you'd likely still get ITs across multiple layers, and ditto for CTs. So if you want layer and
type restriction, it's difficult.

[10:30] Anyhow, my focus was on long-range inputs. The local circuitry we think is better studied with paired recordings -
although I do wish Taro had reconstructed his connected pairs, including axons!

[10:32] S1->PT: they are too close, basically. forelimb S1 is adjacent to forelimb M1. In fact, it may be hard to even define
a border. AAV injection would need to be focal into forelimb S1, but avoid forelimb M1. I tried but this wasn't
feasible. Also, when I did inject S1, even with contamination in M1, I don't think I saw strong axons in M1.

L5/6 - ok makes sense; S1 conitinuum - ah interesting, so perhaps could assume S1->PT similar scracm as L2/3->PT?

ben.suter	[10:45 AM]
for L2/3 S1 sure, could start with that

*** Exp data for long range inputs (summarized in gdoc sheet)
**** Thalamus
***** Sherman 2012 (DONE)
- classification of glutamatergic pathways in thalamocortical circuits:
-- Class 1, which carries the main information for processing (core)
Activates only ionotropic receptors
Synapses show paired-pulse depression (high p)a Large EPSPs
Less convergence onto target
Thick axons
Large terminals on proximal dendrites
Dense terminal arbors

-- Class 2, which serves a modulatory role. (matrix)
Activates metabotropic receptors Synapses show paired-pulse facilitation Small EPSPs
More convergence onto target
Thin axons
Small terminals on distal dendrites Delicate terminal arbors

- division of thalamic relays into:
-- first:  receives Class 1 inputs from subcortical sources
-- higher order: receives from layer 5 of cortex, which it then relays to another cortical area.

- no specific data for model

***** Yamawaki 2015 TC (DONE)
- VL inputs to CT neurons were strikingly weak, in contrast to the robust VL input to PT neurons and to IT neurons in layer
  5B and upper layer 6 (FIG 6)
- CT neurons received vastly less TC in- put compared with either PT (median ratio of TC->CT/TC->PT: 0.05, Fig. 6C) or IT-5B
  (median ratio of TC->CT/ TC->IT-5B: 0.16,Fig. 6D) neurons
- TC input was furthermore significantly weaker onto CT than to neighboring IT-6 neurons (median ratio of TC->CT/ TC->IT-6:
  0.33). However, strong TC input to IT-6 neurons was only observed for neurons located in the upper part of layer 6 (<0.85 yfrac)

- The lack of TC->CT connectivity was unexpected from prior studies of CT neurons in sensory cortex that have suggested direct
  TC innervation of CT neurons (for review, see Thomson, 2010)
- TC->CT synapses were much less abundant than expected on the basis of axon-dendrite overlap, leading to the suggestion that
  excitation from intracortical rather than TC sources determines CT firing activity

- PT = 1.0, CT = 0.1 (ratio in paper = 0.05 ?)

-CT/PT5B = 0.05; CT/IT5B = 0.16
Assume 50% of each IT and PT in L5B -> CT/CT ~= 0.1
5B = 0.6
CT = 0.03 # ignore this

CT/PT = 0.05
CT/IT = 0.16
(PT+IT)/2 = 0.6

--> solution to 3eqn: C=0.0457, P=0.914, I=0.286


- CT/IT6 (yfrac<0.85) = 0.33
Assume 50% of each cell type per layer:
(CT+IT6)/2 = a; CT = 0.33 * IT6
(0.33*IT6 + IT6)/2 = a -> 0.5*0.33*IT6 + 0.5*IT6 = a -> IT6 (0.5*0.33 + 0.5) = a -> IT6 = a / 0.665

for TVL, a=0.061 (yamawaki elife) -> IT6 = 0.061/0.665 = 0.091; CT = 0.33 * IT6 = 0.03


- CT=IT6 (yfrac>0.85) = 0.2


***** Yamawaki 2015 L4 (DONE)
- two distinct peaks of TC input, the uppermost of which coincided with the L3/5A border (normalized cortical depth, ~1/3)
  (Fig. 2C, D, E). These data thus indicate that M1 contains neurons in a laminar zone corresponding to L4 that receives
  strong monosynaptic excitatory TC input from a primary thalamic nucleus associated with this cortical area, thereby
  fulfilling one important circuit-level criterion for the identification of L4 in M1.

- Laminar profiles of the relative amount of monosynaptic TC input from PO axons to M1 neurons showed a broad peak in the
  upper layers that included L4 and adjacent layers .
- Thus, PO’s laminar input pattern in M1 from resembled its laminar innervation of secondary somatosensory cortex (S2) and the
septum-related columns of rat barrel cortex , rather than its innervation of S1 barrel-related  columns themselves (Feldmeyer, 2012).

 ['pia', 'L1-L2/3 border', 'L2/3-L4 border',   'L4-L5A border',   'L5A-L5B border',    'L5B-L6 border',   'L6-WM border']
 [0,     0.12,           0.31,               0.42,               0.52,               0.77,               1.0]

Bar0, 0.15 - L2/3
Bar1, 0.25 - L2/3
Bar2, 0.35 - L4
Bar3, 0.45 - L5A
Bar4, 0.55 - L5B
Bar5, 0.65 - L5B
Bar6, 0.75 - L5B
Bar7, 0.85 - L6

- VL -> mouse forelimb M1:
L23u (0.15): 0.30
L23l (0.25): 0.43
L4   (0.35): 0.64
L5A  (0.45): 0.24
L5Bu (0.55): 0.34
L5Bm (0.65) 0.77
L5Bl (0.75): 0.69
L6   (0.85): 0.061

- POm -> mouse forelimb M1:
L23u: 0.26
L23l: 0.72
L4: 0.72
L5A: 0.58
L5Bu: 0.25
L5Bm: 0.090
L5Bl: 0.044
L6: 0.022

***** Hooks 2013 (Thalamic + Cortical) (DONE)
****** Summary fig
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161206_190025.png][fig]]
****** L2/3, vS1
- Long-range input from vS1 selectively targets superficial neurons in vM1 and also avoids L5B and L6 neurons (Kaneko et al.,
  1994; Mao et al., 2011).
- L2/3 -> PT sCRACM input maps (Fig. 1G) -- similar to Ben's?
- L2/3 input to PT-type neurons was strong in upper L5B, and much weaker in lower L5B (20-fold difference; Fig. 1 I).
- PT-type neurons in lower L5B receive weak interlaminar excitation from pyramidal neurons in the local circuit and little
long-range input from vS1 (Mao et al., 2011). These observations motivated us to search for other long-range excitatory
inputs to L5B and L6 of vM1

****** Origin layers from M2,contraM1,vS1 and S2
- Identified brain regions projecting to vM1: Multiple cortical and thalamic regions were labeled, including ipsilateral
  primary and secondary somatosensory cortices (vS1 and S2), secondary motor cortex (M2), orbital cortex (OC), and anterior
  and posterior thalamic nuclei (including AM, VA, VL, and POm).
- With the exception of vM1, contralateral projections were weak.
- Inputs to vM1 predominantly came from the superficial layers of ipsilateral M2 and contralateral M1 and M2.
- Ipsilateral vS1 and S2 inputs originated in L2/3, L5A, with a minor contribution from deeper layer neurons

****** Sensory thalamus
- Sensory thalamus projected strongly to vM1: primarily L1 and L5A; inputs to L5A neurons was 8 times stronger than to L5B
  neurons and 50 times stronger than to L6 neurons; input to L23 neurons was comparable to L5A neurons
- The laminar pattern of input from the sensory thalamus was indistin- guishable to that from vS1
- The normalized input maps (sCRACM) highlight the subcellular distributions of inputs across the dendrites of the recorded
  neurons (Fig. 6F,G). L2/3 and L5A neurons receive mainly perisomatic input, with a center of mass just below the
  soma. Thalamic input to L1 of L2/3 and L5A neurons were present but less prominent, at least in part due to electrotonic
  attenuation.
- sCRACM of sensory thalamus (POm, VL) -> ~80 (IT?) cells at different depths

- Data points:
L23, 0.81
L5A, 0.99
L5B, 0.13
L6, 0.012

****** Motor thalamus
- Neurons in L2/3, L5A, and L5B received strong input from motor thalamus, whereas L6 received significantly less input
- Excitatory inputs to L5A were generally perisomatic, although L1 input was evident. (sCRACM)
- In contrast, L2/3 neurons received motor thalamic inputs to two regions: basal dendrites below the soma, and apical
  dendrites in L1 (sCRACM)
- All L5B pyramidal cell types, including PT- type neurons, receive strong input from motor thalamic axons.
- No significant differences in strength of anterior thalamic input received by upper and lower sublayers of L5B.

L23, 0.71
5A, 1.0
5B, 0.78
6, 0.077

****** M2
- Inputs from M2 to vM1 targeted predominantly L5B and L6; ~ complementary to that measured from sensory thalamus and vS1
- Projections from M2 originated predominantly from neurons in the upper layers of cortex
- L5B pyramidal neurons received larger input than either L2/3 or L5A neurons.
- L6 neurons received relatively higher M2 input than L2/3 and L5A, but also significantly less than L5B neurons.
- M2 input tended to be perisomatic (sCRACM)
- PT-type and IT neurons in L5B at similar laminar depth received quantitatively similar input
- Significantly greater excitation to the deeper half of L5B

L23, 0.17
L5A, 0.11
L5B, 1.0
L6, 0.44

****** vM1 vs M2
- Both areas were strongly interconnected with other frontal areas, including ipsilateral and contralateral OC, M2, and vM1
- Projections to thalamus were partially overlapping, with M2 targets shifted medially
- Fig 11 shows fraction of output + output density of vM1 vs S2

****** OC
- pyramidal neurons in all layers received detectable input, this was limited to 20 –30% that of L6 neurons
- Neurons in deep layers of ipsilateral OC were strongly labeled by injection of retrograde tracer into vM1; strongest in L6
- Although pyramidal neurons in all layers received detectable input, this was limited to 20 –30% that of L6 neurons
- Formed predominantly perisomatic contacts (sCRACM)

- The innervation of L6 neurons by OC axons furthermore suggests a specialized role for OC in regulating corticothalamic
  feedback; for example, OC may exert executive control over M1- dependent actions through these direct connections to L6
  neurons.
- Because M2 and OC inputs directly innervate PT-type and CT-type neurons, frontomotor sig- nals bypass local circuit input
  and act di- rectly to influence excitatory output to brainstem and thalamus. M1 thus may operate in different modes
  depending on the behavioral task.

L23, 0.19
L5A, 0.31
L5B, 0.30
L6, 1.0

****** summary & questions
Read through Hooks,2013 and has lots of interesting data on long range inputs from thalamus, M2, orbital cortex (OC) and some
vS1 and S2, onto vibrissal M1 (vM1) cells in all layers; includes laminar info of pre- and postsyn cells, and sCRACM data
(dendritic distribution) for most projections -- including for target IT cells at different layers.

@Ben - 1) fig 1 shows
similar sCRACM data to your paper (eg. L23->PT), is there much difference between vM1 and M1?, 2) was thinking could convert
sCRACM maps to radial syn density maps for IT cells, do you know if the morphology of these cells is available? (otherwise
can find one with similar soma depth and use ours), 3) Do you have access to the data in this paper or we need to ask gordon?
****** Ben's reservations on using sCRACM
That said, please note my reservations about (certain aspects of) using his scracm data for subcellular
distributions. Primarily, I believe vM1 is quite different in morphology, axodendritic overlap, and connectivity. Also, I
believe Mac's focus was on summing the total input to cells, rather than the subcellular location of inputs.

****** Email to Ben on possible methods to use sCRACM
Thanks Ben. I think I can easily extract the input laminar distributions from the paper. So if not worth using the sCRACM data, I don't need to email gordon/mac.

However, I still need to decide how to distribute synpases from these long range inputs across the detailed L5 IT cell dendritic tree. I see several options:

1) Ask mac/gordon for sCRACM data, and perhaps cell reconstructions (if they have, otherwise use our IT cell) and,
 a) apply the poster sCRACM -> syn density method;
 b) use some principle/rule derived from the PT sCRACM maps to obtain syn density from the IT sCRACM maps.

2) Distribute uniformly but incorporate clear qualitative features from the sCRACM data, eg. motor thalamus -> L2/3 has strong input to L1 apical.

3) Distribute uniformly (over 'spiny' sections if known) -- same as for many of the local conns for which we don't have sCRACM data.

Obviously, none of the above are accurate methods (for multiple reasons) but have to choose the one that think would give the best approximation. Do you have any preference / other suggestions?

thanks
salva
****** Online app to extract data points
http://arohatgi.info/WebPlotDigitizer/app/?

***** Hooks 2015 (Thalamic + Cortical) (DONE)
- Thalamus POm and vS1 to vM1; 2CRACM method
- Ascending sensory information is topographically represented in vS1, with single barrels primarily responsive to touch of a
  single whisker
- The POm nucleus of the thalamus is part of an ascending sensory pathway characterized by slower, multiwhisker responses
- Axons from vS1 and POm each excite pyramidal neurons in L2/3 of vM1, but it is unknown whether these inputs are correlated
  at the level of single neu- rons.

- vS1 and POm inputs excite the same individual neurons, and the strength of the two inputs is positively correlated.
- A subset of vM1 neurons in L2/3 receive strong input from both vS1 and POm and thus may be specialized for sensory
  processing in the context of motor control.
- Because of the overlap of the vS1 projection zones in vM1 and the widths of individual vM1 neuron dendrites, it is not
  clear the degree to which single vM1 neurons maintain the somatotopic organiza- tion of vS1 or integrate input from across
  somatosensory cortex
- Data suggest that vM1 neurons integrate somatosensory input from a large area of vS1.

***** Harris&Shepeherd, 2015 - neocortical circuit (DONE)
Long range inputs (rodent S1 and M1):
- L4 IT: Core thalamus, cortical FF (perisomatic)
- L2 IT: Matrix thalamus+cortical FB (L1 apical), cortical FF (perisomatic)
- L3 IT: Matrix thalamus+cortical FB (L1 apical), Core thalamus+cortical FF (perisomatic)
- L5A/B IT: Matrix thalamus+cortical FB (L1 apical, basal), Core thalamus+cortical FF (perisomatic)
- L5 PT: Core thalamus (basal), Cortical FB (tuft, perisomatic)
- L6 CT: Cortical FB (basal)

- SST: only local
- PV: Cortical FF, Core thalamus

-The applicability of the core/matrix scheme beyond primary sensory cortex is not yet fully clear.
- Thalamic projections to primary motor cortex (M1) appear, at least in rodents, to follow a rough core/ matrix organization:
  TC axons relaying cerebellar information project to the L3/L5A border, while TC axons relaying basal ganglia information
  project more heavily to L1, consistent with core­ and matrix­type patterns, respectively; upper­layer neurons in M1 can
  also receive matrix­type inputs from POm. Thalamocortical inputs to secondary sensory and association cortex come from
  nuclei containing chiefly matrix­type neurons.

- However, at least in secondary somatosensory and auditory cortex, these inputs terminate heavily in
L4, suggesting they strongly drive secondary cortical areas, in contrast to their modulatory effects on primary
areas26,33,34. Thus, the concepts of core­ and matrix­type projections may need to be extended to manage the full complexity
of thalamic projections to higher order cortex.

L23, 0.17
L5A, 0.11
L5B, 1.0
L6, 0.44
***** Sheperd 2013 - corticostriatal role in disease (DONE)
- no long range inputs; only outputs

***** Hu H, Agmon A. 2016 (DONE)
Differential Excitation of Distally versus Proximally Targeting Cortical Interneurons by Unitary Thalamocortical Bursts.
Hu H, Agmon A.
J Neurosci. 2016 Jun 29;36(26):6906-16. doi: 10.1523/JNEUROSCI.0739-16.2016.
PMID: 27358449

- Mouse somatosensory thalamus and cortex; dual recordings
- L5B RS (=IT based on comparison of intrinsics from Suter,2013), FS, and SOM
- unitary thalamocortical connection EPSPs (uEPSPs) to 3 cortical cell types
- avg RS uEPSP: latency= 2.22ms+-0.38, amp=0.6+-0.2, riset=2.06+-0.76ms, decay tau=28.3+-10.3ms
- avg FS uEPSP: latency= 2.03ms+-0.6, amp=5.4+-5.6, riset=0.57+-0.17ms, decay tau=8.5+-2.9ms
- single SOM uEPSP: latency= 1.89ms, amp=1.44, riset=0.67ms, decay tau=12.1ms

- avg of 4-6 contacts made by thalamocortical axons on FS interneurons

***** Langberg T. (2016) (commentary of Hu 2016 - DONE)
Thalamic Bursts and Single Spikes Evoke Distinct Inhibitory States in the Primary Sensory Cortex.
Langberg T.
J Neurosci. 2016 Nov 9;36(45):11496-11497. No abstract available.
PMID: 27911753

***** Kaneko 2013 (DONE)
It is proposed that two circuits sharing the same TC projection and ML neurons are embedded in the neocortex: one includes
L2/3 and L5 neurons, processes afferent information in a feedforward way and sends the processed information to other
cortical areas and subcortical regions; and the other circuit participates in a dynamical system of theTC recurrent circuit
and may serve as the basis of autonomous activity of the neocortex.

- The ventral anterior and ventral lateral thalamic nuclear complex (VA–VL) is the motor thalamic nuclei, receiving
  cerebellar and basal ganglia afferents and sending projections to motor- associated cortical areas.

- The VA–VL is divided into two portions:
1) the rostroventrally located inhibitory input-dominant zone (IZ); principally innervated by the basal ganglia inhibitory afferents
2) and caudodorsally situated excitatory subcortical input-dominant zone (EZ); driven by the cerebellar excitatory afferents.

- In rats:
(1) The cortical axons of IZ neurons preferred L1 of motor- associated areas, 54.0 ± 7.3% of intracortical axon boutons being
distributed in L1 (cell bodies = L23, L5 IT+PT). In contrast, only 5.8 ± 5.1% of intracortical boutons of EZ neurons were found in L1, and mainly
distributed in middle layers (MLs; L3–L4).  (cell bodies, L4, L5PT)

(2) Almost no EZ neurons sent axon collaterals to the striatum, whereas all IZ neurons projected a considerable amount of
collaterals to the striatum.

(3) The cortical axonal arborization of IZ neurons was very wide in areas M1, M2, HL, FL and S1. The arborization of EZ
neurons was also widespread, but narrower than that of IZ neurons.

(4) The dendritic arborization of EZ neurons was denser than that of IZ neurons.

These results are partly compatible with the concept of “core” and “matrix” projections of TCNs, proposed mainly in the sen-
sory thalamic neurons by Jones

- the cortical axons of EZ neurons were widely, though not evenly, distributed in the motor-associated areas (unlike in
  sensory areas, where they are narrower/columnar
- In other words, the motor-associated areas might apply “non- columnar,” area-wide information processing for motor control.

- Furthermore, because the axonal arborizations of both EZ and IZ neurons were widely distributed, single pyramidal neurons
with developed apical dendrites in the motor-associated areas are likely to receive and integrate two kinds of motor
information: one from the basal ganglia to the apical dendrites of pyramidal neurons, and the other from the cerebellum to
their basal dendrites.

***** Constantinople, C. M. and R. M. Bruno (2013, June). (DONE)
Deep cortical layers are activated directly by thalamus. Science 340 (6140), 1591-1594.

- In vivo rat sensory thalamus (VPM)

Latency (delay):
- L4 onset latencies preceded those in L2/3 (7.76ms; L2/3: 11.04). While the average L5 (9.44) and L6 latencies (10.68) were
  longer than that of L4; many L5 cells exhibited spike latencies as short as cells in L4
- spiking latency range 10-30ms (L2/3,4,5,6)

- VPN->L5/6, 10 of 55 of monosyn pairs tested (unidentified)
- VPN->L5 pyramidal neurons (26%, 7 connected of 27 pairs tested)
- VPN->L6 cells (9%, 1 of 11)
- VPN->PT (44%, 4 connected of 9 pairs tested); VPN->L5 IT (17%, 3 of 18); VPN->L6 (9%, 1 of 11)
- VPM contains ~200 neurons (14), 9–44% convergence translates to ~20–90 thalamic connections per cell depending on its type.
- Only for topographically aligned regions
- depolarization L5/6 = 571uV, similar to L4~=500uV

- after L4 inactivation, sensory stimuli continued to evoke L5/6 action potentials with same amplitude

- The relative depolarization of L5 cells here enables less synaptic input than available to L4 to become suprathreshold in
  53% of cells
- In contrast the smaller sensory-evoked PSPs and relative hyperpolarization of L6  render 81% of its cells
  silent, consistent with L6 corticothalamic cells being unresponsive to sensory stimulation
- L2/3’s extremely low firing rates may explain its minimal contribution to sensory signals in deep layers, which by contrast
  are highly active.

***** Bruno, R. M. and B. Sakmann (2006, June). (DONE)
Cortex is driven by weak but synchronously active thalamocortical synapses. Science 312 (5780), 1622-1627.

The 2006 paper says just 15% of cortical synapses are T->C. I think it also has convergence, divergence, and maybe dynamics
too.

- thalamocortical synapses account for less than 15% of all synapses onto L4 spiny neurons

- Monosynaptic connections onto excitatory L4 barrel neurons were frequently observed (17 out of 40 pairs). ; Onset latency 1.72
- The connections had small aPSP amplitudes (mean 950 uV, median 550 uV, range 165 uV to 4.16 mV);
- vs in vivo: TC-L4 synapses = [mean 1.96 mV, range 0.39 to 5.89 mV (5)].

- Our method suggests a TC (VPM->L4) convergence ratio of 0.43, consistent with paired extracellular estimates (11), but slightly
  higher, perhaps because of better sensitivity to weak connections.
-Therefore, given 200 thalamic cells per barreloid a L4 cell would on average receive 85 TC connections (200 cells ~43 connections/cell).
- About 65% of the roughly 2800 total spines on dendrites of an excitatory L4 neuron are contacted by axons originating from
  other L4 cells

- Each TC axon is thought to contribute on average about seven active synaptic contacts (4). Our estimate of 85 TC
  connections per cell suggests that, on average, 600 spines would be contacted by TC axons. This is well within the range of
  the 1000 spines not associated with axons originating within L4.

***** Bazhenov 1998 (DONE)
- simplified net - two-dimensional network of 729 􏰙 4 RE-TC- CX-IN cells. In the latter three networks, “dense proximal
  connections” (Destexhe et al., 1994a) were used where each cell made connections with all other cells within a fixed
  radius. The diameters of the connection fan out were 9 cells for RE3 RE (GABAA ), RE3 TC (GABAA 􏰟 GABAB ), TC3RE (AMPA),
  CX3CX (AMPA), CX3IN (AMPA), and IN3CX (GABAA ) connections and 17 cells for TC3CX (AMPA), TC3IN (AMPA), CX3TC (AMPA), and
  CX3RE (AMPA) connec- tions.
- AMPA syns
- conn not clear from modeldb code

***** Kerr 2013 + Song 2013 (DONE)
- data from rat thalamocortical model in https://github.com/thekerrlab/ratfitting/blob/master/cellpopdata.py
- rat S1 firing rate: base = 10 Hz; peak = 40 Hz
- Thalamocortical relay nucleus cell
- connprobs[TCR,ER2]=0.1;
    connprobs[TCR,ER4]=0.2;
    connprobs[TCR,EB5]=0.1;
    connprobs[TCR,ER5]=0.1;
    connprobs[TCR,ER6]=0.1;
    connprobs[TCR,IF2]=0.1;
    connprobs[TCR,IF4]=0.1;
    connprobs[TCR,IF5]=0.1;
    connprobs[TCR,IF6]=0.1;

    connweights[TCR,ER2,AMPA]=0.5;
    connweights[TCR,ER2,NMDA]=0.05;
    connweights[TCR,ER4,AMPA]=1.0;
    connweights[TCR,ER4,NMDA]=0.1;
    connweights[TCR,EB5,AMPA]=1.5;
    connweights[TCR,EB5,NMDA]=0.15;
    connweights[TCR,ER5,AMPA]=1.5;
    connweights[TCR,ER5,NMDA]=0.15;
    connweights[TCR,ER6,AMPA]=1.0;
    connweights[TCR,ER6,NMDA]=0.1;
    connweights[TCR,IF2,AMPA]=1.5;
    connweights[TCR,IF4,AMPA]=1.5;
    connweights[TCR,IF5,AMPA]=1.5;
    connweights[TCR,IF6,AMPA]=1.5;

***** Hunnicutt et al,2014  Allen Brain (DONE)
- "A comprehensive thalamocortical projection map at the mesoscopic level"

- Previously, we found that the posterior ‘sensory’ thalamus is more likely to project to layers 2/3 and 5a (L2/3–5a) in vM1,
  whereas the anterior ‘motor’ thalamus projects to layer 5b (L5b) as well as L2/3–5a (37).

- Although previous research has shown that these nuclei send vM1 projections broadly to both L5b and L2/3–5a, we found
  evidence of preferential projections to L5b in vM1.
- The thalamic projections that preferentially target L2/3–5a arose from a more posterior-central thalamic volume,
identified here as Po, LP, Pf and SPFp. This confirmed previous results, which suggest preferential projections
from a region containing Po to L2/3–5a in vM1 (37).
- Furthermore, when we compared each layer-preferential thalamic volume to the thalamic voxel clusters identified above
  (Fig. 4c), we found that several clusters displayed strong preference to specific vM1 layers. For example, 81% of cluster
  11 preferentially projected to L2/3–5a of vM1, whereas only 0.3% projected preferentially to L5b (Supplementary Fig. 14d).

***** Markram et al 2015/ HBP (DONE)
- Juvenile rat, volume 0.29 mm3 = radius=210um * depth=2100um, ~30k cells, 8M conns, 37M syns
- Simulations reproduce an array of in vitro and in vivo experiments without parameter tuning.

- Simulating Spontaneous Activity
-- spontaneous activity due to tonic depolarization; Ca2+ concentration mediated

- Simulating Thalamic Activation of the Microcircuit
- data for the number of incoming fibers, bouton density profiles, and the numbers of synapses per connection (to layer 4)
  for the ventral posteromedial (VPM) thalamic input to the barrel region of somatosensory cortex (Constantinople & Bruno 2013)

- We predicted that each thalamic fiber innervates 903 ± 66 neurons (mean ± SD; n = 100 fibers; 775 ± 57 excitatory and 83 ±
  11 inhibitory neurons) with an average of 8.1 ± 4.2 synapses/connection.
- In total, we found that thalamic fibers form 2 million synapses in the central microcircuit ($1% of synapses across all layers~.

- avg of 1,145 +-75 syns/neuron; total 36.7M syns; 75% exc, 25% inh
- assuming 1.1 syns/um, long-range syns = 147M (~5000 syns/cell) (!= DeFelipe, 2002 (rat)=18k syns/neuron; ~=Meyer=5k spines/neuron)
- total predicted syns= 184 ± 6 million; only 20% ± 2% are local/intrinsic (consistent with Stepanyants=74% extrinsic)

***** Hirata & Castro-Alamancos, 2006 (DONE)
rat VB -> S1

- spontaneous firing rate =  2.9+. 0.7 Hz

***** Meyer et al 2010 (DONE)
rat VPM+POm -> S1

cell type; VPM boutons/neuron; POm boutons/neuron; Total dend length/neuron (um); Total spines; % VPM spines %; % POm spines
L2 pyramid; 16 ± 14; 75 ± 33; 4309 ± 1716; 2155 ± 858; 1; 3
L3 pyramid; 222 ± 131; 63 ± 16; 5947 ± 1147; 2973 ± 574; 7; 2
L4 star pyramid; 197 ± 46; 57 ± 46; 3553 ± 732; 1777 ± 366; 11; 3
L4 spiny stellate; 188 ± 60; 22 ± 10; 2549 ± 648; 1275 ± 324; 15; 2
L5 slender tufted; 150 ± 50; 269 ± 121; 5774 ± 1749; 2887 ± 874; 5; 9
L5 thick tufted;  299 ± 99; 277 ± 67; 10356 ± 1917; 5178 ± 959; 6; 5
L6A pyramid; 131 ± 66; 66 ± 42; 3908 ± 794; 1954 ± 397; 7; 3

***** Clascá et al 2012 (DONE)
- C-type neurons have a profuse arborization in cortical layers III–IV (and, to a lesser degree, upper layer VI), M-type
  neurons have a characteristic subpial arborization in layer I (and usually also in layer III or upper layer V)
- TC axons terminating mainly in layer IV may target spiny stellate neurons and apical dendrites of layer VI
neurons (Jones, 2007), whereas axons terminating in layer I may target the apical dendritic tuft of layer II, III and Vb
pyramidal neurons
***** Naka 2016 (DONE)
 Table 1: VL/PO->IT=low,high; VL/PO->PT=high,low

- PV to PC synapse in L5 is several fold larger than that of a Martinotti to PC synapse (Xiang et al., 2002; Kruglikov and
  Rudy, 2008), though this is likely partially confounded by the limited ability of somatic recordings to measure distal
  conductances
- PV-mediated somatic inhibition may impose a temporal window on synaptic integration in L5 PCs, preventing summation of
  non-coincident inputs.
- While PV neurons chiefly inhibit the soma and proximal dendrites of L5 PCs, SOM cells are thought to primarily target PC
  dendrites.

While PT cells receive and integrate input widely, they do not locally excite many other excitatory neurons, except for other
PT cells (Brown and Hestrin, 2009; Lefort et al., 2009; Harris and Shepherd, 2015; Jiang et al., 2015; Yamawaki and Shepherd,
2015). However, by harnessing the massive divergence of Martinotti cells, L5 PT cells can potentially route inhibition to a
large cohort of neurons across multiple layers. Burst firing by one or a small number of L5 PT cells might therefore
represent a ‘‘call to order’’, quieting activity throughout an entire cortical column by activating frequency dependent
disynaptic inhibition.

***** Bopp17
- 12.1% of total synapses in L4 cells come from Thalamus (core thalamus)
- no inputs to inhibitory cells
- matches current estimate: 0.75 (long) * 0.25 (thalamus) * 0.7 (laminar input) ~= 0.13
**** Cortical
***** Hooks 2013 -- see Thalamus above (DONE)
***** Hooks 2015 -- see Thalamus above (DONE)
***** Mao, 2011 (S1) (DONE)
- Most, perhaps all, L2/3 and L5A cells in the vS1 projection zone within vM1 receive input from vS1.
- Input from vS1 was strongest to L5A neurons; L2/3 neurons received similarly strong input
- many (but not all) L5B and L6 cells did not receive detectable vS1 input.
- Input to large pyramidal neurons in L5B was 7-fold weaker than input to L5A cells on average
- input to L6 was 10-fold weaker than input to L5A

sCRACM:
- L2/3 neurons received input within a single, contiguous domain, centered on the soma, approximately 50 mm above the peak of
  basal dendrite length density
- Input to L5A neurons was split into separate basal and apical domains.
- The basal domain was centered on the basal dendrites, whereas the apical domain was on the border between L1 and L2.
- When it was present, the input to L5B neurons was primarily in the basal dendrites.
- Input to L6 neurons was mainly on the proximal apical dendrites.
- Results support the conclusion that L5B cells, including PT type neurons, receive little input from vS1 compared to
  superficial vM1 neurons. (no distinction PT vs IT)

- Differences in vS1 input strength to L5B and upper layer cells (L2/3, L5A) cannot be explained by the overlap between vS1
  axons and vM1 dendrites; geometric overlap is not an accurate predictor of the strengths of functional projections (fig 8)

***** Suter 2015 (DONE)
- forelimb representation of M1 and S2
- Labeled S2 axons were also observed in more rostral and medial areas outside the forelimb M1 region and were not studied further here.

****** s2 laminar
- S2 input was strongest in layer 2/3 and decreased with cortical depth (normalized: L2/3~=2, L5A~=1, L5B~=0.8, L6~=0.5)
- S2 axons similarly innervate layer 5B neurons in M1, independent of projection class.
- S2 axons monosynaptically excite M1-CSPs, forming a basis for a long-range corticocortical -> corticospinal pathway, and
  they also monosynaptically excite S2- projecting neurons in M1, forming a basis for reciprocal coupling (i.e., a feedback
  loop) between the two areas.

- This laminar pattern of S2 -> M1 innervation resembles the innervation of mouse vibrissal M1 (medial agranular area)
  neurons by axons from both S1 (Mao et al., 2011) and sensory thalamus (PO nucleus) (Hooks et al., 2013) in that layer 2/3
  received strong inputs, but differed in that here deeper-layer neurons also re- ceived substantial input.
- S2 inputs to CSPs decreased substantially in amplitude with increasing soma depth in layer 5B (slope=-5.6) (opposite to M2 inputs to
  vM1)

- because M1 and S2 share multiple common sources of excitatory input, defects in M1 could potentially be compensated by S2, or vice versa.

L23, 1.0
L5A, 0.46
L5B, 0.35
L6, 0.20


****** s2 lateral
- S2 axons innervated a subregion of the M1-CSP territory (order of 1 mm in width; labeled CSPs were horizontally distributed over ~2 mm)

****** s2 sCRACM
- CSP inputs from S2 axons occurred mostly at perisomatic sites, with some neurons also receiving strong apical dendritic
  inputs (sCRACM);
- The lack of input to distal tufts in layer 1 was observed for CSPs at all depths

****** Thalamus sCRACM
- Thalamus (VL) -> vM1: VL provided strong perisomatic input; also innervated both the L1 distal-most apical tuft and
  proximal apical arbor (layers 4 and 5A). Input to dendrites in L2/3 was much weaker than to those
  in neighboring layers.
- Comparing the average input profiles from S2 and VL revealed a triply complementary, inter-digitating pattern; suggest that
  CSPs can integrate inputs from S2 and VL, with potential for convergence onto the same dendritic branches in the
  perisomatic but not apical subarbors.

****** M2 sCRACM
- strong perisomatic input; input to the apical tufts of CSPs in a depth- dependent manner: relative amplitude of M2 input to the
distal-most apical tuft fell as a function of soma depth
- The depth dependence of this subcellular pattern could reflect greater perisomatic input to deeper CSPs, or less input to
  their distal tufts, or a combination of both. Furthermore, decreased distal tuft input could reflect fewer or weaker
  synapses, as well as greater dendritic attenuation for deeper CSPs.

****** contra M1 sCRACM
- primarily at perisomatic sites, also proximal and mid-apical dendrite, but comparatively little in the distal tufts in layer 1.
- simialr to S2 but small upward offset location of the perisomatic input relative to the soma; appeared to increase with CSP
  soma depth (opposite of the trend for S2 inputs);

****** L2/3 sCRACM
- sampled primarily from CSPs in the upper half of layer 5B, as those in the lower half receive little or no layer 2/3 input
- similar to those arising from contralateral M1, with most of the input in the perisomatic region.

***** Zhang 2016 (DONE)
"Organization of long-range inputs and outputs of frontal cortex for top-down control"

- whole brain distribution of RV-labeled neurons presynaptic to motor areas (M1 and M2):
-- Thalamus 24.73%
--- polymodal association (12.78%)
---- dorsal: 2.51%, medial: 2.11%, anterior: 5.72%, lateral 2.0%
--- sensorimotor related = ventral: 9.35%
---- ventral-anterior lateral (VAL): 5.39%
---- ventral medial (VM): 2.17%
---- ventral posterolateral (VPL): 0.55%
---- ventral posteromedial (VPM): 1.24%

-- Isocortex: 71.54%
--- Primary somatosensory: 53.74%
---- Barrel field: 29.16%
----- L2/3: 10.26%
----- L4: 3.05%
----- L5: 13.71%
----- L6a: 1.97%
---- Lower limb: 9.09%
----- L2/3: 2.58
----- L/4: 1.28
----- L5: 3.82
----- L6a: 1.09
---- Upper limb: 8.61%
----- L2/3: 2.31
----- L/4: 0.96
----- L5: 4.33
----- L6a: 0.9
---- Trunk: 5.49%

--- Supplemental somatosensory: 2.78%
---- L2/3: 0.95%
---- L/4: 0.51
---- L5: 1.1
---- L6a: 0.22

--- Orbital: 6.49% (lateral: 6.11%)
---- L1: 0.23
---- L2/3: 3.05
---- L5: 2.08
---- L6a: 0.69

--- Agranular insular: 5.64%
--- Retrosplenail: 1.17%
--- Posterior parietal: 0.52%

-- Cortical subplate / Claustrum: 1.66%

***** Manitas 2015 (DONE)
"A top-down cortical circuit for accurate sensory perception"
- mouse S1 -> M2
- Fig S3F: % of cells from S1 that target M2, as a func of layer:
L2/3: ~53%
L4: ~10%
L5A: ~33%
L5B: 10%
L6: 100%

***** Matyas et al 2010 (DONE)
"Motor Control by Sensory Cortex"
- mouse S1 to M1
- Fig S1: approximate area of M1 = 2 x 2.5 mm (300um2 / 5,000,000 um2 = 1.8%)
- we found a high-density column of axons from S1_C2 in the M1_C2 region (colocalized representation of C2 barrel column)

***** Thomson & Lamy 2007 (DONE)
 unctional maps of neocortical local circuitry
- only local connections
***** Yamashita et al 2013, 2016 (DONE)
- in vivo mouse L2/3 S1 -> M1

2013: "Membrane Potential Dynamics of Neocortical Projection Neurons Driving Target-Specific Signals"
M1-projecting L2/3 S1 neurons:
- Spontaneous AP rate was low: 0.10 ± 0.02 Hz, n = 42
- f-I curve (low excitability); start firing I>0.3nA; 1.0nA -> ~40 Hz
- Passive Touch Responses: 1st 50 ms peak ~= 3 Hz; avg delay ~= 7ms
- Active Touch Responses: 1st 50 ms peak ~= 6 Hz

2016: "Target-specific membrane potential dynamics of neocortical projection neurons during goal-directed behavior"
- change in firing rate of M1-projecting S1 cells due to rewarded whisker-deflection ~= 4.18 Hz (avg 1st 50 ms)
- change in PSP amp of M1-projecting S1 cells due to rewarded whisker-deflection ~= 9.71 mV (avg 1st 50 ms)

***** Aronoff et al 2010 (DONE)
Long-range connectivity of mouse primary somatosensory barrel cortex

- S1->M1 delay ~= 8ms
- S1 C2 barrel intensely activates ~1mm of M1 cortex
- S1 L23 pyramidal neurons showed the densest innervation of deeper L5,6 in M1 and stopped short of the outer layer 1
- S1 L5,6 pyramidal neurons preferentially innervated the superficial layers of M1, with a prominent innervation of the most
  superficial layer 1
- It will be of great interest in future studies to examine the functional consequences of the layer-specific projections from S1 to M1.

***** Potjans & Diesmann, 2014 (DONE)

- Mouse S1 L2/3 firing rate = 0.61 Hz

- 3 external input types and the total number of external inputs to the excitatory populations
- Since long-range projections target excitatory and inhibitory neurons,we choose target specificity values for external
  inputs to be comparable with recurrent connections, resulting in similar total numbers of external inputs to inhibitory
  neurons

- Bkg rate: 8Hz
- Num ext inputs (ref): L2/3 E:1600, I:1500; L4 E:2100, I:1900; L5 E:2000, I:1900; L6 E:2900, I:2100
- Num ext inputs (layer-indep): E: 2000, I: 1850

- The ratio of local synapses (total number of synapses in our network model) and all synapses (according to the countings
  of Beaulieu and Colonnier (1985)) is 0.74, similar to the ratio reported by Binzegger et al. (2004).

**** General
***** Oh et al 2014 (DONE)
- Oh et al 2014, "A mesoscale connectome of the mouse brain"

- imaging data on interareal connectivity - down to laminar level, but not sure how to quantify
- gives injection site volume, target volume and/or density
- can potentially check target layers

mouse, quantitative projection strength from conn matrix fig 4a, sup table 3:
AMd	Anteromedial nucleus, dorsal part
AMv	Anteromedial nucleus, ventral part
PO	Posterior complex of the thalamus
VAL	Ventral anterior-lateral complex of the thalamus

MOp	Primary motor area
MOs	Secondary motor area
SSp	Primary somatosensory area

SSp-n	Primary somatosensory area, nose
SSp-bfd	Primary somatosensory area, barrel field
SSp-ll	Primary somatosensory area, lower limb
SSp-m	Primary somatosensory area, mouth
SSp-ul	Primary somatosensory area, upper limb
SSp-tr	Primary somatosensory area, trunk
SSp-un	Primary somatosensory area, unassigned

SSs	Supplemental somatosensory area

Orbital area   ORB
ORBl	Orbital area, lateral part
ORBm	Orbital area, medial part
ORBv	Orbital area, ventral part

Strength to MOp from:
AMd = 0
AMv = 0
PO = 0.696636197
VAL = 3.506696048

MOp = 0.700050385
contra MOp = 1.270528277 (why stronger than MOp?)
MOs = 0.71546543
contra MOs = 0.327831651
SSp-bfd	= 0.864803415 (use this value, since much data from vS1 and vM1)
SSp-ll	= 0
SSp-m	= 1.25797724
SSp-n	= 0.376339741
SSp-tr	= 0.450066225
SSp-ul	= 1.160082317
SSs	= 0.828155636

ORBl =	0.315953156
ORBm =	0
ORBvl =	0.362257427


***** Ben Suter notes 2013 (DONE)
- So with 10934 um of spiny dendrite, and with 1.5 spines/um length density, would have 16400 spines on this (remaining intact)
arbor.
- A VERY rough estimate of # of presynaptic cells per projection source area, would put the S2 projection at ~1/12th of
long-range total.
- Not sure how to estimate L2/3 relative to long-range, but seems substantial, so let's say S2 = 1/16th and
L2/3 = 1/8th.
- How did I arrive at 1/16th for S2? By counting the # of projection sources that I identified retrogradely (see my SfN 2012
  poster), but roughly weighting them according to size of source region: many of the bilateral ones I counted as
"1", S1 was "2", thalamus was maybe "3", etc. this was really very rough. But I arrived at S2 = 1/12th of long-range
- This is just pre-synaptic # of cells, so don't know # of synapses made! But it's a start.
- Then figure that 25% of synapses are local, 75% are long-range, and thus arrive at S2=1/16th.  But is L2/3 really
source of 50% of local excitatory synapses? Or more like 25%? Or 1/3? So range is 1/16 to 1/8th of total synapses.
- One of the papers I was looking at estimates 270 presynaptic L2/3 neurons for each (I think) lower L3 neuron.  Expect that
transfection of axons is far less than 100% efficient, though ... maybe 50-75%? This is a super rough estimate, not sure on
what I base this.

So would put 16400/16 = 1025, so let's say 1000 synapses for S2 projection, and for L2/3 between 1000-2000. Let's call it
2000 synapses. And thalamic 3000?

N_syn_s2   = 1000
N_syn_l23  = 2000
N_syn_thal = 3000

Summary:
- L2/3 = 1/2 of local * 0.25 (= local/total) * 16400 ~= 2000  (paper: 270 presyn cells -> 270 * 5 = ~1350 syns)
- S2 = 1/12 of long-range * 0.75 (= long-range/total) * 16400 ~= 1000
- thalamus = 3/12th of long-range * 0.75 (= long-range/total) * 16400 ~= 3000

***** Wall et al 2016 (DONE)

- mouse S1

- SST distribution of cells: L1=2.4%, L2/3=35.2%, L4=19.9%, L5A=26.8%, L5B=10.0%, L6=5.7%
- PV distribution of cells: L1=0%, L2/3=15.0%, L4=27.9%, L5A=29.6%, L5B=19.4%, L6=8.1%

- long-range corticocortical inputs % of total input: SST=41.0+.8.3%; PV=48.4+-6.1%
- strongest = S2, M1, S1contra
- Input neurons in S2 were found either in deep layer 3, layer 5A
- Input neurons were present in layers 2– 6 of other cortical input areas

- other long-range source of synaptic input was thalamic projection: SST=52.8+-8.8%; PV=43.8+-9.1%
- The single largest source of input to all three interneuron types arose from the ventral posteromedial nucleus of the
  thalamus (VPm), with other major input arising from the posterior nuclear group (POm)

***** DeFelipe et al 2002 (DONE)
- mouse S1
- syns/cell = 21983 (rat = 18015)
- % exc syns = 84%
- % inh syns = 16%

-- L1 exc=143438, inh=26593
-- L23 exc=15647, inh=2086
-- L4 exc=14952, inh=4524
-- L5 exc=23068, inh=4444
-- L6 exc=15561, inh=3093

- neurons/mm3 = 120315 (rat = 54468)
-- L1: 18229 ± 2915
-- L2/3: 137645 ± 6410
-- L4: 181362 ± 6142
-- L5: 77765 ± 6282
-- L6: 122092 ± 7161
(rat ~= 0.5x for each layer)

***** Schuz & Palm 1989 (DONE)
- syns/cell mouse area 6 (sensorimotor) = 7,300-7,800

***** Stepanyants et al 2009
- Radius=500um would contain 26% of the local excitatory synapses; 74% of excitatory synapses would originate from nonlocal neurons,
- Radius=250um: exc 18% local versus 82% long range; inhib 66% local, only about 34% long

***** Horvat 2016 (DONE)
- motor M1 expontentially decaying long range inputs 0-10mm
***** Yang 2013
- mouse V1
- comparison of inputs to PYR and FS
- no mention of LTS
***** Cruishank 2007
- Axons from the thalamus made stronger and more frequent excitatory connections onto inhibitory interneurons than onto
  excitatory cells.
- no mention of LTS
***** Hayut 2011
-  RS and FS neurons, but not LTS neurons in layer 4, receive thalamic input [10,15].
- There are conflicting data regarding the possibility that LTS neurons in other layers are innervated by thalamocortical
  axons (see [15,16]).
- LTS neurons in layer 3 are excited by sensory inputs during whisking [17], but these inputs could represent ascending layer
  4-to-layer 3 excitation or neuromodulatory pathways.
- Whether LTS neurons in other layers are innervated by the thalamus still remains unresolved (see [15] vs. [16,17]).

***** Cruikshank 2010

- mouse S1 ChR2 in vivo - no TC->LTS
- Low TC input to LTS (~1mV) vs FS (~20mV) vs RS (~11mV)

- We found that the TC-EPSPs in GIN cells
were much weaker than those of RS or FS cells, but similar to TC-EPSPs of LTS cells identified
by physiological criteria alone (Figures 6B, S5) (Beierlein et al., 2003). Interestingly, in
simultaneous recordings from adjacent GIN-RS or GIN-FS cell pairs, not only were the
excitatory TC responses of GIN cells weakest within the pairs, but feedforward inhibition was
also weakest in GIN cells (Figure S5B).

***** Gentet 2010
- mouse S1
- TC -> LTS (NFS) facilitating vs TC->FS depressing

***** Tan 2008 - yes LTS
- mouse S1
- 1st EPSP higher in FS; rest higher amp in LTS
- SOM decay (20 vs 10 ms), rise (4 vs 2 ms), latency (4 vs 3 ms) > than FS

***** Markram 2004
In general, inhibitory neurons form more synapses onto their target cells than excita- tory neurons do (as many as 30
synapses per target, with an average of around 15)14,15,38. Inhibitory synapses are highly distributed across the dendritic
surface of target cells and are mainly formed onto dendritic shafts.

*** implementation
- add to conn.py as dict entry for each region; read from params
- modify netpyne so can have population of netstims as cell objects; different from stim
- create pops with fixed density per region - use same dimensions but adapted, eg. only L2/3 = < yfrac

- Herc13 - neuron density in mouse M1, M2, S1, S2, Orbital

- What we need to know for each projection:
1)  Num or % of presyn cells, syns, syns/conn
2) Num or % of postsyn cell
3) Convergence, divergence or probability
4) Strength
5) Delay
6) Source firing properties
7) Source layer
8) Target layer/cell type
9) Target dendritic distribution

**** Thalamus

***** How many different populations?
-- Harris&Shepehrd (mouse/roden M1):
1) Core = Cerebellar-relaying (for S1 = VPM)
2) Matrix = BG-relaying + POm

Hooks 2013:
1) posterior = sensory = POm (+ posterior VL)
2) anterior = motor = AM, VA, VL (cerebellar+BG)

Kaneko (rat, motor areas):
1) VA/VL rostrovental = IZ = BG-relaying = matrix-like
2) VA/VL caudodorsal = EZ = Cerebellar-relaying = core-like

summary:
ThVALc = Thalamus, motor, ventro-anterior-lateral, core, Cerebellar-relaying
ThVALm = Thalamus, motor, ventro-anterior-lateral, matrix, BG-relaying
ThPOm = Thalamus, sensory, medial posterior, matrix

***** What info do we have?

1) Num or % of presyn cells, syns, syns/conn
-- *% of whole-brain presyn cells, ThVALc,m, POm? -> M1+M2 (Zhang 2016, mouse)
-- syns/con VPM -> L4(upper?) (Bruno 2006, in vivo rat S1) = 7 syns/con
-- *num and % syns Thal -> PT (Suter notes, 2013, mouse M1)
-- num presyn inputs Thal -> all layers (Potjans 2013, rat/cat S1/V1)
-- syns/conn, total syns Thal -> E,I (Markram 2015, Rat S1)  = 8.1+-4.2 syns/con
-- syns/cell, % total syns VPM+POm -> E cells L2-L6 (Meyer 2010, rat S1)
-- syns/cell (DeFelipe 2002, mouse M1) = 21983
-- syns/cell (Markram 2015/Meyer 2012, rat S1) = ~5000 (PT = ~10400)
-- syns/cell (Shuz 1989, mouse S1/M1?) = ~7500
-- syns/cell (Suter notes 2013, mouse M1 PT) = ~16400

2) Num or % of postsyn cell
-- % of cell activated VPM -> L5IT,L5PT,L6 (Constantinople, 2013, in vivo rat S1)

3) Convergence, divergence or probability
-- prob VPM -> L5IT,L5PT,L6 (Constantinople, 2013, in vivo rat S1)  = 44%
-- prob VPM -> L4(upper?) (Bruno 2006, in vivo rat S1) = 42.5%
-- conv VPM -> L4(upper?) (Bruno 2006, in vivo rat S1)
-- div Thal -> E,I (Markram 2015, Rat S1)
-- div Thal -> Cortex = 160 (OKusky Colonnier, 1982, scholarpedia models of TC system)

4) Strength
-- *relative strength of ThVAL-> PT/CT/IT(L5B,6) (Yamawaki,2015, mouse M1)
-- *relative strength to all layers (Hooks,2013, mouse M1)
-- uEPSP amp VPN-> IT5B and L5 FS/LTS (Hu, 2016, mouse S1) = 0.6 mV
-- EPSP amp VPM -> L4,L5IT,L5PT,L6 (Constantinople, 2013, in vivo rat S1) = 0.57 mV
-- EPSP amp VPM -> L4(upper?) (Bruno 2006, in vivo rat S1) = 0.95 mV

5) Delay
-- delay VB -> IT5B and L5 FS/LTS  (Hu, 2016, mouse S1)  = 2.2ms
-- delay VPN -> all E layers (Constantinople, 2013, in vivo rat S1) = 11,8,10,10,11 (range 10-30) ms

6) Source firing properties
-- firing rate Thal (Potjans 2013, rat/cat S1/V1) = 8 Hz
-- spontaenous LGN ~= 1-10 Hz (rat)
-- spontaneous VB ~= 2.9 +- 0.7 Hz (Hirata, 2006, rat)

7) Source layer
- N/A

8) Target layer/cell type
-- core vs matrix -> all E+I pops (Harris 2015, mouse M1/S1)
-- ThVALc,ThVALm -> L2/3, L4 IT, PT (Kaneko, rat M1)

9) Target dendritic distribution
-- *sCRACM ThVAL,ThPOm -> L23,L5A,L5B IT/PT (Hooks, 2013, mouse M1)
-- core vs matrix descriptive (Harris 2015, mouse M1/S1)
-- descriptive ThVALc,ThVALm -> L2/3, L4 IT, PT (Kaneko, rat M1)
-- *sCRACM VL -> PT (Suter 2015, mouse M1)

***** Steps to implement
1) Set total num of long range syns/cell:
 a) Start from Ben's estimate (dend length and 1.5 spines/um) for our M1 PT cell = ~16400
 b) Estimate num for other cell types / layers based on Markram,2015/Meyer 2012 (rat S1), scaling based on PT = 10400
 c) Make sure consistent with Shuz 1989 (~7500); not sure what to make of DeFelipe 2002 (21983) - ignore since estimate ?

2) Set num or % of Thalamic syns/cell:
 a) rat VPM,POm -> S1 % of total (Meyer, 2010b): L2: 1,3; L3pyr: 7,3; L4 pyr 11,3; L4 sp: 15,2; L5IT: 5,9; L5PT: 6,5; L6A pyr:
   7,3; avg = 7.4, 4
 b) mouse VAL,POm -> M1,M2 % of long presyn cells (Zhang, 2016): VAL = 5.39%, POm (posterior complex or mediodorsal nucleus)
   = 2% ; multiply by 75% or 80% (Suter 2013 and Markram,2015, estimates of long range conns %) = 4.3%, 1.6%; depends on
   divergence and syns/conn -- not so useful!
 c) Thal -> mouse M1 PT (Suter notes 2013): 3/12th (counting spines) * 0.75 (= long-range/total) = 18% (* 16400 ~= 3000 syns)
 d) VAl, POm -> mouse M1 (Hooks 2013): overall similar level for sensory vs motor (not sure if valid comparison or normalized, fig 5)
 e) Thal -> L4 S1 rat (Bruno 2006): ~15% of tot syns; prob=43%, conv=85 conns; syns/conn=7;
 f) assume 1/3 of each type ->  since PT only TVAL = 20% -> TVALc=10% TVALm=10% TPOm=10%
 g) local vs long exc = 20-80% (Markram 2015; Stepanyants 2009); 25-75% (Suter 2013); inh = ~70-30% (Stepanyants 2009)
   exc vs inh = 84/16% (DeFelipe, 2002); 75/25% (Markram, 2015) --> 80%-20%
   long = 0.8 (exc) * 0.8 (long exc) + 0.2 (inh) * 0.3 (long inh) = 0.7

- had to choose between normalizing across inputs to cell, or across layers:
inputs to cell: fixed thalamic % (eg 18); if only core, then 18% inputs from core; if core+thalamus then 9%+9%=18%; can't
keep proportions in Hooks 2013
layers: fixed % for each input (eg. 6, 6, 6%); if only core the 6% inputs; if core+thalamus then 12%

- strength of input = number of inputs per cell? number of cells innervated? -- Hooks 2013 is relative strength, so num
  inputs per cell
- need absolute number of inputs instead of % so response comparable?! probably not since effect of inputs will depend on
  total dendritic length which is proportional to num syns/cell


3) Distribute differentially based on presyn (ThVALc, ThVALm, ThPOm) and postsyn (layer, cell type):
 a) assume % of each Thal inputs calculated above is max (normalized value = 1); eg. ThVALc=10%, ThVALm=10%, ThPOm=10%
 b) adjust based on Hooks 2013
 c) Core vs matrix:

4) Distribute syns/cell based on dendritic distribution (Hooks, 2013; Suter, 2015; Harris 2015; Kaneko)

Harris & Shepherd, 2015:
rough distinction in M1

L23 IT - "Matrix (L2+L3) + Core (only L3) Thal L1 apical"
L4 IT - "Core Thal perisomatic"
L5A/B IT - "Matrix Thal (L1 apical+basal) Core Thal (perisomatic)"
L5B PT - Core Thal (basal); no matrix?
L6 - no thalamic input

Kaneko, 2013 (rat M1):
L23 - IZ input; L1 dendrites (54% IZ axons)
L3d/4 - EZ input; L3/L4 dendrites
L5B PT - "IZ input; L1 dendrites (54% IZ axons); EZ input; L3/L4 dendrites"

Clasca et al 2012 (rodent core vs matrix Thalamus -> Cortex):
Core axons - L3+4, some L6; (L4 may correspond to cells in L4,6)
Matrix axons - L1, L3, L5; (L1 may correspond to L2,3,5B neurons)

Hooks 2013:
no clear laminar distinction for core vs matrix inputs

Yamawaki 2015:
no distinction

Harris Shepherd 2015:
not clear beyond S1

Kaneko 2013:
clear differentiation

L2/3 IT = Matrix (Harris+Kaneko)
L3 low / L4 = Core (Harris+Kaneko)
L5A/B IT = matrix + core (Harris, Hooks 2013)
L5B PT = Core (Harris); Core+Matrix (Kaneko)
L6 = no

- Long range thalamic inputs to PV vs SOM
-- Harris & Shepherd: only Th -> PV
-- Hu & Agmon 2016: Th -> SOM 2x amp Th -> PV
-- Wall 2016: SST long range Th (VPm,POm) inputs = 52.8%; PV long range TH inputs = 43.8%  (low input from VL to S1)
-- Cruikshank 2010: mouse S1 ChR2 in vivo - Low TC input to LTS (~1mV) vs FS (~20mV) vs RS (~11mV)
-- Gentet 2010: mouse S1 TC->LTS (NFS) facilitating vs TC->FS depressing
-- Tan 2008: mouse S1 TC-> 1st EPSP higher in FS; rest higher amp in LTS; LTS decay (20 vs 10 ms), rise (4 vs 2 ms), latency (4 vs 3 ms) > than FS

***** adapt based on gmgs email (some simplifications)
- focus on mouse forelimb M1
- VL (core) -> IT4 (Yamawaki elife), PT5B and IT5B (yamawaki JNS), with the PTs getting input to tufts (suter); some axons in
  L1, but does mainly innervate L4 and L5B
- PO (matrix) -> IT3/IT4/IT5A (yamawaki elife);  with axons to L1 and L5A
- ignore VA (core) and VM (matrix)

Naka16 confirms in Table 1: VL/PO->IT=low,high; VL/PO->PT=high,low

**** S1
- % of input/syns for each layer
-- gmgs: most from IT
-- Hooks 2013/Mao 2011 (vS1->vM1): L2/3, L5A, minor from deep
-- Manita 2015 (S1 paws->M2): % of cells from S1 that target M2: L2/3: ~53%, L4: ~10%, L5A: ~33%, L5B: 10%, L6: 100%
-- Zhang 2016 (S1->M1/M2): % of presyn cells:
--- Barrel field: 29.16% = L2/3: 10.26%, L4: 3.05%, L5: 13.71%, L6a: 1.97%
--- Lower limb: 9.09% = L2/3: 2.58%, L/4: 1.28%, L5: 3.82%, L6a: 1.09
--- Upper limb: 8.61% = L2/3: 2.31%, L/4: 0.96%, L5: 4.33%, L6a: 0.9%
-- Aronoff 2010 (S1->M1): L5,L6 (to L23/4); L2/3
-- conclusion: mostly L2/3,5A -- combine into single S1 region with 15% of syns

- % target layers
-- Hooks 2013/Mao 2011 (vS1->vM1): L23=L5A=strong (most/all cells receive input); L5B 7x weaker; L6 10x weaker (many no
input): L23, 0.7, L5A, 1.0, L5B, 0.14, L6, 0.1
-- Hooks 2013: similar to sensory thalamus (PO): L23, 0.81, L5A, 0.99, L5B, 0.13, L6, 0.012
-- Harris & Sheperd 2015: L23,L4,L5A/B, FS
-- Aronoff 2010 (mouse S1->M1): L23/L4; L5-L6

**** S2
- % of input: 0.83 (Oh 2014, norm strength); ~1/12th long-range syns (Suter 2013 notes) --> ~10%
- % target layers:
-- Suter 2015: divide L5B into 3 sublayers with decreasing
L23=1.0, L5A=0.46, L5B=0.35, L6=0.20; in L5B decreases with slope=-5.6 (Suter 2015)
divide L5B into 3 bins and calculate strength of each bin based on slope
bins: (0.77-0.52)/3 = 0.083 -> [0.52, 0.603], [0.603, 0.687], [0.687, 0.77]
values: x=0.645, y=0.35; slope = -5.6*0.35 (rescaled) = 1.96
-> x=0.5615, y=0.35 + (-0.083)*-1.96 = 0.35+0.1626 = 0.51;
-> x=0.7285, y=0.35 + (+0.083)*-1.96 = 0.35+0.1626 = 0.189;
use values from L5A (0.46 and 0.20) and L6 since consistent with calculated ones.
 Also add layer 4 as subset of L5A

**** M2 and contraM1
- Hooks 2013 (M2->vM1); use same for M2
L23, 0.17
L5A, 0.11
L5B, 1.0
L6, 0.44

-- Significantly greater excitation to the deeper half of L5B

**** How to increase netstims firing rate
1) NSLOC - rename to NetStimVarRate -- use vec.play to set the rate at different time points ( arbitrary patterns - use shapestim)
2) VecStims - need to generate all (random) spike trains before hand - faster? (arbitrary pattern - use shapestim)
3) NetStim -> NetStim - does this work to generate extra events? turns on/off? (can only do 1 block?)
4) 2 NetStims per long-range input: 1 for background, 1 for signal (can only do 1 block)

***** implemented option 2:
# VecStim - generate spike vector based on params
        if self.tags['cellModel'] == 'VecStim':
            # seed
            if 'seed' not in self.params:
                self.params['seed'] = sim.cfg.seeds['stim']

            # interval
            if 'interval' in self.params:
                interval = self.params['interval']
            else:
                return

            # set start and noise params
            start = self.params['start'] if 'start' in self.params else 0.0
            noise = self.params['noise'] if 'noise' in self.params else 0.0

            # fixed interval of duration (1 - noise)*interval plus a
            fixedInterval = np.full((sim.cfg.duration/interval), [(1.0-noise)*interval])

            # randomize the first spike so on average it occurs at start + noise*interval
            # invl = (1. - noise)*mean + noise*mean*erand() - interval*(1. - noise)
            if noise == 0.0:
                vec = h.Vector(len(fixedInterval))
                spkTimes =  np.cumsum(fixedInterval) + (start - interval)
            else:
                # negexp interval of mean duration noise*interval. Note that the most likely negexp interval has duration 0.
                rand = h.Random()
                rand.Random123(self.gid, sim.id32('%d'%(self.params['seed'])))
                vec = h.Vector(len(fixedInterval))
                rand.negexp(noise*interval)
                vec.setrand(rand)
                negexpInterval = np.array(vec)
                spkTimes = start + np.cumsum(fixedInterval + negexpInterval) + (start - interval*(1-noise))

            self.hPointp.play(vec.from_python(spkTimes))

***** speed comparison
netParams.popParams['artifNet'] = {'cellModel': 'NetStim', 'numCells': 20000, 'interval': 100, 'noise': 0.5, 'start': 50}

  Number of cells on node 0: 20000
  Done; cell creation time = 0.78 s.
  Done; run time = 0.44 s; real-time ratio: 2.25.
  Spikes: 192388 (9.62 Hz)

netParams.popParams['artifNet'] = {'cellModel': 'VecStim', 'numCells': 20000, 'interval': 100, 'noise': 0.5, 'start': 50}

  Number of cells on node 0: 20000
  Done; cell creation time = 2.27 s.
  Done; run time = 0.34 s; real-time ratio: 2.95.
  Spikes: 191674 (9.58 Hz)



**** DONE plot cmat matrices
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170104_122257.png][fig]]
**** DONE plot num of syns/cell as func of pre and post cell type
- similar to Bezaire

*** open questions
**** email to gordon on core vs matrix
Hi Gordon,

Thanks for the refs. I have a question regarding core vs matrix thalamic inputs. My understanding from several papers is we should have these 3 thalamic inputs to M1:

1) motor-related core: VA/VL/AM, cerebellar-relaying; target mainly perisomatic dendrites of L4,5A,5B cells
2) motor-related matrix: VA/VL/AM, basal ganglia-relaying; target mainly L1 dendrites of L2/3,5A,5B cells
3) sensory-related matrix: POm, target mainly L1 dendrites of L2/3,4, 5A cells

I have quantitative data on the target laminar and dendritic distributions (Yamawaki,2015; Hooks,2013; Suter,2015), although these don't make distinction between motor thalamus core vs matrix.

Harris & Shepherd 2015 mentions there is a "rough core/matrix organization" in M1, and shows PT cells only receive core inputs (figs 2+4). However, Kaneko 2013 (rat M1) emphasizes PT cells also receive matrix inputs via L1 dendrites (eg. fig 6b). I'm guessing the discrepancy is due to S1 vs M1 or mouse vs rat.

Does it make sense to include the core vs matrix distinction in our mouse M1 model? If so, would PT cells receive thalamic matrix inputs?

Bill suggested we could have a call at the beginning of January.

Thanks
Salva

**** 16dec20 response from gordon with data on Thal->M1 inputs
For mouse (forelimb) M1, I would mainly go with what's in the Yamawaki papers plus Ben's; basically:

VL --> L4 pyr (Yamawaki elife) and 5B PT and IT (yamawaki JNS), with the PTs getting input to tufts (suter)

VA is small and indistinct in the mouse; can ignore for M1 model IMO

PO --> upper layers, mainly 3/4/5A, according to yamawaki elife laminar profile

VL is core-ish; doesn't fit perfectly with core pattern because there are some axons in L1, but does mainly innervate L4 and L5B

PO is matrix, with axons to L1 and L5A

VM is matrix, with axons mainly to L1 (but some in 5A-ish), but only has weak projections to M1; projects mainly to anterior
frontal areas; can ignore for M1 model IMO

Kaneko -- it's all anatomical projections, right? not connectivity. Where it's been looked at (yamawaki; petreanu; hooks), PO
projections (defined as having L1 pattern, with or without the L5A band) have not been found to much input at all to PTs. But
we do see an exception to this for VM inputs to PTs in anterior frontal cortex (area ALM).

The things that stand out about the M1 thalamo-cortico-thalamic circuits compared to S1 (and other sensory) is the LACK of
monosynaptic contacts between TC axons and CT dendrites, and between CT axons and TC dendrites -- i.e., it's not a "closed"
loop. IMO, this is the kind of first-order difference that could be explored in models and should give striking results, no?

The big picture for the M1 T-C-T circuits, IMO, is that there's no "tight" or closed loop; instead, activity flows necessary
via multiple cell types in the cortex -- i.e., TC inputs to IT and PT, ending up at CT via local circuits -- and multiple
nuclei in thalamus -- at a minimum, VL and PO and, I hate to say it, RTN, which complicates everything of course.

Hopefully that's more helpful than confusing ...

-Gordon



**** Thalamic input to LTS?
-- Harris & Shepherd: only Th -> PV
-- Hu & Agmon 2016: Th -> SOM 2x amp Th -> PV
-- Wall 2016: SST long range Th (VPm,POm) inputs = 52.8%; PV long range TH inputs = 43.8%  (low input from VL to S1)
-- Cruikshank 2010: mouse S1 ChR2 in vivo - Low TC input to LTS (~1mV) vs FS (~20mV) vs RS (~11mV)
-- Gentet 2010: mouse S1 TC->LTS (NFS) facilitating vs TC->FS depressing
-- Tan 2008: mouse S1 TC-> 1st EPSP higher in FS; rest higher amp in LTS; LTS decay (20 vs 10 ms), rise (4 vs 2 ms), latency (4 vs 3 ms) > than FS

** DONE Methods: PV and SOM cells
*** fI curves dont look so good
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170124_120918.png][fig]]
samn [12:04 PM]
probably not ideal ... thought PV should be more excitable? but haven't checked / optimized to experimental FI curves

salvadord [12:05 PM]
y I thought PV would have higher rates too… and LTS have lower threshold maybe? so where are these cells taken from?

samn [12:05 PM]
PV was basket cell originally from hippocampal model - probably had some changes to it since then

[12:06]
LTS was also hippocampal but then put in channels from other neocortical models for LTS cells
*** from neuroelectro
Basket cell (=FS=PV): rheobase=222.53 pA, FI slope=406.19 Hz/nA  (http://www.neuroelectro.org/neuron/99/)
Martinotti cell (=LTS=SOM): rheobase=67.66 pA, FI slope=151.35 Hz/nA  (http://www.neuroelectro.org/neuron/98/)

*** modeldb
a bunch of them in modeldb for FS: https://senselab.med.yale.edu/modeldb/ModelList.cshtml?id=97753 ; and LTS:
https://senselab.med.yale.edu/ModelDB/ModelList.cshtml?id=142232

**** FS15 and LTS15 - Engaging distinct oscillatory neocortical circuits (Vierling-Claassen et al. 2010)
- FS and LTS matched to FI curves
- 15 compartments each!

**** FS1 good! als LTS byt pyramidal - Hodgkin-Huxley models of different classes of cortical neurons (Pospischil et al. 2008)
https://senselab.med.yale.edu/modeldb/ShowModel.cshtml?model=123623&file=/PospischilEtAl2008/sIN_template#tabs-2

	One compartment model and currents derived from:

   Pospischil, M., Toledo-Rodriguez, M., Monier, C., Piwkowska, Z.,
   Bal, T., Fregnac, Y., Markram, H. and Destexhe, A.
   Minimal Hodgkin-Huxley type models for different classes of
   cortical and thalamic neurons.
   Biological Cybernetics 99: 427-441, 2008.

	- one compartment model
	- passive
	- HH: Traub

- FI curve : http://cns.iaf.cnrs-gif.fr/files/Lausanne2008.pdf fig 3,4

- added to central repo as FS1.py

**** LTS - Parametric computation and persistent gamma in a cortical model (Chambers et al. 2012)
many compartments! - from traub

**** LTS3 good (also FS3) - Pyramidal neuron, fast, regular, and irregular spiking interneurons (Konstantoudaki et al 2014)
https://senselab.med.yale.edu/ModelDB/ShowModel.cshtml?model=168310&file=/KonstantoudakiEtAl2014/experiment/cb.hoc#tabs-2
- 3 compartments
//Interneuron for PFC - Calbindin/LTS interneuron
//Written 25-10-2007 by Xenia Konstantoudaki

good FI curve: Fig 3B: http://journal.frontiersin.org/article/10.3389/fncir.2014.00007/full

model is calbindin, not somatostatin -- 99% of cortical interneurons are Htr3a,Pvalb, Sst (Harris 2015); but there can be
overlap between somatostatin and calbindin interneurons

*** sam old friesen
have some in /u/samn/vcsim - friesen type

[12:32]
but didn't optimize against those FI data either ... was based on previous kimberle jakobs model

*** bill 1991 paper
had these in my 1991 paper -- can use those with bg.inc

*** modifying FS3 and SOM3
- FS16 and SOM16 have better match to neuroelectro, but 7x slower
- FS3 and SOM3 rates too high because tuned for 23ºC not 34ºC
-- check if can lower by lowering hoc temp before running tuning, or by modifying some params - Ra, L, diam?

- base rates: PV3: 118, SOM3: 100 Hz (34º, 0.3nA)

- lowering hoc temp to 23º - increases rates by 2 Hz
- lowering netpyne temp to 23º - decreases to 96, 88 Hz
soma:
- L*4 - 0, 25Hz
- L*2 - 10,59 Hz
- L*1.5 - 76,75
- L*1.2 - 104, 89
- diam*1.2 - 104, 89
- Ra*1.2 - 118,100
- nafin, nafcb * 0.9 - 114, 99
- nafin, nafcb * 0.75 - 106, 97
- kap*0.5 - 129,99

dend:
- L*1.5 - 97,98
- L*1.2 - 111, 100
- cm*1.2 - 118,100
- Ra *1.2 - 118,100

axon:
- L * 0.5 - 88,98 ; 167, 132 (0.5nA)
- L * 0.01 - 0,80 Hz

*** final choice
- PV3 with dend L * 2.0 (44 um): rheobase =~250 pA; fi Slope = decreasing from  700 to 100 Hz/nA
- SOM3 with dend L * 8.0 (176 um): rheobase =~50pA; fi slope ~=180 Hz/nA

- checked and also consistent with Izhi FS and LTS

*** spontaneous firing rates in vivo (Urba16)
L2/3 of S1
In vivo, anaesthetized
0
52
L2/3 of V1
In vivo, anaesthetized
1.3 ± 0.5
49
L2/3 of V1
In vivo, anaesthetized
2.7 ± 0.4
51
L2/3 of S1
In vivo, quiet awake
6.3 ± 0.6 (0–15)
52
L2/3 of S1
In vivo, whisking in air
2.1 ± 0.4
52
L2/3 of S1
In vivo, with whisker touch
1.7 ± 0.9
52
L2/3 of V1
In vivo, awake
7.2±8
53
L2/3 of V1
In vivo, awake
7±2
51
L2/3 of V1
In vivo, running
11.6 ± 10.8
53
L2/3 of V1
In vivo, awake, visual stimuli
26±2

** DONE Methods: Convert single unitary weights to multiple synaptic weights
*** Method from Bezaire, 2016
To determine the synaptic weights and kinetics for those connections that have not yet been experimentally characterized, we
used a novel modeling strategy we call Network Clamp, described in Bezaire et al. (2016). As experimental paired recording
data were not available to directly constrain the synapse properties, we instead constrained the firing rate of the cell in
the context of the in vivo network, for which experimental data have been published. We innervated the cell with the
connections it was expected to receive in vivo, and then sent artificial spike trains through those connections, ensuring
that the properties of the spike trains matched the behavior expected from each cell in vivo during theta (firing rate, level
of theta modulation, preferred theta firing phase). Next, we adjusted the weight of the afferent excitatory synapses onto the
cell (starting from experimentally observed values for other connections involving that cell type) until the cell achieved a
realistic firing rate similar to had been experimentally observed in vivo.

*** Beha12 - effect of location/syn efficiency
We used two-photon uncaging to show that efficacy decreases with distance from the soma in L2 pyramidal neurons. Because MD
inputs target the more distal dendrites, their influence on the somatic potential could be diminished. However, these same
experiments also demonstrate that efficacy correlates with spine head volume in these neurons. Because MD inputs also connect
with larger spines, their influence at the soma is ultimately restored. Indeed, the unitary EPSPs predicted for MD, cmPFC,
BLA and VH inputs are equivalent and closely match the average response expected for all spines. Moreover, this alignment is
perturbed when either level of subcellular targeting is not included in the predictions. This unexpected reciprocal
relationship between spine morphology and location allows diverse long-range excitatory inputs to influence L2 pyramidal
neurons.
*** Neuro book 2008: "Synaptic Conductances in Dendrites Tend to Interact Nonlinearly"
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170301_112854.png][fig]]
*** Once all syns distributed ensure soma EPSP mV match weight value?
- unfeasible to do for all connections
- find some patterns for the different cell types?
- stim all cell segments and obtain EPSP mV in soma --> calculate weight factor for each segment (relative to soma?)
- assume independence of each synapse contribution
- when distributing synapses, scale each one by factor
- store weight scaling factor within cellrule of each cell type
- provide netpyne function to calcualate this (option during importCell func?)
- alternatively, do the same but within network -- consider interactions with all other bkg inputs?
*** include demonstration of why needed
- PT cell with inputs from 3 other cells
- Fix weights and compare 1) single synapse at soma, 2) single synapse at random locs, 3) multiple synapse at random locs
- We know unitary connection (including ~5 synapes gen
- see Mage00

*** tuft dendrites generate spikes
- weights that generate small epsps in other sections (including soma) generate spikes in tuft
- in soma this corresponds to either very small epsps or very high -- abrupt change

- srdjan: level of input? doesnt reach soma? abortive amplitude? ~45 mV
- na conductance: AIS = 5000 pS/um2, soma = 200 pS/um2, dendrite = 70 pS/um2 (linear fall off, randomness)
- Larkum model for apicals? Antic paper?
- can compensate by changing params in Axon

*** chat with bill/sam on tuft spikes
salvadord [8:01 PM]
so identical input generates 10x stronger somatic response if placed at tuft vs soma — feature or bug?

[8:06]
(this is without the ca hot zones)

samn [8:24 PM]
interesting...

billl [8:24 PM]
will have much higher Rin at soma

[8:25]
so same thing that srdjan talks about in the basilar dends -- input at end vs not end

salvadord [8:29 PM]
but here only happens for tufts; other dends don’t generate dend spike (so lead to smaller somatic epsp)

samn [8:29 PM]
not sure there should be anything special about tufts - other than small size at distal locations?

billl [8:29 PM]
identical input in terms of conductance?

[8:30]
small also leads to high Rin

salvadord [8:30 PM]
yeah its a NetStim with identical weight + synapse — only changed location

[8:30]
single spike

samn [8:30 PM]
is that for small/thin tufts?

[8:30]
once get past nexus, hcn chan density is flat

salvadord [8:31 PM]
I tried in random secs of 4 different tuft branches

samn [8:31 PM]
so that shouldn't be contributing factor...

[8:31]
what's diam of those

billl [8:31 PM]
how's it look with passive dends?

salvadord [8:31 PM]
I’m setting up batch sim to run in all segments and check if just tufts

samn [8:31 PM]
also seemed like all or nothing response? or is that due to very diff magnitudes?

salvadord [8:32 PM]
y all or nothing — not so diff weights, same as used for soma, which produces gradual increase in epsp amp

samn [8:32 PM]
netstim is using alpha synapse?

billl [8:32 PM]
alpha is an i syn

salvadord [8:33 PM]
passive dends - 1st graph above shows for soma, basal, maintrunk, uppertrunk and tuft — not sure exactly which are passive

billl [8:33 PM]
we only use g syns i think

salvadord [8:33 PM]
netstim using same AMPA syn as in net

samn [8:33 PM]
ampa, ic

billl [8:33 PM]
thats and exp2syn?

samn [8:33 PM]
none are passive by default

billl [8:33 PM]
could check it with passive to see if was all Rin effects or more active stuff

salvadord [8:34 PM]
its active stuff since in tuft generates dend spike

billl [8:34 PM]
mcgee has results about distance noralization -- does this look like his results?

salvadord [8:34 PM]
thats why all or nothing

[8:34]
mcgee — I’ll check

billl [8:35 PM]
also * jnphys82:3268.pdf  /u/billl/articles/jnphys82:3268.pdf
 author =    "Jaffe, DB and Carnevale, NT",
 title =    "Passive normalization of synaptic integration influenced by dendritic   architecture",

salvadord [8:35 PM]
thx!

billl [8:35 PM]
maybe i was thinking of this one -- /u/billl/articles/jnsci24:11046.pdf  On the Initiation and Propagation of Dendritic Spikes in CA1 Pyramidal Neurons

[8:36]
nope this one -- Somatic EPSP amplitude is independent of synapse location in hippocampal pyramidal neurons  /u/billl/articles/natnsci3:895.pdf

salvadord [8:36 PM]
I’d looked through Ted’s paper, but not the others, thx

[8:37]
also checked the Hay 2011 PT paper, but didn’t find specific mention of whether tuft generates dend spikes at low thresh

billl [8:38 PM]
perhps have a lot of ffwd inhib in L1 so might be hard to elicit wihtout blocking

[8:38]
oh how about srdjan's papers abotu activating apicals

[8:40]
graph some traces -- be easier to see and could show to srdjan tomorrow

salvadord [8:40 PM]
sure

billl [8:41 PM]
from grant: "The Antic lab has existing data on plateau potentials in the apical tufts, and we will incorporate these data into future models.  Higher cortical areas project into L1, activating these tufts (and inhibiting via feedforward inhibition), as well as into infragranular layers L5, L6.  Therefore the interactions of these inputs in terms of producing the \epl\ activated ensemble will be of great interest."

[8:43]
he has something in a paper about the activation in the apical tufts as not being reproducibel -- 1 time 1 thread goes off and another time anothe rone
samn [9:13 PM
ok, so it is a real spike

[9:13]
but response in soma is not 0, just much smaller when no spike in tuft

billl [9:13 PM]
spike in tuft? -- Na chans?

samn [9:14 PM]
there's na there

[9:14]
should be much higher in soma

salvadord [9:15 PM]
@ much smaller - y, 0.1 mV vs 20mV for a small change in weight

[9:17]
In [4]: c.secs.apic_56.mechs.nax
Out[4]: {gbar: 0.0153130368342, sh: 0.0}

In [5]: c.secs.soma.mechs.nax
Out[5]: {gbar: 0.0153130368342, sh: 0.0}

samn [9:18 PM]
that seems wrong

billl [9:18 PM]
those are same numbers

samn [9:19 PM]
yeah

[9:19]
ah, sorry

[9:19]
axon has higher nax density in the full model

[9:20]
>>>cell.axon(0.5).gbar_nax
cell.axon(0.5).gbar_nax
0.076565184171
>>> cell.apic[56](0.5).gbar_nax
cell.apic[56](0.5).gbar_nax
0.0153130368342
>>>
salvadord [9:20 PM]
y identical nax gbar in all secs except axon

billl [9:20 PM]
so same everywhere

samn [9:21 PM]
except axon

billl [9:21 PM]
why so much naf in dend?

samn [9:21 PM]
those are the rules we spec'ed out with ben; could revise

billl [9:21 PM]
recall where/how he came up with this?

samn [9:21 PM]
axon has larger in original model and in subsequent

[9:21]
have to check his ref

[9:22]
prob like that in many detailed models - if axon hillock initiates the AP

billl [9:22 PM]
will be good to show srdjan tomorrow and get his input anyway

[9:22]
high axon makes sense but not sure why so high in dends

[9:22]
seems liek many models have no naf in dends

samn [9:22 PM]
i think some models have tapering na with distance from soma

billl [9:23 PM]
or that

samn [9:23 PM]
but he thought that rule didn't have a good basis

[9:23]
think larkum or stuart models have that rule

[9:23]
and opposite for k - increasing

billl [9:24 PM]
larkum, stuart, magee are good sources

samn [9:27 PM]
suppose can revise model

salvadord [9:28 PM]
in Hay paper Na much lower in apical (100 vs 20k pS/um2)

billl [9:28 PM]
that seems more reasonable

salvadord [9:29 PM]
and seems like no Na in basal

samn [9:33 PM]
want new rules?

salvadord [9:35 PM]
I think would be good since otherwise network activity might be messed up

[9:35]
can check what antic thinks tomorrow

billl [9:35 PM]
in any case generally don't want a single syn anywhere to cause a spike but i guess we said other day that a single syn for us might represent 7-20 syns

samn [9:36 PM]
ok, will look at revising rule tomorrow and see if impacts dynamics under somatic current clamp substantially

salvadord [9:36 PM]
in reduced models yeah, but for detailed cell model I’m trying to keep more realistic, ~1 syn=1 syn (a la Soltesz, Allen or HBP)

[9:37]
@revising - thanks

billl [9:38 PM]
we discussed other day but i don't think 1syn==1syn is very practical but i suppose if ivan can do it then we can give it a try :)

salvadord [9:39 PM]
y, if seems unfeasible can switch to 1, but his model had 300k cells and 2B syns; ours only 10k cell and ~60M syns, so
hopefully doable
*** figs
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170109_214745.png][fig]]
*** refs
- Gasp04
-- 50 synaptic inputs spread over 100m of the apical trunk/tuft need to be activated within 3 msec.
-- Dendritic spikes are characterized by a more depolarized voltage threshold than at the soma

- Mage00 - synapse location normalization!!
-- Most neurons receive thousands of synaptic inputs onto widely spread dendrites. Because of dendritic filtering, distant
synapses should have less efficacy than proximal ones. To investigate this, we characterized the amplitude and kinetics of
excitatory synaptic input across the apical dendrites of CA1 pyramidal neurons using dual whole-cell recordings. We found
that dendritic EPSP amplitude increases with distance from the soma, counterbalancing the filtering effects of the dendrites
and reducing the location dependence of somatic EPSP amplitude. Dendritic current injections and a multi-compartmental
computer model demonstrated that dendritic membrane properties have only a minor role in elevating the local EPSP. Instead a
progressive increase in synaptic conductance seems to be primarily responsible for normalizing the amplitudes of individual
inputs.

- Zhou15

-Beha12 (see above)

- Spru08

- Mage00

*** implementation
- check better weight range -- maybe aim for 0.1 mV (since 5 syns per unitary conn)
- other simpler method is to test 1 single weight for all segs, and then scale weight by epsp factor

- run for PT,IT (full+reduced) with ca hotspots and reduced dend Na
- for all segments
- use single spike to colocalized NMDA and AMPA syns (test also GABAA ? )
- Run on 'my' if free, or 'ma' (although many 10 sec jobs, maybe not worth?)
- Store normalizing factor for each section as a list (1 element per segment)
- Update cellParams to include factor for each section
- Do not update each cell instance to save space (generalize this to all cell props -- by ref!)
-- pointer to cellParams dicts?
- When setting weights (conn and subconn) multiply by factor of segment
- Update general scaleConnWeightModels to values obtained for 0.5mV
- Actually set scaleConnWeightModels to 1, and use weightNorm from each cell section
- use interp1d to get weight value for epsp of 0.5 mV (weightNorm = weightReal / weightDesired eg. = 0.00032 / 0.5 = 0.00064)
- ie. w_epsp * weightNorm = w_syn; multiplication factor to obtain the w_syn required to generate somatic epsp of w_epsps mV
- assuming single synapse; for multiple synapses assume additive (rough estimate)
- multiply weight by weightNorm during addConn; in subConn if syn moves, divide by old (to get orig w) and multiply by new

- note: 0.00032 uohms = 1/0.00032 /1e3 = 3.12 nS (~5 synapses) -> 1 synapse = 0.62 nS
- consistent with somatic EPSP for an excitatory synapse of fixed synaptic conductance (0.3 nS), produces soma EPSP of
  0.2-0.3 mV (Spruston 2008, Nature)
- syn weight (nS) ~= soma epsp (mV)

Increases in synaptic conductances can compensate for the reduced somatic impact of distal synapses. This mechanism has
limits, however, as increasing synaptic conductance also increases the local voltage change, further reducing the driving
force and increasing the likelihood of generating local dendritic spikes.

- significant variation within section, so calculating weightNorm on a per segment level

** DONE Methods: Synaptic distributions (including I->E and I->I)
*** requirements per cell model
- HH_full - 5 syns/cell, detailed syn distribution
- HH_reduced - 5 or 1 syns/cell, broad distribution over 5 compartments
- HH_simple (all I) - 1 syns/cell, no distribution

*** Long -> E/I
- TVL, TPO, M2, OC -> E (L2/3, L5A, L5B, L6) (Hooks 2013)
-- can't use scracm
-- make general rule based on line plots, derived from L2/3->PT; yfrac correction factor
-- scale based on electrotonic factor: avg weight scale across x for each y bin

- TVL, M2, cM1, M2, S2 -> L5B PT (Suter 2015)
-- get scracm from Ben
-- make sure Thalamus-S2 match Fig 6c

- missing use similar region

*** E -> E
- L2/3 -> PT (Suter 2015)
-- have scracm
-- use same for L4,L5A -> PT?

- rest use uniform distribution over spiny

*** I->E
**** Katz11
- (I->E) Katzel 11 Nat neu has source conn densities/distribution across layers for I->E (+ relative densities of cell types)
-- Katzel: L2/3 post = 76.5% (L2/3), 16.5% (L5), 0% (L6)
           L5 post = 1.5% (L2/3), 87% (L5), 10% (L6)
	   (L5B has 23.8% from L6)
	   L6 post = 0.3% (L2/3), 2.2% (L5), 97.5% (L6)
**** Naka16
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161206_184711.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20161206_184855.png][fig]]

- PV -> IT/PT = perisomatic
- SOM -> IT/PT = apical dendrites

*** DONE create perisomatic 1d profile, or make 'perisom' secList
- center at 1000
- create gaussian decaying around around soma

or

- 'perisom' secList = soma + proximal basal
- make function to calculate syns within a range -- part of netParams to create secLists

*** TODO wait for Ben sCRACM
*** DONE adapt Suter15 and Hooks13 based on electrotonic weight scaling
- check if PT cell syn density map can be obtained by multiplying 1d sCRACM by avg weightNorm and dend density of each region
- scracm = syn density * weightNorm * dend density (assume constant weight?)
- need statistical/avg data on dend density for each cell type as a func of depth:
-- for L5 PT, ITs can calculate based on cell models
-- L4 IT from Yamawaki
-- L2/3 ?
-- L6 ?

- uhoh is weightNorm incompatible with sCRACM method?!
- when placing syns should take into account weightNorm?

- to extract syn density from scracm:
option 1:
-- divide by avg dend density and weightNorm for each pixel
-- that gives relative syn density (distribution), assuming identical syn weights
-- distribute syns taking into account weightNorm

option 2:
-- divide by avg density
-- gives relative syn density (distribution), assuming identical soma epsps
-- distribute syns with weights multiplied by weightNorm (to comply with above assumption of identical soma epsps)

**** test with L2/3->PT cell
- check if PT cell syn density map can be obtained by multiplying 1d sCRACM by avg weightNorm and dend density of each region
- scracm = syn density (syns / dend um) * weightNorm (strength / syn to reach 0.5mV in soma) * dend length (dend um) (assume constant weight?)
-- scracm: we have
-- syn density: variable to resolve for; = scracm/(weightNorm*dendDensity)
-- weightNorm: we have
-- dend density: we have

- since scracm is low; dendL avg -> if syn density high, then weight low; if weight low then syn density high;
-- in PT cell assumed weights were identical, and scracm difference accounted by dendL + syn density (so don't include wnorm)
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170214_233108.png][fig]] : red (approx syn density using this method) reproduces pretty well green (syn density calculated via simulation - sfn16 poster)
-- if include wnorm, then syn density will be complementary (no longer uniquely responsible for
scracm exp values) -- so in dend = lower syn density;  vs soma = higher syn density

- in model we are assuming option 2: divide only by avg density, which gives relative syn density (assuming identical soma
  epsps); when distribute multiple by weightNorm

- use same for L4,L5A -> PT?

- comparison of syn density calculated via model (sfn paper) vs syn density calculated from extracted figure
 (no wnorm):
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170217_115948.png][fig]]
-- with wnorm: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170217_120101.png][fig]]
-- both decent approximations, although underestimate apical tufts

**** TVL, TPO, M2, OC -> E (L2/3, L5A, L5B, L6) (Hooks 2013)
dendritic densities:
- L2/3 - use L4 Yama - match
- L4 IT - Yama15 elife (fig 8D): [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170217_160651.png][fig]]
- L5A IT and L5B IT - detailed cell models (for L5B avg with PT?)
- L6 - use L5B IT+L5B PT ? stretch? translate bottom half to match soma location; insert middle pixels replicating exiting one

**** TVL, M2, cM1, M2, S2 -> L5B PT (Suter 2015)
-- make sure Thalamus-S2 match Fig 6c

** DONE Methods: Check local conns
- IT6 and CT6 only inh input! - found bug in code!! - weights = [1.0] * len(prePops)
- SOM6 and PV6 identical?
- PV5A/B twice inputsthan PV2 or PV6 ?  - reduced from 26% to 17%
- PT5B,CT6 was projecting to upper layers
** DONE Methods: Cylindrical volume
- square: 300um * 300 um = 90k
- circular: radius = 180 -> 3.14 * 160^2 = 80384

- border effects:
-- mirrored borders conn
-- toroidal cliff?

** DONE Methods: Update cell densities
*** Excitatory from Tsai 2009 (mouse M1)
- mouse agranular cortex (AP bregma +1mm; ML bregma +1mm ~= M1 according to Allen Brain:
  http://help.brain-map.org/download/attachments/2818171/InjectionSites_and_StereotaxicCoordinates.pdf)

- Extract densities for each yfrac used in model:
0.12, 0.31, 0.41, 0.52, 0.77, 1.0 and average to calculate dendsity in each layer

- Cortical depth = 1600um -- calculate um for each yfrac:
0.12 -> 192
0.31 -> 496
0.42 -> 672
0.52 -> 832
0.77 -> 1232
1.0 -> 1600

- Calculate avg density for each region (10^5 mm^3):
L2/3 -> 192:496 -> 1.1044
(L2/3 based on graph -> 160:496) -> 1.115
L4 -> 496:672 -> 1.0122
L5A -> 672:832 -> 0.8115
(L5B -> 832:1232 -> 1.179)
L5Bu -> 832:1032 -> 0.9087
L5Bl -> 1032:1232 -> 1.3254
L6 -> 1232:1600 -> 1.427

- take upper bound (1.04*x) since other papers show higher values (also match 10k cell for 300x300um):
[114858, 105269, 84396, 122616, 148408]

- Layers based on densities - not clear!

*** ratio of E/I
Lefort (mouse S1):
L2=105/545 = 0.193
L3=125/1147 = 0.11
L4=142/1655 = 0.09
L5A=97/453 = 0.21
L5B=138/646 = 0.21
L6=133.5/1291 = 0.10

Markram (rat S1):
L2: 0.3023
L3, 0.1902
L4, 0.1400
L5, 0.2375
L6, 0.1991

*** Inhibitory distribution
- Wall 2016 (mouse S1)
SST distribution of cells: L1=2.4%, L2/3=35.2%, L4=19.9%, L5A=26.8%, L5B=10.0%, L6=5.7%;
PV distribution of cells: L1=0%, L2/3=15.0%, L4=27.9%, L5A=29.6%, L5B=19.4%, L6=8.1%;

- Katz 2011 (mouse M1) - / 0.05mm^3
- L5B: PV = 309+84, SOM = 130+-44; VIP = 79+-29
- L6: PV = 132+-32, SOM = 91+-46, 93+-26

-- convert to cells/mm^3 (multiply by 20)
L5B PV = 6180, SOM = 2600 (~70-30%)
L6 PV = 2640, SOM = 1820 (~60-40%)


- this S1 so not clear if makese sense for M1
- maybe better to keep 10% PV and 10% SOM
- separate L5A and L5B!

*** Option 1
1) Use total density of Tsai09 (mouse M1)

2) E/I ratio from Lefort09 (mouse S1)
L23: E=1.1044*0.84=0.9371; I=1.1044*0.1515=0.1673

3) PV/SOM ratio from Katz 2011 (mouse M1)

4) Compare to Katz11 and Wall16 relative densities
L23 0.06113-0.3111
L4 0.3111-0.4999
L5A 0.4999-0.5624
L5B 0.5624-0.7492
L6 0.7492-1.0

** DONE Methods: Update delays
- From Thalamus ~2.2ms (mouse S1); 10ms (rat S1 in vivo) - maybe use 5ms?
- current intrinsic conns have 5ms + dist-dep -- reduce this! maybe 2ms?

- reduced defaultDelay to 2ms

** DONE Methods: Cells by ref
- Save memory; point to structures in cellParams
- cellParamsByRef = True  # Warning: shouldn't be used if multiple cell properties apply to same cell
- simpler option for now: cfg.saveCellSecs = False

** DONE Methods: Reorganize folders and create final netParams (17feb26)
- sim/conn - include conn.py and subconn, + weightNorm
- sim/cells - include synDensity
- rename FS and LTS cells

** DONE Methods: Use fixed I/E ratios at cell-by-cell basis, mediated via disynaptic inhib
Yamawaki Shepherd 2015 JNeuro  -- this shows that disynaptic inhibition accompanies excitation in a precisely
'tuned' manner -- specifically, I/E ratio is specific for different presynaptic cells types, with CTs generating relatively
more I (i.e., higher I/E), than ITs; also, I is tuned to E at the level of each postsynaptic E neuron, independent of E cell
type. This holds in the extreme: an E neuron will get zero I if it gets zero E. If it does get E, the amount of I will be
tuned according to the I/E ratio for the presynaptic class. (This may sound more complicated than it is ... sorry)

"Photo- stimulation of PT neurons evoked strong E and I in a PT neuron, but essentially zero E and I in a neighboring CT
neuron, even though these neurons were separated by only  75  m. There- fore, from these experiments, we conclude that  disynaptic inhi- bition in these CT-related microcircuits is both postsynaptically cell specific, in that E and I remain proportional (‘balanced’) on a cell-by-cell basis according to the precise level of excitation received by individual postsynaptic neurons, and presynaptically class specific, in that the proportionality constant (ratio of I to E) varies according to the presynaptic (but not postsynaptic) pro- jection class."

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170823_105245.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170823_105317.png][fig]]

- tricky to implement -- probably for next iteration/paper

*** implementation
option1: Modify conns after created, but before creating NEURON objs and syns:
- For each interneuron:
-- For each incoming exc conn:
---

- For each Epre->Epost conn:
-- For each Epre->Ipost conn:
--- if not Ipost->Epost:
---- check if any Ex for [Ex in Ipost->Ex]

I->E are dist-dep!!

option2: bias during conn creation
- when creating Ix->E conns probabilistically
-- check Epre->Ix and favor/include those in target
-- increase prob of Epre by X %; and for each decrease prob of 1 non-Epre by same X%


network.py:
    def _disynapticBiasProb(self, origProbability, bias, prePreGids, postPreGids, disynCounter):

        probability = origProbability

        print origProbability, bias, prePreGids, postPreGids, disynCounter

        if not set(prePreGids).isdisjoint(postPreGids):
            probability = min(origProbability + bias, 1.0)
            disynCounter += 1
        elif disynCounter > 0:
            probability = origProbability - (probability - origProbability)
            disynCounter -= 1
        print probability
        return probability, disynCounter


analysis.py:
    numDis = 0
    for postCell in sim.net.allCells:
        preGids = [conn['preGid'] for conn in postCell['conns'] if isinstance(conn['preGid'], Number)]
        for preGid in preGids:
            preCell = sim.net.allCells[preGid]
            prePreGids = [conn['preGid'] for conn in preCell['conns']]
            if not set(prePreGids).isdisjoint(preGids):
                numDis += 1
    print '  Total disynaptic connections: %d (%.2f%%)' % (numDis, float(numDis)/float(sim.totalSynapses)*100)

*** issues
- in large scale net, less connections being created each time but same proportin! why?? see v46_tune1,2,3
-- PT5B -> L5 I -> PT5B
-- disyn 0.0: Total disynaptic connections: 671610 / 1011310 (66.41%)
-- disyn 0.2: Total disynaptic connections: 609230 / 913270 (66.71%)
-- disyn 0.4: Total disynaptic connections: 497195 / 738045 (67.37%)

- maybe low probs, so if set 5 from 0.1 to 0.0 but in increase 1 by 0.5 doesn't compensate?
*** try different approach
- find indices of disyn vs not, and force that connections after calculating rand
- new method works and provides fixed % of disyn and same num of conns
*** code
    ###############################################################################
    ### Disynaptic bias for probability (version 2)
    ### bias = min fraction of conns that will be disynaptic
    ###############################################################################
    def _disynapticBiasProb2(self, probMatrix, allRands, bias, prePreGids, postPreGids):
        connGids = []
        # calculate which conns are disyn vs
        disynMatrix = {(preGid, postGid): not set(prePreGids[preGid]).isdisjoint(postPreGids[postGid])
                for preGid, postGid in probMatrix.keys()}

        # calculate which conns are going to be created
        connCreate = {(preGid, postGid): probMatrix[(preGid, postGid)] >= allRands[(preGid, postGid)]
                for preGid, postGid in probMatrix.keys()}
        numConns = len([c for c in connCreate.values() if c])

        # change % bias of conns from non-disyn to disyn (start with low, high probs respectively)
        disynConn, nonDisynConn, disynNotConn = [], [], []
        for (pre,post), disyn in disynMatrix.iteritems():
            if disyn and connCreate[(pre,post)]:
                disynConn.append((pre,post))
            elif not disyn and connCreate[(pre,post)]:
                nonDisynConn.append((pre,post))
            elif disyn and not connCreate[(pre,post)]:
                disynNotConn.append((pre,post))
        disynNumNew = int(float(bias) * numConns)
        disynAdd = disynNumNew - len(disynConn)

        if disynAdd > 0:
            # sort by low/high probs
            nonDisynConn = sorted(nonDisynConn, key=lambda k: probMatrix[k])
            disynNotconn = sorted(disynNotConn, key=lambda k: probMatrix[k], reverse=True)

            # replaced nonDisynConn with disynNotConn
            for i in range(disynAdd):
                connCreate[nonDisynConn[i]] = False
                connCreate[disynNotConn[i]] = True

        connGids = [(pre,post) for (pre,post), c in connCreate.iteritems() if c]
        return connGids
*** results show less synchronized activity - good
- less interlaminar dependency - good
*** something wrong in implementation
- only when 100% saw significant diff
- if compute disyn conns always the same
- worked with small net bug issues with large net
*** comments by gmgms at sfn17
- this features only in L6 CT -- acualy paper includes PT and IT5B
- hard to implement
- in L5 disyn inhibition ok to happen
*** comparison
- Yama15 suggests E->I and I->E by cell type
- Apicella doesn't really divide by cell type - no info
- Naka16: "Despite this promiscuous connectivity, some studies suggest that the PV population may preferentially inhibit
  specific PC subtypes (Ye et al., 2015), though reports in L5 conflict over whether IT or PT cells receive more inhibition
  (Fariñas and DeFelipe, 1991; Lee et al., 2014; Rock and Apicella, 2015).
 "However, by harnessing the massive divergence of Martinotti cells, L5 PT cells can potentially route inhibition to a large
cohort of neurons across multiple layers. Burst firing by one or a small number of L5 PT cells might therefore represent a
‘‘call to order’’, quieting activity throughout an entire cortical column by activating FDDI."

[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20171122_162305.png][fig]]

- Basically unknown - so assume interactions .-- need to further constrain inhibitory conn

** DONE Methods: Add Migliore ih channel (17jun10) 		    :ih_mig1:
*** modeldb
- https://senselab.med.yale.edu/ModelDB/ShowModel.cshtml?model=144541&file=/Ih_current/h.mod#tabs-2
*** different distribution
forsec "soma" {
		insert hd ghdbar_hd=ghd	vhalfl_hd=-82
                insert na3 gbar_na3=gna
                insert kdr gkdrbar_kdr=gkdr
                insert kap gkabar_kap = KMULT
		insert km gbar_km=gkm
}

for i=0, numbasal-1 dend[i] {
		insert hd ghdbar_hd=ghd vhalfl_hd=-82
                insert na3 gbar_na3=gna
                insert kdr gkdrbar_kdr=gkdr
		insert kap gkabar_kap=0
		insert kad gkabar_kad=0

		for (x,0) { xdist = distance(x)
                	if (xdist>500) {xdist=500}
                		if (xdist > 100){
					vhalfl_hd=-90
                        		gkabar_kad(x) = KMULT*(1+xdist/100)
                			} else {
					vhalfl_hd=-82
                        		gkabar_kap(x) = KMULT*(1+xdist/100)
               				}
		}
}

forsec "dend_5" {
	insert ds
		insert hd ghdbar_hd=ghd
                insert na3 gbar_na3=gna
                insert kdr gkdrbar_kdr=gkdr
		insert kap gkabar_kap=0
		insert kad gkabar_kad=0

		for (x,0) { xdist = distance(x)
                	ghdbar_hd(x) = ghd*(1+100/(1+exp((half-xdist)/slope)))
                	if (xdist>500) {xdist=500}
                		if (xdist > 100){
					vhalfl_hd=-90
                        		gkabar_kad(x) = KMULT*(1+xdist/100)
                			} else {
					vhalfl_hd=-82
                        		gkabar_kap(x) = KMULT*(1+xdist/100)
               				}
		}
}

for i=0, numapical-1 apic[i] {
	insert ds
	insert hd
        insert na3 gbar_na3=gna
        insert kdr gkdrbar_kdr=gkdr
	insert kap
	insert kad
	gkabar_kap=0
	gkabar_kad=0

		for (x,0) { xdist = distance(x)
                	ghdbar_hd(x) = ghd*(1+100/(1+exp((half-xdist)/slope)))
                		if (xdist > 100){
					vhalfl_hd=-90
                        		gkabar_kad(x) = KMULT*(1+xdist/100)
                			} else {
					vhalfl_hd=-82
                        		gkabar_kap(x) = KMULT*(1+xdist/100)
               				}
		}

	vhalfl_hd = dend_5[aplist.x[i]].vhalfl_hd

*** parameters
{ehd_hd=-30 elk_hd=-75 clk_hd=coeffRa}
*** OPTIONS COMPROMISE BETWEEN FI CURVE AND EPSPvsWEIGHT IH CURVE
**** problem definition
different params for fI curve vs epsp-weight curve
eg. good epsp/weight -> gbar=1.5, lkc=1.6, lke=-85; flat fI curve
- good fI curve -> 1.25, 1.2, -70


**** try changing distribution based on migliore (but CA1) or Markram paper
-- soma   6.6129403774e-05
dend_3   6.6129403774e-05
apic_23   0.00565
apic_20   0.00215621225432
apic_18   [0.0011666691691727131, 0.0014051161901134166, 0.0018572014448675063]

**** fix to remove dendritic spikes, might not be needed anymore, since ih could take care of that!
-- v42_batch17 - didn't find any combination which produced spikes from 1.5,1.5,-90
-- v42_batch18 - checking with lower ihgbar (0.0,0.5,1.0)
-- conclusions:
--- fI with orig na+axon -> increased diff between ih vs no ih
--- only increasing dendNa or axonNa -> higher fI (ih=0.5), lower fI (ih=0.0)
--- dec axonRa -> higher fI (ih=0.5)
--- if ih=1.0 -> all fI = 0
-- v42_batch20,21 - check EPSP:
--- only increasing dendNa -> not clear diff; inc axonNa -> inc epsp reversal, but also get spk + double reversal
--- dec axonRa -> similar but reduces dend spikes
--- fI with orig -> reversal + dend spikes -- no ih=spk, ih=no spk -> good?
-- to improve fI could reduce axonRa, inc dendNa+axonNa, but not too much cause get dend spk+double reversal
--- maybe also help match spike shape+subthresh (already tuned with Kole ih but not with Migliore)
27

**** test removing somatic ih
-- v42_manualTune31 - if reduce somatic+basal ihgbar * 0.1, 24->32hz (epsps -68->-70mV) - good!
-- check if same effect changing ih params in PTcell
-- conclusion: lowering soma+basal ih keeps epsps ~same, but increases fI rate (eg. v42_manualtune52)
-- v42_batch19 - reduced somatic+basal ih
--- with ihBasal=0.1 or 0.01, get ~decent ih with ihlkc=1.2 and ihlke=85 -> reversal epsp (actually similar to ihBasal=1.0 !)
--- check epsps v42_batch22 - can get 6 fI points and reversal epsp

- check if can justify ihGbarBasal - compare with kole's + mig - run single sims to test
-- soma, basal = fixed h_gbar in Kole - so just rescaling - should be ok

**** check usin migliore ghdbar_hd(x) = ghd*(1+100/(1+exp((half-xdist)/slope))); ghd=0.6e-4, slope=14,half=265
-- practically identical results -- surprising
-- check modifying just vhalfl_hd=-82 in perisom -- ok'ish, fI might compensate epsp
-- use ih_BS values for PT ? vhalfl=-78.474, vhalft =-66.139 -- too much
-- if lower half param -> dec fI (slightly) but inc epsp -> optimum value=230 ?
-- conclusions:
--- reducing vhalf -> increase epsp (bad), increase fI (good)
--- using mig distribution (lower basal ih) -> great, reduces epsp (good), increases fI (good)
-- check parametric fI+epsp: v42_batch23, v42_batch24
-- compared to sam dist: practically identical epsp; very slightly better fI

**** test different combination of inputs to dendrites - just tufts? (same EPSP amp as mig paper)
-- locations: hard to compare since realative strength varies as func of loc; results unclear
-- just 50 inputs like paper - v42_batch25 (50,75,100)
---

**** check if num spikes consistent with EPSP amps - sheets fig 1
-- reproduce epsp fig but with spikes -- difference between ih vs zd
-- v42_batch26
--- in all cases zd higher rate than ih (increase almost linearly)
--- so just need to focus on fI curve, and plpay with range of weight stim + input locs to get reasonable reversal effect

**** if needed, assume lower base level (e.g. 0.5 so decent fI, and then ih modulated to reduce to 0.1 or increase to 1.0 or 1.5)

**** param explore num stims, weights, locs, to get reversal with good fI
- include as func of ihGbarBasal - affects netstim spks!
-- v42_batch27 -- didn't find any case with reversal

**** include noise in netstim inputs (ih effects over integ window etc)
-- v42_batch28 - reversal using 0.2 noise !!! ih=1.0, ihbasal=0.1,c=1.2, e=-75 (only if apicdend :/)  - should be decent fI curve - great!
-- also ih=1.0, ihbasal=1.0, c=1.2, e=-75, alldend, noise=0.5 -> reversal at high weights (>200*1e-5)

**** use different ihlke and ihlkc for soma+basal than apical!!
- might be easier to find compromise!
- reproducing sheets fig 7 (v43_tune39 vs 32) shows reducing ihlkc compensates for low ihGbarBasal

**** axonNa inc rotates fI line clockwise and increases peak V, but reduces ih-zd diff
**** found good fI solution with decent epsp-w
cfg.ihModel = 'migliore'  # ih model
cfg.ihGbar = 1.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarZD = 0.0  # multiplicative factor for ih gbar in PT cells
cfg.ihGbarBasal = 1.0 # 0.1 # multiplicative factor for ih gbar in PT cells
cfg.ihlkc = 1.2 # ih leak param (used in Migliore)
cfg.ihLkcBasal = 0.01
cfg.ihlke = -72  # ih leak param (used in Migliore)

cfg.dendNa = 0.25
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.65  # multiplicative factor for pas g in PT cells
cfg.epas = 1.0  # multiplicative factor for pas e in PT cells
**** maybe want to emphasize ih-zd difference and sacrifice fI
- if want to show strong ih modulation of PT for modes of operation need this
- check sheets fig11 response + fI simultaneously in 3-sec sim
- inc ihlke+ihlkc until get strong ih vs zd (sheets 11) with sec=alldend
-- sheets 20hz -> zd = ~6x ih Hz (var: 0.1-20x)
-- sheets 40hz -> zd = ~4x ih Hz (var: 1-8x)
*** comparing migliore ih distribution with kole's
Kole:
- soma, basal, oblique = h_gbar
- < nexusdist (297): h_gbar*exp(x_savedist(x)/h_lambda); h_gbar= 6.6129403774e-05, h_lambda=66.774625145718858
- h_lambda= nexusdist (297) / log (h_gbar/h_gbar_tuft)
- 10 um -> 7.68e-5
- 50 um -> 0.00013
- 100 um -> 0.0003
- 167 um -> 0.0008
- 297um -> 0.00565
- > nexusdist: fixed at h_gbar_tuft=0.00565

Kole with lambda 0.6:

Migliore:
- sigmoid: ghd*(1+100/(1+exp((half-xdist)/slope))); ghd= , half=, slope=
- effectively:
-- < half-7*slope (<~167 um): ghd (6e-5)
-- half-10*slope to half+2*slope (~167 to 363 um): increase exp from ghd (6e-5) to 0.006 (at nexus=297um -> 0.00577)
-- > half+7*slope (>363um): ~0.006

*** double reversal effect - feature/bug?
if keep increasing weight, then PT with ih shows stronger response again (after spiking, so might be depol block related?)

*** ih effect on PT too high in net -- reduce and improve fI curve
- probably need to rerun weightNorm
- check first results, see if really needed -- might be ok to just use ih=0.5
- also rates go from 0.5 to ~10hz so not that big difference really.
- might actully need lower to avoid depol blcok when stim!

- 1st try modifying:
cfg.dendNa = 0.4
cfg.axonNa = 7
cfg.axonRa = 0.005

cfg.gpas = 0.6  # multiplicative factor for pas g in PT cells
cfg.epas = 0.9  # multiplicative factor for pas e in PT cells

- check prev solutions
tune116: ihlke:-88, ihlkc=0.25
fI 0.35-0.6nA: 12.00 - 39.00
stim ih-zd   : 23.00 - 47.00 (24.00)
RMP ih-zd    : -73.03 - -84.65
Peak ih-zd    : 12.81 - 13.23

- issue reproducing due to netpyne; get this instead:
fI 0.35-0.6nA: 0.00 - 36.00
stim ih-zd   : 16.00 - 63.00 (47.00)
RMP ih-zd    : -74.67 - -84.65
Peak ih-zd    : 12.80 - 13.24

- but if go back to netpyne version on Aug 15, then works ok! aaagh, something to do with the import I guess

- check bdd7ffbb7c (version 0.7.4): ok
- 4556905c: messed up
- 61e8074: messed up
- ba331e: messed up (v47_tune18)
- fd7064e: ok! (v47_tune19)

*** Fixed BUG in PT ih! (ehd global)
was having trouble reproducing tuned PT cell fI curve so started digging and found complex chain of causes
I tuned PT cell before fixing obscure netpyne bug (the one prevented penny+sergio from reproducing results)
that bug was causing the netParams to be stored as OrderedDict instead of netpyne’s ODict
due to an additional bug that format prevented global variables from being read and set properly (also happened when loading saved netd from json file)
since migliore’s ih ehd variable was global (and undefined in mod) this causes PT to fire differently

ALL SIMS USING WRONG PT - ehd not set!!

*** Find new balance PT ih params
parametrized somaNa (v48_manualTune):
somaNa values (S/cm2) and dend ratio:
- PT_full (Neym17): 0.0153 (1:1)
- PT_6comp (Neym17): 0.0345 (1:1)
- PT_6comp (JoeGraham): 0.0345 (10:1)
- PT_full (Hay11): 2.0 (20:1)
- PYR_full (Srdjan/Penny): 0.09 (6-12:1)

New PT ih values tuned in v48_batch47

** DONE Methods: NMDA/AMPA and GABAA/GABAB ratios
- \cite{Myme03} - NMDA to AMPA ratio between 0.45 and 2x -- avg ~1.0
- model results nicer with ratio of 1.0 than 0.1 (bursts)
- major reproducibiliy issue v45_batch10-v46_batch3 was due to synWeightFraction not being implemented
- test different ratios
- use 0.5:0.5 with adjusted weightNorm
- also check lower GABAB ratio 7.5 - too high!

- For GABAB - prev implementation had no effect -- use exp2syn with values from Markram

- New values:
cfg.synWeightFractionEE = [0.5, 0.5] # E->E AMPA to NMDA ratio
cfg.synWeightFractionEI = [0.5, 0.5] # E->I AMPA to NMDA ratio
cfg.synWeightFractionSOME = [0.9, 0.1] # SOM -> E GABAASlow to GABAB ratio

** DONE Methods: Check IT5A conn - shows 2 bands of different activity on edges of layer
*** problem
- shows up when order cells by yfrac
- [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20171019_180212.png][fig]]
*** plan to check whats going on
- find 2 cells on center and edge of layer
-- plot v47_batch8_2_0_1_1_1_0, 1-2 sec, just IT5A pop, ordered by y and then by gid
--  cell: 3480.0, 16spk (v47_tune11); cell 3481.0, 2spk (v47_tune10)
- plot incoming conn to those cells

sim.load('../data/v47_batch9/v47_batch9_2.json')

- netClamp
cfg.netClampConnsFile = '../data/v47_batch9/v47_batch9_2.json'
cfg.netClampSpikesFile = '../data/v47_batch8/v47_batch8_2_0_1_1_1_0.json'
cfg.netClampPop = ['IT5A_1']
cfg.netClampGid = 3481

- 3481 - 2 spks ok; but 3480 showing only ~8 spks after stim -- check by cortical depth

- Get full list of conns and tags so can analyze properly:
In [5]: connfile='../data/v47_batch9/v47_batch9_2.json'

In [6]: connsFile='../data/v47_batch9/v47_batch9_2_conns_full.json'

In [7]: tagsFile='../data/v47_batch9/v47_batch9_2_tags_full.json'

In [8]: sim.ijsonLoad(connfile, tagsGidRange=None, connsGidRange=None, loadTags=True, loadConns=True, tagFormat=['pop', 'y', 'ynorm'], connFo
   ...: rmat=['loc','weight', 'preGid', 'delay', 'sec', 'synMech'], saveTags=tagsFile, saveConns=connsFile)

- cell y pos
   "3480": [
      "IT5A",
      689.160631119702,
      0.5104893563849644
    ],
    "3481": [
      "IT5A",
      699.7626845734748,
      0.518342729313685

-- edge: (v47_manualTune12)
    "3571": [
      "IT5A",
      701.7925999481713,
      0.5198463703319788

-- center: (v47_manualTune13)
    "3597": [
      "IT5A",
      622.1460398255973,
      0.46084891838933134

- Significant changes between edge and center cells:
-- center much stronger IT2 (~6x)
-- less PV (~2x -- don't think significant)

- CHECK IT2->IT5A bins!:
In [3]: bins[('W+AS', 'IT', 'L4,5A,5B')]
Out[3]:
array([[ 0.3125,  0.375 ],
       [ 0.375 ,  0.4375],
       [ 0.4375,  0.5   ],
       [ 0.5   ,  0.5625],
       [ 0.5625,  0.625 ],
       [ 0.625 ,  0.6875],
       [ 0.6875,  0.75  ]])

*** Conclusion - possible artifact due to binning (but ok)
Problem is layer 5A 0.42-0.51, so 0.42-0.4375 uses conn from L4 bin, and 0.5-0.51 uses conn from L5B bin !!
- Artifact of using bins -- radically differnet strengths within layer
- If used function then would be smoother

** DONE Methods: Fix layer borders and conn
*** New layer borders
- From Yamawaki:
Based on the results of the circuit analyses (Figures 1–6), we de ned ‘L4’ as a thin zone centered on 0.33 (in units of
normalized cortical depth) and span- ning 0.05 the cortical thickness (i.e., depth range 0.305–0.355). We de ned ‘L2/3’ as
the laminar zone spanning 0.14–0.26, and ‘L5A’ as the zone 0.37–0.42. These laminar zones were separated by small gaps (0.045
between L2/3 and L4, and 0.015 between L4 and L5A), which reduced (but did not necessarily eliminate) the likelihood that
some neurons were wrongly classi ed due to slice-to-slice variability in layer thicknesses.

L2/3 = [0.14, 0.26] or [0.1, 0.25]
L4 = [0.305, 0.355] or [0.29, 0.37]
L5A = [0.37, 0.42]

 L2/3, 0.1 to 0.25; L4, 0.29 to 0.37

- From Weiler:
L2/3 = [0.1, 0.3]
L4,5A = [0.3, 0.46]
L5B = [0.46, 0.8]

- From Anderson:
-- 5A/5B border = ~0.47 or 0.46 or 0.51
-- L6 border = 0.81

- From Hooks13:
-- L1-L2/3 = 0.09
-- L2/3-L5A = 0.16
-- L5A/L5B = 0.32
-- L5B-L6 = 0.69

- From Sute13:
L23: [0.12-0.31]
L5A: [0.31-0.47]
L5B: [0.47-0.8]

- From Oswa13:
-- L2/3-L5A: 0.4
-- L5B-L6: 0.81

- Yamawaki 15 CT:
-- L6: 0.75 (cites Sute13)

- Current:
    bins['layerLabels'] =   ['pia', 'L1-L2 border', 'L2/3-L4 border',   'L4-L5A border',   'L5A-L5B border',    'L5B-L6 border',   'L6-WM border']
    bins['layers']      =   [0,     0.12,           0.31,               0.42,               0.52,               0.77,               1.0]

- New
L2/3 = [0.1, 0.29] - Yamawaki
L4 = [0.29, 0.37]  - Yamawaki
5A = [0.37, 0.47] - Anderson10/Suter13
L5B = [0.47, 0.8] - Suter13/Anderson10/Oswa13
L6 = [0.8, 1.0] - Suter13/Anderson10/Oswa13

*** New cell densities
- Extract densities for each yfrac used in model:
0.1, 0.29, 0.37, 0.47, 0.8, 1.0 and average to calculate dendsity in each layer

- Cortical depth = 1600um -- calculate um for each yfrac:
0.1 -> 160
0.29 -> 464
0.37 -> 592
0.47 -> 752
0.8 -> 1280
1.0 -> 1600

- Calculate avg density for each region (10^5 mm^3):
L23, 4, 5A, 5B, 6]
[112484.88513157895, 110496.06095875, 85514.869699, 115370.51838181818, 143964.80444814815]
*** New number of cells per pop
IT2 1730
SOM2 114
PV2 232
IT4 767
IT5A 644
SOM5A 56
PV5A 114
IT5B 1435
PT5B 1435
SOM5B 251
PV5B 511
IT6 1236
CT6 1236
SOM6 90
PV6 184

*** conn matrices
- including weight confusing due to weightNorm - eg. CT6 vs IT2 twice -- use probability or strength
- Check upper to lower PT! — consistent with Anderson
- Reduce IT5B->IT5A — 0.5
- Check 0.375-0.4 region - ok

- VL -> L5B profile has strong effect -- make uniform as suggested by gordon!
- Increased S2 inputs from 10% to 15%


*** fix lower PT5B
- lower PT5B receives strong inputs from upper and lower PT5B (from Anderson matrix)
- the result is lower PT5B exhibits higher activity than upper PT5B
- if lower PT5B recurrent then get stronger in upper layer and can differentiate sublayers

- Options to justify reducing IT5B/PT5B->PT5B:
-- reduce overall strength of conns
-- Kiritani shows PT5B->PT5B lower than IT5->IT5

*** Decrease L2/3 -> L4 (Yama)
Decrease L2/3->L4 (= 0.25 * L4->L2/3, Yamawaki,15)

** DONE Methods: Fix border effect due to dist-dep and layer-bound inh conns
*** problem

other artifact why L5B borders have more activity: inh cells are restricted to each layer and are distance-dependent, so borders receive less inhibition

 from matplotlib import pyplot as plt; nis = []; ynorms=[]
   ...: for i in sim.net.pops['IT6'].cellGids+sim.net.pops['CT6'].cellGids:
   ...:     cell = sim.net.cells[i]
   ...:     nis.append(len([conn for conn in cell.conns if 'GABA' in conn['synMech']]))
   ...:     ynorms.append(cell.tags['ynorm'])
   ...: plt.scatter(ynorms,nis); plt.ion(); plt.show()
L24 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180426_174204.png][fig]]
L5 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180426_174539.png][fig]]
L5B IT - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180426_174232.png][fig]]
L6
*** solution
when calculating distance (for dist-based prob) take into account distance from border so decreases value used — effectively
increasing prob of making conns with more distant neurons
- implemented in netpyne net.params.borderEffect

** DONE Results: Tune to obtain reasonable rates and oscillation (17feb28-17may31)
- check measures in Bezaire, Plos Comp PFC, Markram, Potjans
- v27_manualTune rates pretty good! match rates described by gmgs, except 1) IT6 too high; 2) I>E; 3) FS>SOM;
- Test EE, EI, IE, II scaling params on comet
*** DONE Running on Comet
ssh salvadord@no.neurosim.downstate.edu
hg clone ssh://no.neurosim.downstate.edu///u/salvadord/Documents/ISB/Models/m1
cd /home/salvadord/site/nrniv/local/mod or cd $MODL_INCLUDE
hg pull; hg up -C
cd /home/salvadord/site/nrniv/local/python
vim .bashrc
 export PYTHONPATH=/home/salvadord/site/nrniv/local/python:/home/salvadord/site/nrniv/local/python/netpyne:$PYTHONPATH
 export PATH=/home/salvadord/site/nrniv/local/bin:$PATH
mkmod
sbatch jobscript
squeue -u salvadord
qstat -au salvadord
qstat -n -1 -u salvadord
qstat -f jobid
scontrol show jobid -dd 8098155
show_accounts
squeue -u <username> -t RUNNING
squeue -u <username> -t PENDING

*** DONE check if syn dist look ok -- plot syns over morph with diff colors
- check robert package- https://github.com/ahwillia/PyNeuron-Toolbox  (email alex.h.willia@gmail.com if use)
- gridY generated by conn_dend.py is already aligned to cell -- don't use; instead assume 0 to -1500
- long->PT5B scracm not aligned perfectly to cell (Eg. S2 cell is displaced upward)
- try to find better alignment, and reproduce TVL vs S2 -- maybe reduce factor of dendL by 2 (so original scracm stronger effect)
-- multiplied by sqrt(dendL) to smooth effect and give preference to scracm data -- sqrt smoothing (spread, no peaks)
-- skewed selection of cells towards pia (-0.3,0.2) so matches better with soma of 735um
-- now can see diff effect of TVL vs S2 on PT dend
*** DONE check rates across 10 sec - dep blockade
v27_manualTune9 - many cells dep block after ~500 ms
- too many inputs? high weights?
- wrong dend dist?
- not enough inhib?
- fixed many issues - now v30
- running EI balancing
-

*** DONE error with ca-dependent NMDA syn placed at 0 or 1
You can not locate a point process at
 position 0 or 1 if it needs an ion
22 nrniv: ca_ion can't be inserted in this node
22  near line 0
22  ^
        22 MyExp2SynNMDABB(0)

I didn’t realize that syn was using ca — is this something we want/need for this model?
can be useful in future -- keep

*** DONE finish netpyne batch changes so can run 'grouped' params
eg.

def IFcurveCompare(pnameList, pvaluesList, Ivalues=list(np.arange(-2.0, 8.0, 0.5)/10.0)):
	# Create Batch object
	b = Batch()
	for label, pvalues in zip(pnameList, pvaluesList):
		b.params.append({'label': label, 'values': pvalues, 'group': True})
	b.params.append({'label': ('IClamp1', 5), 'values': Ivalues})
	return b

b= IFcurveCompare([('seeds', 'conn'), ('seeds', 'stim'), ('seeds', 'loc')],
				  [[1,2,3], [1,2,3], [1,2,3]])

b.batchLabel = 'v30_test'
b.saveFolder = '../data/'+b.batchLabel
b.method = 'grid'

b.runCfg = {'type': 'mpi',
			'script': 'init.py',
			'skip': True}

# run batch
b.run()

*** DONE check why diff pop rates in comet vs zn
- only for detailed PT5B and IT5A cells
- NEURON versions?
- mod mechanism?

	params['EEGain'] = [0.8, 1.0, 1.2]
	params['EPVGain'] = [0.8, 1.0, 1.2]
	params['ESOMGain'] = [0.8, 1.0, 1.2]
	params['PVEGain'] = [0.8, 1.0, 1.2]
	params['SOMEGain'] = [0.8, 1.0, 1.2]
	params['IIGain'] = [0.8, 1.0, 1.2]

- checked again and where same -- maybe ok after fixing mod files
- compare 0.8,0.8,0.8,0.8,0.8  zn vs cm
- wokring ok
*** TODO since syn sumation not linear, try dividing weight by numsyns/2 instead of /5
- do quick test in cell branch
- ah but weight scaling wasn't linear either - check if compensate
- batch with X=10000? combinations of 5 random dendrites with w=0.1 each -- histogram of EPSP

*** DONE use panda to analyze results + find reasonable rates
- add option to load only subset of data (for large datasets)
- create pandas with params + pop rates
- search for reasonable rates
- choose best and run stim 200ms for each long pop

*** DONE first results show dep blockade in PT; and spk threshold too low
defaultThreshold = 10 -- so PT dep blockade must be only for cell 0 -- bug! had NetStim!!

*** DONE slides for gmgs
- run 1 sec sims -- check some good looking sims
-
*** DONE depol blockade
- plot conn bars with all inputs to PT vs IT -- strength + num syns
- plot num syns shape plot
- run systematic test with fixed num inputs/weights - distributed uniformly across secs

- FOUND ISSUE: IT6->PT5B subconn rule wrong so all inputs to same segment (num syns>100)!
- Also wrong: S1,S2,cM1->IT5A (num syns>100)

- check those subconn rules and try in single cell controlled sim -- those rules missing!!!

- after fixing missing subconn rules still have depol blockade on PT
- checked strength bar plot of PT vs IT -- PT much higher still ~9000 vs <10 ? (same as before)
- check num syns
- check in single cell syms if similar ratio of strength
- maybe threshold weightNorm? - check paper
-- Mage00 shows ~3X weight for distal vs proximal syns
-- IT cell max weightnorm is ~2X
-- limited to 10x factor, only tuft affected: [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170407_154023.png][fig]]
-- add 'weight' to shape plot, and check PT in net

- IT5A no weightNorm in soma?! - fixed (soma vs soma_0)

**** chat with sam/bill on fixing depol
synaptic conductances - used what we had in prev models

[10:05]
inputs are based on data — as much as possible

billl [10:05 PM]
well they've always been high since we've always had too few syns and perhaps we've always had less sensitive dends -- in fact our preivous models have mostly been much smaller cells lately

samn [10:05 PM]
and scaling everything down uniformly ( that's what i usually do )

billl [10:06 PM]
some of the models from early on were ~1e3 compartments but not in a network of more than a few cells

salvadord [10:06 PM]
good way to separate - no, but Kiritani paper shows somatic EPSP for unitary connection, so based weight on reproducing that

samn [10:06 PM]
so you have an average weight

[10:07]
but range more unknown?

billl [10:07 PM]
ok but somehow still coming out too strong i guess -- going to run a single cell and see where the problem is?

salvadord [10:08 PM]
range according to gmgs papers ~0.2-1.0 mV (somatic EPSP for unitary conn)

samn [10:08 PM]
but that's not a distribution

[10:08]
could be skewed

salvadord [10:09 PM]
uploaded this image: Kiritani's distribution of unitary conn soma EPSPs
Add Comment

samn [10:10 PM]
E?

salvadord [10:10 PM]
too strong - if reduce then get very few spikes — that why mentioned intermediate regime of operation — but will check better on single cell

[10:10]
y E

samn [10:10 PM]
so you use ~same distrib as E

billl [10:10 PM]
well the spiking will only happen if there is convergent input

[10:11]
not expecting ongoing activtiy except from the bg giving 1hz?

salvadord [10:11 PM]
same as E - I actually used weights from Lefort, which are in same range but depend on pre- and post- pops

billl [10:11 PM]
so the low baseline is what we want i think and then trying out inputs to give transient activations

samn [10:12 PM]
could use those homeostatic synapses too

salvadord [10:12 PM]
y but as soon as give transient inputs go quickly into depol

samn [10:12 PM]
hmm, not sure would help if go to dep block

[10:12]
transient inputs all excitatory?

salvadord [10:12 PM]
no, inh too

samn [10:13 PM]
and weights and time constants all "known"

[10:13]
synaptic time constants - haven't tweaked those?

billl [10:13 PM]
quote unquote

samn [10:13 PM]
yeah, some sort of known

salvadord [10:14 PM]
syn time constants - nope, used same u had for prev cortical models

samn [10:14 PM]
well, doubt they were perfect either :slightly_smiling_face:

[10:14]
might want to adjust reversal potentials too

salvadord [10:14 PM]
I think checked against some other paper and seemed reasonable

samn [10:14 PM]
ben's cells had lower RMP than what many people use in models

salvadord [10:14 PM]
guess dont really have specific data anyway

samn [10:15 PM]
so a lot of wiggle room

salvadord [10:15 PM]
yeah, will tweak stuff if needed, thanks

salvadord [10:19 PM]
uploaded this image: example raster with bkg inputs (0-2hz)
Add Comment

salvadord [10:20 PM]
uploaded this image: PT v trace
Add Comment

salvadord [10:21 PM]
thats just so u see an example

samn [10:22 PM]
would expect a lot more I cell activation

[10:24]
PV5B silent a lot

[10:24]
guess SOM and PV competing

[10:25]
maybe I->I gains off

salvadord [10:26 PM]
possible

samn [10:26 PM]
PV hits PT soma?

salvadord [10:27 PM]
y parasomatic region — ~50um around soma

samn [10:27 PM]
and PV mostly off

[10:27]
when on the dep block is gone

[10:27]
500 - 1000 ms

[10:28]
at least at one period

salvadord [10:29 PM]
also complex interactions, cause eg. L5A inh and L2/3 PV also target PT

samn [10:30 PM]
yeah, but overall looks like PV too silent (?) ... L2/3 PV also active at end when cell starts spiking again

salvadord [10:30 PM]
uploaded this image: local conn convergence
Add Comment

samn [10:31 PM]
complicated :slightly_smiling_face:

[10:31]
interesting display

salvadord [10:32 PM]
could be PV5B too silent — yeah complicate to try increase single pop rate (eg. PV5B) since so many interactions

samn [10:32 PM]
but might be due to the I -> I gains between PV and SOM

[10:32]
since they seemt o compete in the raster

salvadord [10:33 PM]
I’ve tried some batch sims for IIgain, but can try specifically for PV<->SOM

samn [10:33 PM]
yeah, i tweaked those separately to PV and SOM in some models...sometimes difficult otherwise

[10:33]
but good you keep constraints from the data where possible

salvadord [10:35 PM]
uploaded this image: IT5A also some depol
Add Comment

salvadord [10:36 PM]
will try playing around more with PV-SOM

samn [10:36 PM]
cool

salvadord [10:36 PM]
thanks

samn [10:36 PM]
np

**** Check modifying som-pv weights
- sam suggested too high since they seem mutually exclusive
- when pv not firing PT too high so depol
- also possible that prob of I->E generally too high (1*exp(-d/l) -- try 0.5* ?
**** DONE multiple cells hasd depol blockade - next steps?
- from v38_tune2: IT2 (partly), IT5A ,PT5B (partly), PV5A, PV5B, CT6
- so overall need lower EIGains - try 0.75
- also maybe param value steps too high -- missing good regions of stability!

- IPTGain = 4.0 looks reasonable - v37_batch2 - 2011
- PT weighNormThreshold of 3 -- looks like a good compromise

- run sim to check no depol blockade -- see what else needs to be fixed to obtain low rates:

- increase IT4 firing
- modify L6 separately to reduce firing in IT6 and CT6
- increase PV2 firing
**** DONE use joe's analysis to help figure out solution
`/u/graham/projects/eee/sim/batches/batch_analysis.py `

[1:41]
Only `get_vtraces` and `plotrelation2` are guaranteed to work right now.  See `plot_vtraces` for an example of using ‘em.

[1:42]
And let me know if anything doesn’t work and I’ll fix it.

**** overall had excessive input in many pops - solved by balacing IE,II in v38_batch2 and v38_batch3

*** DONE load json files faster using ijson
http://explique.me/Ijson/
https://www.dataquest.io/blog/python-json-tutorial/
http://lpetr.org/blog/archives/faster-json-parsing-python-ijson
https://github.com/isagalaev/ijson
https://pypi.python.org/pypi/ijson/

to install yajl in mac:
conda install --channel https://conda.anaconda.org/conda-forge yajl

- use hdf5??

- code:
def ijson_load(filename, gid):
    #import ijson
    import ijson.backends.yajl2_cffi as ijson
    from time import time

    print 'Reading data'
    with open(filename, 'r') as fd:
        # for item in ijson.items(fd, 'net.cells.item.gid'):
        #     print item

        start = time()

        objs = ijson.items(fd, 'net.cells.item')
        conns = next((cell['conns'] for cell in objs if cell['gid']==gid),[])

        print 'time ellapsed (s): ', time() - start

    return conns

*** DONE Network clamp
- even with weightNorm thresh at 2.0, depol blockade happens periodically
- seems like PT either few spikes+subthresh or quickly goes into depol block
- no intermediate regime of operation

- check again if get depol blockade with single cell stims
- test cell individually -- reproduce all incoming spikes:
-- check conns of cell: sec, loc, preGid, weight
-- check spk times of preGid cells
-- for each conn/syn, create vecStim with spike times

- remove weightNorm -- otherwise applied twice!

- DONE organize by prepop

- DONE check modifying weights

*** DONE Plotting 2d,3d,4d params with pandas
**** useful links

pandas
https://github.com/pandas-dev/pandas/blob/master/doc/cheatsheet/Pandas_Cheat_Sheet.pdf
http://pandas.pydata.org/pandas-docs/stable/visualization.html
http://pandas.pydata.org/pandas-docs/stable/api.html#api-dataframe-plotting
http://stackoverflow.com/questions/32114186/group-by-in-pandas-dataframe-and-unioning-a-numpy-array-column
http://pandas.pydata.org/pandas-docs/stable/groupby.html
http://wesmckinney.com/blog/groupby-fu-improvements-in-grouping-and-aggregating-data-in-pandas/
http://stackoverflow.com/questions/15003828/returning-aggregated-dataframe-from-pandas-groupby
http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel

seaborn
https://web.archive.org/web/20150404034126/http://stanford.edu/~mwaskom/software/seaborn/tutorial/dataset_exploration.html
http://stackoverflow.com/questions/41471238/how-to-make-heatmap-square-in-seaborn-facetgrid

pandas+seaborn
http://stackoverflow.com/questions/36577606/how-to-transform-a-pandas-dataframe-into-a-heatmap-compatible-dataframe

*** DONE adapt conn to match gmgs suggestions
- gmgms didn't include conn in initial diagram = L6 practically isolated
- could be overestimated in Weiler
- reduces complexity in terms of recurrent interactions

- check netclamp inputs

- further isolate IT5A <-> IT5B, PT5B->IT5B, IT6/CT6->IT5B!!
- reduce IT2,IT4,IT5As->IT5B
- lower L6->L2+L5

- from gmgs email:
Recurrent (i.e., IT-IT, PT-PT, CT-CT), intralaminar connectivity is present for all cell classes across all layers. Let’s
call these ‘medium’.


Major connectivity across classes (and layers):


IT-L4 projects (medium) to IT-L2/3 -- but IT-L2/3 does not project to IT-L4 (Yamawaki et al 2014)

IT-L2/3 instead projects (strong) to IT-L5A and PT in upper 5B (Anderson et al., plus others)

IT-5A projects (medium) to IT-L2/3 (Weiler)

IT-L5B and IT-L6 project (medium) to CT (Yamawaki & Shepherd 2015 J Neuro in press)

CT project (medium) to IT-L6 (Yamawaki & Shepherd 2015 J Neuro in press)

CT and PT don't interconnect (Yamawaki & Shepherd 2015 J Neuro in press)

IT connect to PT, but PT don't connect to IT (Kiritani et al 2012)



Thalamocortical (TC) input:

TC from motor thalamus (ventrolateral, VL) goes to L4, PT, IT-L5B, IT-L6upper (all medium). (Yamawaki et al., 2014; Yamawaki & Shepherd 2015 J Neuro in press)

VL axons don’t connect to CT (Yamawaki & Shepherd 2015 J Neuro in press)

TC from PO goes to ITs in L3, L4, L5A (medium)


Yamawaki Shepherd 2015 JNeuro (in press) -- this shows that disynaptic inhibition accompanies excitation in a precisely
'tuned' manner -- specifically, I/E ratio is specific for different presynaptic cells types, with CTs generating relatively
more I (i.e., higher I/E), than ITs; also, I is tuned to E at the level of each postsynaptic E neuron, independent of E cell
type. This holds in the extreme: an E neuron will get zero I if it gets zero E. If it does get E, the amount of I will be
tuned according to the I/E ratio for the presynaptic class. (This may sound more complicated than it is ... sorry)

"Photo- stimulation of PT neurons evoked strong E and I in a PT neuron, but essentially zero E and I in a neighboring CT
neuron, even though these neurons were separated by only  75  m. There- fore, from these experiments, we conclude that  disynaptic inhi- bition in these CT-related microcircuits is both postsynaptically cell specific, in that E and I remain proportional (‘balanced’) on a cell-by-cell basis according to the precise level of excitation received by individual postsynaptic neurons, and presynaptically class specific, in that the proportionality constant (ratio of I to E) varies according to the presynaptic (but not postsynaptic) pro- jection class."

---- CHANGES MADE:
**** 1) IT2->IT4 reduce or remove (Yamawaki et al 2014) - done
- difficult to differentiate between IT4 and IT5A because occupy same bin: 0.375-0.4375 (border = 0.41)
- swap values of bins predominantly for L2/3->L4 (0.3125,0.375) with L2/3->L5A (0.4375,0.5)
-- 16.0894	6.9846	2.4457 <-> 8.8509	4.5339	2.9227
-- divide by two the L2/3->L4 so its approximately 4x smaller than L4->L2/3

conn.py:
# 9b. Decrease L2/3->L4 strength based on Yamawaki et al, 2015 (~1/4 of L4->L2/3)
# swap high value of bin 0.375-0.4375 (predominantly L2/3->L4) with low value of bin 0.4375-0.5 (predominantly L2/3->L5A)
s_L23_L5A = list(smat[('W+AS_norm', 'IT', 'L4,5A,5B')][2,2:5])
smat[('W+AS_norm', 'IT', 'L4,5A,5B')][2,2:5] = smat[('W+AS_norm', 'IT', 'L4,5A,5B')][1,2:5]
smat[('W+AS_norm', 'IT', 'L4,5A,5B')][1,2:5] = s_L23_L5A
# decrease strength of L2/3->L4 by 2 so its approx 1/4 of L4->L2/3 (0.117 vs 0.38)
smat[('W+AS_norm', 'IT', 'L4,5A,5B')][1,2:5] *= 0.5

**** 2) reduce IT5B->CT to 0.5* IT->IT5B/IT6 (Yamawaki & shep 2015) - done
IT6 and IT5B neurons received approximately
twice as much IT input compared with neighboring CT neurons

IT->CT/ IT->IT-6: 0.62
IT->CT/IT->IT-5B: 0.43

(IT = mostly IT5B, some IT5A, sparse IT2/3+6

**** 3) reduce or remove IT2,IT4,IT5A<->IT5B - done
- maybe reduce overall EE?
- or increase IE for this layers -- evidecen from Yama ratios

- lower L5B (bin 0.5,0.6) -> L23 (bin 0.1-0.3)? (weiler)
- lower L5B -> L4,L5A? (anderson)
- both already quite low

- reduced IT5B, IT6 -> IT2,IT4, IT5A - * 0.75 (was already pretty low)
- reduced IT4,IT5A -> IT5B -  * 0.75 (was already pretty low)

**** 4) reduce or remove IT6,CT6->IT5B (Yama & Shep 2015) - done
CT->IT5B/CT->CT = 0.05  --> already 0 since no projections from CT->L5
CT->IT6/CT->CT: 0.58 -- similar so no need to modify (would need to split pre ['IT','CT'])

- reduce IT6->IT5B - *0.75

The CT neurons excited IT neurons, but primarily only those intermingled with them in layer 6, and not those in layer 5B.
**** 5) remove/reduce CT -> PV5/SOM5 (Yama & Shep 2015) - no need??
- already relatively low
**** 6) increase CT -> PV6/SOM6 (Yama &Shep 2015) -- done
wmat[celltype][2,2] = wmat[('W+AS_norm', 'IT', 'L6')][:,7:8].mean()*1.5 # increase L6 CT/IT->I (Yamawaki & Shepeherd 2015)

**** 7) Separate IT5->PV5/SOM5 from PT5->PV5/SOM5?? - no
- Yamawaki & Shepherd 2015 mentions separation of disynaptic inhibition by cell class
- Naka fig 1B clearly states PV shared between IT and PT

In turn,L5 PV cells connect onto surrounding L5 PCs at a very high rate, and diverg emassively, with one recent study
estimating that each L5PV cell inhibits >1000 L5 PCs (Packer andYuste, 2011, Figure1B). This has led to the proposal that PV
cells may provide a blanket of dense, non-specific inhibition to all excitatory cells (Fino etal., 2013).
Despite this promiscuous connectivity, some studies suggest that the PV population may preferentially inhibit specific PC
subtypes (Ye etal., 2015), though reports in L5 conflict over whether IT or PT cells receive more inhibition (Fariñas andDeFelipe, 1991;
Lee etal., 2014; Rock andApicella, 2015)



*** DONE PT cells firing too high
- requires I-PT weights ~x4
- probably due to PTweightnorm
- inhib inputs are perisomatic - so maybe effect not strong enough in PT since low RMP

- max numSyns per segment = 140!! too high,
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170514_212051.png][fig]]
-- TVL - 32
-- TPO - 13.5
-- S2 - 13.5
-- S1 - 10
-- OC - 13.5
-- M2 - 27
-- cM1 - 56

-- PT5B - 40 syn/seg
-- IT6 - 10
-- IT5B - 20
-- SOM5A - 4
-- SOM5B - 10
-- PV5B - 8
-- PV5A - 8

- when run single cell - syn dists ok -- cM1=18; total= 40syn/seg
- possible diff when run 1 vs 10k cells?

- check sim in my -- plotShape of PT5B (compare spiking vs non spiking PTs); compare with IT5A

- try redistributing syns in netClamp
-- redistributed from 140 -> 40 syn/seg
-- only small diff in firing
-- maybe cascade of small diffs leads to low firing
-- anyway need to check why not distributed properly
-- solved! was missing loc in netClamp!!

- the need for higher Inh input might be that weightNorm tuned to E conns but not I; might require different scaling;
most perisomatic!

*** DONE Bug - weight not adapted to new weightNorm after subConn distribution
- that means potentially high weightNorms could be applied to proximal dendrites
- could explain excessive PT firing!
- fixed - reduces PT firing, less need of inhib

*** DONE Bug - inh cells not firing, fixed 200+ mV voltage
- updat to use new PT ih, and run single sim to test output
- netpyne changes affected it somehow
- just needed to re-import and save
*** DONE Tune network with new ih

- check v42_batch29
--  all similar; can try a couple different ones
-- v42_batch30 - not major diff between ih; diff inputs drive differently, but modes of operation not clear

*** Lognormality of firing rates
**** How to test lognormality
- Shapiro-Wilk normality test (first compute log of data points) (work better with small sample size; sensitive to deviations)
-- Since the sample size is large, statistical hypotheses tests have a large power (1 - probability of II type error), and hence any small difference between your distribution and the null distribution (Normal distribution) is meaningful and leads to the rejection of the null hypothesis.
-- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3693611/ 
-- https://stats.stackexchange.com/questions/146765/normality-test-for-large-samples 
-- https://stats.stackexchange.com/questions/2492/is-normality-testing-essentially-useless
https://www.statisticshowto.datasciencecentral.com/assumption-of-normality-test/

- P-P plot Q-Q plot - asses visually - should be diagonal line (large sample size)
- Boxplot - symmetric box + whiskers; whiskers longer; median in center --> suggests normal distribution
"A boxplot that is symmetric with the median
line at approximately the center of the box and with symmetric
whiskers that are slightly longer than the subsections
of the center box suggests that the data may have
come from a normal distribution (8). ""
https://www.statisticshowto.datasciencecentral.com/assumption-of-normality-test/ 
https://www.statisticshowto.datasciencecentral.com/assumption-of-normality-test/

- Measure skewness and kurtosis -- <1.0 with large samples ()
-- An absolute value of the score greater than 1.96 or lesser than -1.96 is significant at P < 0.05, while greater than 2.58 or lesser than -2.58 is significant at P < 0.01, and greater than 3.29 or lesser than -3.29 is significant at P < 0.001. In small samples, values greater or lesser than 1.96 are sufficient to establish normality of the data. However, in large samples (200 or more) with small standard errors, this criterion should be changed to ± 2.58 and in very large samples no criterion should be applied (that is, significance tests of skewness and kurtosis should not be used)
-- https://www.thinkbrg.com/media/publication/720_720_McCrary_ImplementingAlgorithms_Whitepaper_20151119_WEB.pdf 
-- https://www.ibm.com/support/knowledgecenter/fr/SS3RA7_15.0.0/com.ibm.spss.modeler.help/dataaudit_displaystatistics.htm


**** Datasets to work on
- PT and IT cells (~3k of each)
- Single 50 sec sample
- 25 2 sec trials (average before or after stat or all samples)
- 25 5 sec trials (average before or after stat or all samples)

**** Prev results (from paper)
\note{CHECK lognormal VALUES -- use Shapiro-Wilk test for normality; "fit the rates and see if lognormal is significant"}
\note{$\mu = 0.85$ $\sigma = 0.95$ (\fref{spont}C)}
\note{($r=0.57$ for IT, $0.67$ for PT); r guide: .40-.59 “moderate”,.60-.79 “strong” http://www.statstutor.ac.uk/resources/uploaded/pearsons.pdf}
\note{also do stats over 5*5 seeds?}. 

**** Results
- 50 sec (1-51sec) 1 trial (log10)

-----
('IT2', 'IT4', 'IT5A', 'IT6'): 
lognormal mean=0.861501, std=0.919428, var=0.845348, skewness=-0.387778, kurtosis=-0.893755, ratioSkew=-7.947089, ratioKurtosis=-3.975118
Skew ratio: Sample does not look Gaussian (reject H0)
Kurtosis ratio: Sample does not look Gaussian (reject H0)
Shapiro-Wilk Test: Statistics=0.957, p=1.01522e-26
Shapiro-Wilk test: Sample does not look Gaussian (reject H0)
('IT2', 'IT4', 'IT5A', 'IT6'): min, Q25, median, Q75, max, IQR = -0.920819, -0.008774, 0.599883, 1.044540, 1.744136, 1.053314
IQ symmetry: 0.608657, 0.444657 ; Tails larger: 0.912045, 0.699597
('IT2', 'IT4', 'IT5A', 'IT6'): mu, sigma = 0.956734, 0.000000 

-----
PT5B: 
lognormal mean=0.843575, std=0.921962, var=0.850014, skewness=-0.321935, kurtosis=-0.868243, ratioSkew=-4.357030, ratioKurtosis=-2.180489
Skew ratio: Sample does not look Gaussian (reject H0)
Kurtosis ratio: Sample looks Gaussian (fail to reject H0)
Shapiro-Wilk Test: Statistics=0.966, p=2.22549e-15
Shapiro-Wilk test: Sample does not look Gaussian (reject H0)
PT5B: min, Q25, median, Q75, max, IQR = -0.920819, -0.017729, 0.536558, 0.999348, 1.666705, 1.017077
IQ symmetry: 0.554287, 0.462789 ; Tails larger: 0.903090, 0.667357
PT5B: mu, sigma = 0.965802, 0.000000 


- 25 1.5 sec (0.5-2sec) trials (25 trials * ~3k cells) -- check, not sure! 
PT5B:
Means: min, Q25, median, Q75, max, IQR = 1.417424, 1.682974, 1.787744, 1.872985, 2.004919, 0.190011
Means: mu, sigma, W, p = 1.770714, 0.147778, 0.956520, 0.000119
Stds: min, Q25, median, Q75, max, IQR = 1.091535, 1.191671, 1.230959, 1.257294, 1.411714, 0.065623
Stds: mu, sigma, W, p = 1.229091, 0.063192, 0.941872, 0.000007

('IT2', 'IT4', 'IT5A', 'IT6'):
Means: min, Q25, median, Q75, max, IQR = 0.074419, 0.648484, 1.682974, 1.826567, 2.004919, 1.178083
Means: mu, sigma, W, p = 1.343990, 0.625638, 0.803471, 0.000000
Stds: min, Q25, median, Q75, max, IQR = 0.662126, 0.950278, 1.191671, 1.240892, 1.411714, 0.290614
Stds: mu, sigma, W, p = 1.115124, 0.179571, 0.889783, 0.000000

**** DONE Get decent fI
- v43_batch8 - looks ok but make sure full fI looks decent!!
cfg.ihGbar = 1.0
cfg.ihGbarBasal = 1.0
cfg.ihlkc = 1.2
cfg.ihLkcBasal = 0.01
cfg.ihlke = -72

- shows reversal (v44_batch7) and inc rate (v44_tune54)
- need to confirm fI is ok - v44_batch8 -- rheobase is too high

- try playing with gpas and epas (bill suggestion)
-- v44_batch13: fI improved rheobase
-- v44_batch14: check if epsp reversal ok

- reduced rheobase might also cause more depol block? maybe not if keep slope constant

- v45_tune91 - compromise between fI and ih effects

**** DONE Avoid depol block
- v44_batch1 - depol block - lower PT weights/weightNorm?
- probably due to reduced axonNa --> higher fI rate, but also depol
- use v44_batch3 - EI balance
- v44_batch15 - EI balance with S2 20 hz
- v44_batch16 - long stim with 20 hz - still depol block

- maybe also try reducing 20hz -> 15hz?

- v45_tune91
- v47_batch5 - some no depol


** DONE Results: Dynamics/information flow in response to long-range stims and ih modulation; STR/SPI hypo; modes of operatio
*** functional M1 microcircuit model (not "canonical"), neural coding
*** gmgs suggestions in Chicago meeting
- what happens when you activate inputs from different regions (S2, thalamus)

- incorporate long-range connectivity from Ben's paper - main inputs:
-- Thalamus
-- M2 -> L1
-- S2 contralateral
-- M1 contralateral
-- Retrospinal only to small segment (vibrisal)
-- VM -> only layer 1

- data from Ben - S2, CT, scracm maps - L1
- increase the drive from these regions - with and without ih

- look at 2 inputs to M1, varying the time lag;
- thalamus and S2 maybe? or do all 3?
- look at interaction
- dual input experiment - vary timing and look at summation with/without ih (IT vs PT) !! - main priority

- purely M1 ? ih effect sheets paper fig 11?
- IT inputs - local, but similar paradigm
- during ongoing activity - spiking output depends on ih current (for same input) - if blocked higher firing
- apical tuft is basically disconnected
- why? narrows temporal integration window (high pass filter) - more temporal summation

- 2nd order question: hwo does synaptic distribution affect this results? use sCRACM maps
- striatal show higher EPSPs but fire very little
- view from soma is distorted (best but still not very good)
- more dendritic effects than somatic

- model = auxiliary tool bridge from invitro -> in vivo - how connections translate

- Thalamus -> L5 PT (randy bruno) - not necessarily through L2/3; only engaging PT without influencing the IT dominated
- Böhm, Schmidt jneuroscience 2016 - subiculum (IT-RS and PT-Burst equivalent)
- IT dominated if ih is high (noradrenaline control) - PTs only listening
- opposite long range driving the PTs; but doesn't involve IT

*** gmgs email
For mouse (forelimb) M1, I would mainly go with what's in the Yamawaki papers plus Ben's; basically:

VL --> L4 pyr (Yamawaki elife) and 5B PT and IT (yamawaki JNS), with the PTs getting input to tufts (suter)

VA is small and indistinct in the mouse; can ignore for M1 model IMO

PO --> upper layers, mainly 3/4/5A, according to yamawaki elife laminar profile

VL is core-ish; doesn't fit perfectly with core pattern because there are some axons in L1, but does mainly innervate L4 and L5B

PO is matrix, with axons to L1 and L5A

VM is matrix, with axons mainly to L1 (but some in 5A-ish), but only has weak projections to M1; projects mainly to anterior frontal areas; can ignore for M1 model IMO

Kaneko -- it's all anatomical projections, right? not connectivity. Where it's been looked at (yamawaki; petreanu; hooks), PO projections (defined as having L1 pattern, with or without the L5A band) have not been found to much input at all to PTs. But we do see an exception to this for VM inputs to PTs in anterior frontal cortex (area ALM).

The things that stand out about the M1 thalamo-cortico-thalamic circuits compared to S1 (and other sensory) is the LACK of
monosynaptic contacts between TC axons and CT dendrites, and between CT axons and TC dendrites -- i.e., it's not a "closed"
loop. IMO, this is the kind of first-order difference that could be explored in models and should give striking results, no?

The big picture for the M1 T-C-T circuits, IMO, is that there's no "tight" or closed loop; instead, activity flows necessary
via multiple cell types in the cortex -- i.e., TC inputs to IT and PT, ending up at CT via local circuits -- and multiple
nuclei in thalamus -- at a minimum, VL and PO and, I hate to say it, RTN, which complicates everything of course.

Hopefully that's more helpful than confusing ...

-Gordon
*** plot matrix of nTE/Granger betweeen main exc pops and inputs
*** Kaneko 2013 independent circuits
- Kaneko 2013:
It is proposed that two circuits sharing the same
TC projection and ML neurons are embedded in the neocortex: one includes L2/3 and L5
neurons, processes afferent information in a feedforward way and sends the processed
information to other cortical areas and subcortical regions; and the other circuit participates
in a dynamical system of theTC recurrent circuit and may serve as the basis of autonomous
activity of the neocortex.

- Constantinopple & Bruno 2013 (Science):
L4 is thus not an obligatory distribution hub for cortical activity, and thalamus activates two separate, independent
“strata” of cortex in parallel.
*** stimulation used in other papers
- Potjans and Diesmann: transient thalamic inputs at 15Hz spk rate for 10 ms
- Markram 2015: single pulse simult in 10-80 thalamic fibers
- Chadderdon 2013 (M1): subthresh stim (IClamp?) of 10-55% cells in a pop; duration?
- Bazhenov: thalamic stim 10 hz
- M1 grant: packets of 100 ms

*** chat with sam on osc inputs and LFPy
you ran single pulse stim on the network?
one of ideas from grant was looking at the "packets" and how they interact with ongoing dynamics
we had sections originally on all kinds of pulse stim vs osc stim -- not sure which best to start with;  think we also had  combo ideas for the 2 circuits? -- not recalling all the subaims we listed

packets - discrete inputs into specific locations of the circuit
discrete -> brief

but not an eshock -- something more like a set of coordinated bursts? -- what would a natural input look like?

the model has some form of LFP now?

maybe burst on particular phase of alpha or gamma

LFPy still not in there

and alpha/gamma - model has ongoing

LFPy not good
there's that paper by mhines on LFPsim


billl
oh :(  all that decade of work by gaute for nothing ?

samn [12:40 PM]
that works in networks in single pass...was using code from that to make point source model of LFP in network context, etc.

billl
but he keeps releasing new versions but going nowhere? -- someone should sit that boy down and talk to him!

samn [12:42 PM]
yeah, so have version that works pretty well - trying it in a diff model but if needed that could add to M1 possibly

[12:42]
if have some gauge of oscillation already can use that instead

[12:42]
or pick out oscillatory events (rather than ongoing)

billl [12:42 PM]
works well ~= LFPy not good ??


samn [12:42 PM]
LFPy not good, no

[12:43]
can't run in one pass

billl
[12:43 PM]
have a version of ... that works well

samn [12:43 PM]
well, still tweaking it...but hopefully won't take long


billl
[12:43 PM]
ok so you're own version of LFPy works well but LFPy from gaute is not good

samn [12:44 PM]
based on michael's version

salvadord [12:44 PM]
single stim - what I ran was increased input (increased from 2hz to 20hz) from the 7 long-range inputs from regions — somethign I will try next is from simulatenous regions (suggested by gmgs) and with oscillatory inputs (non uniform spiking)

samn [12:44 PM]
new feature of neuron to record all transmembrane current in a location

[12:44]
that makes it easier

billl [12:44 PM]
your version of michaels version of LFPy works well but gautes version does not work well

samn [12:44 PM]
fast imemb

[12:44]
michael's written independent of LFPy

[12:44]
has a forntiers paper on it but then he wrote his own better version

[12:44]
also in the allen biomodeling toolkit

billl
[12:44 PM]
oh ok

[12:45]
anyway

salvadord [12:45 PM]
however would like to check best baseline net to test all those stims — I have several recent batch sims I need to check

billl [12:45 PM]
how about sam works on osc inputs?

[12:45]
so not replicating same types of things

[12:45]
1st osc and then signals (packets) on top of osc

[12:46]
LFP - have implemented power spectra of firing rates — ~proxy for lfp

billl
[12:46 PM]
trying to get the network moved forward ..... but do we need to fix up the L5 models further?


[12:46] would be good to stick whatever sam is talking about into netpyne -- since just at the analysis level might be easy?  we hear much from mitra these days? could he do?

samn [12:47 PM]
yeah, useful for netpyne...

salvadord [12:47 PM]
add to netpyne - yeah would be useful
*** lakatos papers on laminar osc
- Global dynamics of selective attention and its lapses in primary auditory cortex
- Laminar Profile and Physiology of the α Rhythm in Primary Visual, Auditory, and Somatosensory Regions of Neocortex.

*** grant aim 4: input/output
- We will look at the role of the long distance inputs from other brain areas, including projections to and from other areas of
cortex, thalamus, striatum, etc.
- Extending from Buzsaki, Lisman and others, we hypothesize that activation from other cortical areas (grossly feedforward or
  feedback in the hierarchical conception of cortical organization) occurs via activation-packets, brief patterned inputs
- The efficacy of these activations depends on the resonance properties of the cortical network.
- The dynamical properties of the Layer 5 pyramidal cells contribute to this resonance directly, as well as through their
  involvement in the network.
- Prev focused on gamma as the representation, with a slower envelope (alpha or theta) as a carrier envelope
- Use information theoretic methods to follow information, allowing us to look for signal across frequencies bands
- local circuit responds differently to different projections based on laminar input location, input frequency, phase, and
  present dynamic state – depending on prior input history (signal integration) and intrinsic dynamical history (signal processing)
*** TODO stimulate via long range inputs + modulate ih; measure activation sequence, power spectra, nTE, Granger
- modes of operation - IT/CT, vs PT vs mixed
*** TODO cell-type specific response and statistics to stimuli -- figs 16,17 of Mark15
- check what grant mentioned re: packets and osc inputs

** DONE Results: Effect of Ih (17may15- ) :ih_results1:
- affects L23->PT syn integration -- different modes of operation
- check Bezaire SFN poster + Seku17 (skinner)
- reproduce fig 8,9,19 Sheets 2011 - spatial+temp integration L2/3->PT
*** Original ih conductances (gbar)
In [10]: for ks,s in p.secs.iteritems():
    ...:     for km,mech in s.mechs.iteritems():
    ...:         if km == 'ih':
    ...:             print ks,': ',mech['gbar']
    ...:
dend_16 :  6.6129403774e-05
dend_17 :  6.6129403774e-05
dend_14 :  6.6129403774e-05
dend_15 :  6.6129403774e-05
dend_12 :  6.6129403774e-05
dend_13 :  6.6129403774e-05
dend_10 :  6.6129403774e-05
dend_11 :  6.6129403774e-05
apic_8 :  0.000290796058841
apic_9 :  0.000353197496249
dend_18 :  6.6129403774e-05
dend_19 :  6.6129403774e-05
apic_7 :  0.000277650158036
apic_0 :  0.000112690527355
apic_1 :  0.000140684393465
apic_5 :  0.000216302939737
apic_2 :  0.000150736233675
apic_3 :  0.000190581827057
apic_27 :  0.00565
apic_26 :  0.00565
apic_25 :  0.00565
apic_24 :  0.00565
apic_23 :  0.00565
apic_22 :  [0.003033263234641989, 0.003890141868982288, 0.005650000000000001]
apic_21 :  0.00267844314351
apic_20 :  0.00215621225432
apic_29 :  0.00565
apic_28 :  0.00565
dend_63 :  6.6129403774e-05
dend_62 :  6.6129403774e-05
dend_61 :  6.6129403774e-05
dend_60 :  6.6129403774e-05
dend_67 :  6.6129403774e-05
dend_66 :  6.6129403774e-05
dend_65 :  6.6129403774e-05
dend_64 :  6.6129403774e-05
dend_68 :  6.6129403774e-05
apic_34 :  0.00565
apic_35 :  0.00565
apic_36 :  0.00565
apic_37 :  0.00565
dend_8 :  6.6129403774e-05
dend_9 :  6.6129403774e-05
apic_32 :  0.00565
apic_33 :  0.00565
dend_4 :  6.6129403774e-05
dend_5 :  6.6129403774e-05
dend_6 :  6.6129403774e-05
dend_7 :  6.6129403774e-05
dend_0 :  6.6129403774e-05
dend_1 :  6.6129403774e-05
dend_2 :  6.6129403774e-05
dend_3 :  6.6129403774e-05
soma :  6.6129403774e-05
apic_89 :  6.6129403774e-05
apic_88 :  6.6129403774e-05
apic_81 :  6.6129403774e-05
apic_80 :  6.6129403774e-05
apic_83 :  6.6129403774e-05
apic_82 :  6.6129403774e-05
apic_85 :  6.6129403774e-05
apic_84 :  6.6129403774e-05
apic_87 :  6.6129403774e-05
apic_86 :  6.6129403774e-05
apic_30 :  0.00565
apic_4 :  0.000194883130714
dend_49 :  6.6129403774e-05
dend_48 :  6.6129403774e-05
dend_45 :  6.6129403774e-05
dend_44 :  6.6129403774e-05
dend_47 :  6.6129403774e-05
dend_46 :  6.6129403774e-05
dend_41 :  6.6129403774e-05
dend_40 :  6.6129403774e-05
dend_43 :  6.6129403774e-05
dend_42 :  6.6129403774e-05
apic_96 :  6.6129403774e-05
apic_97 :  6.6129403774e-05
apic_94 :  6.6129403774e-05
apic_95 :  6.6129403774e-05
apic_92 :  6.6129403774e-05
apic_93 :  6.6129403774e-05
apic_90 :  6.6129403774e-05
apic_91 :  6.6129403774e-05
apic_98 :  6.6129403774e-05
apic_99 :  6.6129403774e-05
apic_38 :  0.00565
apic_39 :  0.00565
apic_18 :  [0.0011666691691727131, 0.0014051161901134166, 0.0018572014448675063]
apic_19 :  0.00211466257762
apic_16 :  0.000834928479208
apic_17 :  0.00106307881311
apic_14 :  0.000650073509309
apic_15 :  0.000761755971215
apic_12 :  0.00044490857439
apic_13 :  0.000583864576769
apic_10 :  0.000381276560036
apic_11 :  0.000426773017638
dend_58 :  6.6129403774e-05
dend_59 :  6.6129403774e-05
dend_52 :  6.6129403774e-05
dend_53 :  6.6129403774e-05
dend_50 :  6.6129403774e-05
dend_51 :  6.6129403774e-05
dend_56 :  6.6129403774e-05
dend_57 :  6.6129403774e-05
dend_54 :  6.6129403774e-05
dend_55 :  6.6129403774e-05
axon :  0.0
apic_102 :  6.6129403774e-05
apic_101 :  6.6129403774e-05
apic_100 :  6.6129403774e-05
apic_69 :  0.00565
apic_68 :  0.00565
apic_63 :  0.00565
apic_62 :  0.00565
apic_61 :  0.00565
apic_60 :  0.00565
apic_67 :  0.00565
apic_66 :  0.00565
apic_65 :  0.00565
apic_64 :  0.00565
dend_29 :  6.6129403774e-05
dend_28 :  6.6129403774e-05
dend_27 :  6.6129403774e-05
dend_26 :  6.6129403774e-05
dend_25 :  6.6129403774e-05
dend_24 :  6.6129403774e-05
dend_23 :  6.6129403774e-05
dend_22 :  6.6129403774e-05
dend_21 :  6.6129403774e-05
dend_20 :  6.6129403774e-05
apic_78 :  0.00565
apic_79 :  6.6129403774e-05
apic_70 :  0.00565
apic_71 :  0.00565
apic_72 :  0.00565
apic_73 :  0.00565
apic_74 :  0.00565
apic_75 :  0.00565
apic_76 :  0.00565
apic_77 :  0.00565
dend_38 :  6.6129403774e-05
dend_39 :  6.6129403774e-05
dend_34 :  6.6129403774e-05
dend_35 :  6.6129403774e-05
dend_36 :  6.6129403774e-05
dend_37 :  6.6129403774e-05
dend_30 :  6.6129403774e-05
dend_31 :  6.6129403774e-05
dend_32 :  6.6129403774e-05
dend_33 :  6.6129403774e-05
apic_45 :  0.00565
apic_44 :  0.00565
apic_47 :  0.00565
apic_46 :  0.00565
apic_41 :  0.00565
apic_40 :  0.00565
apic_43 :  0.00565
apic_42 :  0.00565
apic_49 :  0.00565
apic_48 :  0.00565
apic_31 :  0.00565
apic_52 :  0.00565
apic_53 :  0.00565
apic_50 :  0.00565
apic_51 :  0.00565
apic_56 :  0.00565
apic_57 :  0.00565
apic_54 :  0.00565
apic_55 :  0.00565
apic_58 :  0.00565
apic_59 :  0.00565
apic_6 :  0.000267990877461
*** DONE Parametrize ih in cfg/netParams


	# Adapt ih conductance based on cfg param
	for sec in cellRule['secs'].values():
		for mechName,mech in sec.mechs.iteritems():
			if mechName == 'ih':
				mech['gbar'] = [g*cfg.ihFactor for g in mech['gbar']] if isinstance(mech['gbar'],list) else mech['gbar']*cfg.ihFactor

*** Sam replicated fig 7 sheets
aEPSPs inputs -- ih reduces temp summation
sam:
tried similar with the cell - with keeping RMP fixed and letting it move - to look at effect on the EPSPs
when RMP held fixed then EPSPs increased with ih blockade
otehrwise had opposite
*** explanation of ih mechanism
gmgs didn't like abbott's paper...

something about interaction with other k channels

this paper: http://www.nature.com/neuro/journal/v12/n5/abs/nn.2307.html

think gmgs didn't like since not much km in SPI neurons

"The HCN channels generated an excitatory inward current (Ih) that exerted a direct depolarizing effect on the peak
voltage of weak EPSPs, but produced a paradoxical hyperpolarizing effect on the peak voltage of stronger, but still
subthreshold, EPSPs. Using a combined modeling and experimental approach, we found that the inhibitory action of Ih was
caused by its interaction with the delayed-rectifier M-type K+ current. In this manner, Ih can enhance spike firing in
response to an EPSP when spike threshold is low and can inhibit firing when spike threshold is high."

*** sam/gmgs on Ih sim results
Hi Sam (et al.) --

I'm pretty excited by these simulations -- if I understand correctly, altogether you can now recapitulate in silico key parts of the sheets et al study, including:
Fig 5 -- resonance
Fig 7 -- somatic current injection of alpha-synapse trains
Fig 10-11 -- synaptic input --> spiking output

Presumably you would be able to recapitulate the other results as well, e.g.
Fig 4 -- basically what Bill would call the 'channel effect map' for HCN
Fig 8 -- repetitive input for 1 input channel; like Fig 7, but for actual synaptic input (i.e., into dendrites, not somatic injection)
Fig 9 -- coincidence detection window for 2 separate inputs

Is that a correct summary?

From my perspective it seems like the significance is (1) your model does a pretty good job (some tweaking still needed, admittedly) of recapitulating the sheets data, which (unlike the purely mapping studies we've done; e.g. weiler et al) carry some interesting functional implications; (2) having essentially validated the model by recapitulating the experimental results, you are now in a position to explore in silico the parameter space in a way that's not possible experimentally (because the expts are hard), such as the frequency dependence as you've already started to do for the Fig 7 paradigm (which for me is less interesting though because it's artificial stimulation at the soma, not actual synaptic input from a defined presynaptic source).
Add Comment Collapse

samn [4:31 PM]
looking for where generated from

salvadord [4:32 PM]
thanks, have pointer to code?

samn [4:32 PM]
looking

[4:32]
/u/samn/ihtest

billl [4:33 PM]
gmgs excited! -- but not excited enough to have us visit ... :)

samn [4:33 PM]
:slightly_smiling_face:

[4:33]
code in sim.py; see how to run in the notebook

[4:34]
(/u/samn/ihtest/notebook.dol:996:25)

salvadord [4:35 PM]
thanks — so see big diff in RMP (-80 vs -92 mv) for ih vs no ih

samn [4:35 PM]
yeah, usually see that...you finding the same?

billl [4:35 PM]
RMP should be depol with ih since ih is an inward current relative to rest

samn [4:36 PM]
yeah

salvadord [4:36 PM]
y I have the same

samn [4:38 PM]
also "Regarding the Siegelbaum paper Sam mentioned -- you should definitely talk to Michele about this
-- he told us it's all wrong, and was working on simulations to show that, but I don't know if he
ever published that stuff. The Dembrow-Johnston study looked at cholinergic modulation of IT/PT."

[4:38]
anyway, not important since we have no km

salvadord [4:40 PM]
so also replicated same expt fixing RMP to -70 in both cases?

billl [4:40 PM]
fixing rmp or init at rmp?

samn [4:40 PM]
think i have that somewhere...hmm

[4:41]
maybe not

[4:41]
think key was how EPSP amp/peak measured

[4:42]
since with SPI+ZD RMP lower and overall depolarization lower, but there's still higher depolarization on successive EPSPs relative to first EPSP

[4:43]
and gmgs said get that effect whether hold RMP fixed or not ... makes sense, but seems more important how close to threshold you go

salvadord [4:46 PM]
y seems important, cause relative EPSP might be higher but not absolute; fig 8E actually superimposes PT with and w/o ih and w/o ESPS is higher — but wonder if he aligned RMPs or not

samn [4:47 PM]
yeah, prob held them fixed (via current clamp) for paper figures

salvadord [4:47 PM]
also seems he only adjusted RMP to -70 for fig 11 — at least doesn’t mention for rest

*** sam on sheets fig 11
I ran a test of AP production via stimulating a set of distal (> 200 microns from
soma) apical dendrites (ISI = 25 ms) with/without Ih, and with/without a current
clamp holding RMP near -80 mV when Ih was turned off.

First figure shows the case where current clamp holds RMP near -80 - the effect is
that shutting off Ih produces more spikes. Second figure shows the case where RMP is
free to move -->> shutting off Ih hyperpolarizes the RMP and fewer APs are produced.

Do you think this impacts the dynamic connectivity via Ih modulation idea? And similarly
how does this fit with Amy Arnsten's work (which seemed to show similar effects as Sheets -
though her work was in nonhuman primates in vivo and used dopamine, etc.)  . . .
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170531_175435.png][fig]]
*** notes from sam repo on ih tests
Just to follow up on the discussion of Ih effect on EPSP integration, we get the effect (see
attached; blue with Ih on, red with Ih off) if measure EPSP as max minus baseline but a little
lower (7-10% increase instead of ~20% increase). However, still seems that RMP effects of Ih
blockade (via neuromodulator) may dominate overall in a network setting. Next, I'll check
synaptic inputs at dendrite effect on AP output with Ih on/off.

gmgs> nice, looks promising

pick random dends to stim, look at EPSP/APs at soma ...

hmm, only need to stim a handful (or just 2!) of dends  and with fixed
frequency, do not need random timing ... that's how was done in sheets paper
when used L2/3 stimulation (fixed interval of 50 ms between the two
sets of L2/3 neurons stimulated)

so, get similar effect with the apical dend stim (as with somatic stim) ...
same effect, and more pronounced when do not use the iclamp ...

so next question is whether the ih on/off has an impact on AP generation
look at synaptic barrage - w/wo ih - w/wo iclamp - effect on APs
fig 11 of sheets paper specifically mentions the iclamp to -70 mV (or -80 if taking
into account LJP)

ok, now the effect is not there ... fewer APs when ih is off due
to the RMP shift ...

- WHEN ihoff sam adds IClamp of 0.1 to compensate for RMP
#cell.reconfig()
myrun(inj=0.0,clr='b') # that produces 7 spikes
ihoff()
myrun(inj=0.1,clr='r') # 10.0  spikes

savefig('gif/16aug9_f0.png')
savefig('gif/16aug9_f0b.png')

and now do the same thing but without the current injection for ih off ...

cell.reconfig()
myrun(inj=0.0,clr='b') # that produces 7 spikes
ihoff()
myrun(inj=0.0,clr='r') # that produces 1 spike

savefig('gif/16aug9_g0.png')
savefig('gif/16aug9_g0b.png')

ok, now the effect is not there ... fewer APs when ih is off due
to the RMP shift ...

blue = Ih ON; red = Ih OFF; this is WITHOUT Iclamp holding Ih OFF RMP fixed near -80 mV; when Ih
is off, there are now fewer spikes due to the lower RMP
[23:18]
samn in vivo there's no iclamp mechanism holding RMP fixed, so even if neuromodulators turn off
ih, i wouldn't expect heightened activity as a result ...

*** importance of ih by gmgms
I'm pretty excited by these simulations -- if I understand correctly, altogether you can now
recapitulate in silico key parts of the sheets et al study, including:
Fig 5 -- resonance
Fig 7 -- somatic current injection of alpha-synapse trains
Fig 10-11 -- synaptic input --> spiking output

Presumably you would be able to recapitulate the other results as well, e.g.
Fig 4 -- basically what Bill would call the 'channel effect map' for HCN
Fig 8 -- repetitive input for 1 input channel; like Fig 7, but for actual synaptic input (i.e.,
into dendrites, not somatic injection)
Fig 9 -- coincidence detection window for 2 separate inputs

Is that a correct summary?

From my perspective it seems like the significance is (1) your model does a pretty good job (some
tweaking still needed, admittedly) of recapitulating the sheets data, which (unlike the purely
mapping studies we've done; e.g. weiler et al) carry some interesting functional implications;
(2) having essentially validated the model by recapitulating the experimental results, you are
now in a position to explore in silico the parameter space in a way that's not possible
experimentally (because the expts are hard), such as the frequency dependence as you've already
started to do for the Fig 7 paradigm (which for me is less interesting though because it's
artificial stimulation at the soma, not actual synaptic input from a defined presynaptic source).

couple more thoughts on the input-output stuff -- it seems likely that in addition to the
HCN-related effects the spike-frequency adapation (SFA) could play a similar and complementary
role -- i.e., during high-frequ activity, HCN closure will boost output, which will be further
supported/boosted/etc by the sustained non-adapting/accel firing in cspinals in contrast to the
adaptation in cstriatals, which will contribute to the phasic signaling in that channel (this
stuff is written into the grant of course). i guess my point is simply that it seems like we're
at or close to the point where the HCN-related effects and the SFA-related effects could be
brought together, which would be pretty cool if it works out ...
*** Other refs that show increased net activitiy
**** Geor09
**** Pasp13 (Arnsten) fig 5 also shows increase in net firing rate (hippo)
**** Wang07b (arsnte) fig 4 - PFC
-  "reduction of the Ih results in significant enhancement of local recurrent network activity in cortical networks,presumably through enhanced effectiveness of dendritic synaptic potentials to initiate action potential activity"
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170518_113134.png][fig]]
- "HCN channel opening shunts synaptic inputs onto dendritic spines and reduces network activity"
"When HCN channels are open in the presence of cAMP, they pass Ih that lowers membrane resistance and effectively shunts synaptic input, reducing the functional connectivity of the network"
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170518_113105.png][fig]]
- "HCN inhibitory effects likely arose from nonspecific blockade of glutamate receptors at high doses" - dependence on cconcentration

**** Migliore 2012
- George 2009 M-type K current - wrong
-- "in CA1 pyramidal neurons the KM is localized in the axo-somatic region [6–7], and the rare channels found in the
dendrites [8] do not seem to affect synaptic integration "
-- "Ih, which is instead predominantly involved with synaptic
integration and with a predominant dendritic distribution.

- "A dynamic interaction between Ih and KM in a realistic model cannot reproduce the experimental findings."

- "Only under very special circumstances the effect of KM might result in a range of synaptic strength for which Ih would
  have an inhibitory effect. A particular example is an electrotonically very compact neuron that can be represented as a
  single-compartment model, as in George 2009."

- "In all cases, the KM needed to obtain a reasonable crossover effect was too high to allow repetitive firing at any input
  current" - fig 4

- "Here, using a realistic model we show instead how and why a shunting current, such as that carried by TASK-like channels
  [12–13], dependent on the Ih peak conductance is able to explain virtually all experimental findings on Ih

- "Using an additional current proportional to the Ih peak conductance, Ilk, we were able to model the excitatory and
  inhibitory effect of Ih in very good agreement with the experiments" - fig 5

- fig 2A - ZD -> lowers RMP -> lower firing rate
- fig 2B - ih x3 -> increased RMP -> increased rate
- fig 2C - ZD -> increased syn integration -> higher EPSP amp; ZD+Inj -> higher peak V  (50 Hz, w=1.7 nS, g_h_pk=0.01/cm2)
- fig 3,4 - failure of George 2009 model
- fig 5 - the puzzling excitatory/inhibitory effect of Ih can be explained in terms of a shunting current dependent on Ih
  channels; using different values of lk and Ilk reversal potential we were able to generate a crossover point between
  excitation and inhibition practically anywhere over the entire range of synaptic strength (Fig. 5c),

*** DONE check with na blocked; and fixed RMP
- "Resting membrane potentials were adjusted to -70 mV by somatic current injection through the patch pipette." Sheets 2011
- "ZD7288 also hyperpolarized the resting membrane potential (by -10 +- 3 mV) and increased the input
resistance consistent with the blockade of Ih" Sheets
- Sam: "keep in mind gmgs keeps RMP fixed in experiments"
- Sam: "ben's cells had lower RMP than what many people use in models"
- Sam: "i think gmgs mentioned that even when not holding RMP fixed that blocking Ih doesn't shift RMP much...maybe can ask him again, to clarify"

*** DONE levels, distribution, locations; inputs
*** DONE reproduce sheets figs
**** DONE Fig 4 - dendritic ih effect
- need to scale weight by dendritic density (otherwise too homogeneous)
- v40_batch12 - weight=0.003, ih1=2.0

**** DONE Fig 7 - somatic aEPSPs (IClamp?), 20 Hz, 5 pulses (sam reproduced - v40_manualTune)
- sam reproduced
- improved in v40_manualTune/tune36 - [[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20170525_211206.png][fig]]
-- same EPSP amp = ~5mV
-- same ZD ratio = 1.2 (although not increasing)
-- same ih ratio = close to 1.0

**** DONE Fig 8 - reduced temp summation; 20 Hz optogen stim of same L2/3 cells, 4 stims
- 20 Hz spike trains on single L2/3 site (how many cells!?) via photostimulation
- EPSP amps ~3mV (only 1st 1 or 2 clear EPSP; not in sync with 20hz pulses)
- can estimate num cells by assuming:
- Weiler says ~100 neurons fired per stimulus; if 20% conn -> ~20 neurons -> 100 syn contacts?
-- 5 syns/conn
-- weight=0.5/5 with weightNorm
-- somatic EPSP of 3 mV
-- distribution of inputs based on L2/3->PT

- when simulate get 4 epsps as in fig 7; what is difference with L23->PT?
-- different delays for diff cells/synaptic inputs?
-- activation of inh inputs? mentions monosynaptic but not if inh?
-- decline due to presyn effects: caged compound depletion and glutamate receptor desensitization.

- tried introducing noise=0.2 (+ overlayed by adding 10mV manually; not Iclamp)
- v40_tune60b

- not clear if really affecting temporal summation or just driving force difference
-- reproduced with Iclamp to match RMP and still got same result (actually higher epsp - interesting!)

**** DONE Fig 9 - narrow coinc detect; 20 Hz optogen stim of 2 L2/3 populations, 1 stim in each, modulate time lag
- 2 inputs from different L2/3 regions
- target different dends
- delay range between stim 10-200ms

- got match using noise=0.3, w=0.2, 100 stims - v40_tune68b
- plot across times - v40_batch14


**** DONE Fig 11 - increased PT rate; rapid stim of L2/3 (20,40 Hz); RMP adjusted to -70mV

- tested both 20 hz and 40 hz
- "To emulate rapid activity in multiple convergent inputs, we stimulated
ChR2-expressing layer 2/3 cell bodies and axons in rapid
succession across an array of locations at high frequencies (8 
16 stimulation grid, 65 m spacing; Fig. 10B) in a sequence
designed to maximize the spatiotemporal separation of sites
(“pseudorandom” order). This stimulation paradigm was used
to generate rapid and sustained barrages of EPSPs in corticospinal
neurons and APs (Fig. 10C)"
- 20 hz stim -> ~10hz corticospinal (with ih)
- for 20hz paper shows avg of ~7x more firing (but big range from <1x to 20x)

- v40_tune81 - 20hz

*** DONE Add Migliore H channel with shunt inhib
- replace h channel in PT
- check fI curve and traces
- check if distribution makes sense (use old one, adapt to CA1 cell?)
- adapt params of h Ilk so reasonable cross-point
- rerun sims for sheets figs
- run in model
*** DONE 3) Recheck fI curves with start=500ms
- redo all fI curves with start=500ms! (previously all started at 0ms!!)
** DONE Results: New fig comparing power in ih vs no ih
color = avg/sum/max power in 0-4 Hz (Delta) beta/gamma (25-40hz) 
y-axis = depth or pop
x-axis = time

for low vs high ih, so 4 panels total
** DONE Results: Improve Granger figure - bin size, duration, inh+L6, stats, reliability (Jun'19 )
*** bin size
- changeset fd9c11e671
bin sizes 1 and 2 produce wide curves, and may be picking up noise
bin sizes 3,4,5 show narrow peaks and are consistent with each other
switch to using 4 -- higher resolution but not picking noise
*** duration
1, 4, 50 secs produced similar results
*** include analysis for L6 cells and inhbitory cells
                    plt.plot(PV5_PT5B_f, PV5_PT5B_y2x, 'g-', linewidth=2.5, label = 'PV5 -> PT5B')
                    plt.plot(PV5_PT5B_f, PV5_PT5B_x2y, 'g:', linewidth=2.5, label = 'PT5B -> PV5')
                    plt.plot(PV5_IT5A_f, PV5_IT5A_y2x, 'r-', linewidth=2.5, label = 'PV5 -> IT5A')
                    plt.plot(PV5_IT5A_f, PV5_IT5A_x2y, 'r:', linewidth=2.5, label = 'IT5A -> PV5')
                    plt.plot(SOM5_PT5B_f, SOM5_PT5B_y2x, 'b-', linewidth=2.5, label = 'SOM5 -> PT5B')
                    plt.plot(SOM5_PT5B_f, SOM5_PT5B_x2y, 'b:', linewidth=2.5, label = 'PT5B -> SOM5')
                    plt.plot(SOM5_IT5A_f, SOM5_IT5A_y2x, 'm-', linewidth=2.5, label = 'SOM5 -> IT5A')
                    plt.plot(SOM5_IT5A_f, SOM5_IT5A_x2y, 'm:', linewidth=2.5, label = 'IT5A -> SOM5')

                    plt.plot(IT6_PT5B_f, IT6_PT5B_y2x, 'g-', linewidth=2.5, label = 'IT6 -> PT5B')
                    plt.plot(IT6_PT5B_f, IT6_PT5B_x2y, 'g:', linewidth=2.5, label = 'PT5B -> IT6')
                    plt.plot(IT6_IT5A_f, IT6_IT5A_y2x, 'r-', linewidth=2.5, label = 'IT6 -> IT5A')
                    plt.plot(IT6_IT5A_f, IT6_IT5A_x2y, 'r:', linewidth=2.5, label = 'IT5A -> IT6')
                    plt.plot(CT6_PT5B_f, CT6_PT5B_y2x, 'b-', linewidth=2.5, label = 'CT6 -> PT5B')
                    plt.plot(CT6_PT5B_f, CT6_PT5B_x2y, 'b:', linewidth=2.5, label = 'PT5B -> CT6')
                    plt.plot(CT6_IT5A_f, CT6_IT5A_y2x, 'm-', linewidth=2.5, label = 'CT6 -> IT5A')
                    plt.plot(CT6_IT5A_f, CT6_IT5A_x2y, 'm:', linewidth=2.5, label = 'IT5A -> CT6')

*** stats
- calculate stats over N=25x25
- plot mean, variance/std err, overlay in gray/colors
- box plot of max peak
- https://www.graphpad.com/guides/prism/8/statistics/statwhentoplotsdvssem.htm
*** reliability
http://users.sussex.ac.uk/~anils/aks_code.htm
https://www.statsmodels.org/stable/generated/statsmodels.tsa.stattools.grangercausalitytests.html

Not sure how to interpret the statsmode causality tests, so using instead shuffling method
**** grangercausalitytests for PT5B-> IT2 vs IT2-> PT5B
In [1]: from statsmodels.tsa.stattools import grangercausalitytests as gt

In [2]: tests = gt(np.array([histoCount1, histoCount2]), maxlag=10)

In [3]: histoCount1
Out[3]: array([11,  9, 12, ...,  0,  0,  0])

In [4]: data=np.array([histoCount1, histoCount2])

In [5]: data.shape
Out[5]: (2, 1499)

In [6]: tests = gt(np.array([histoCount1, histoCount2]).T, maxlag=10)

Granger Causality
number of lags (no zero) 1
ssr based F test:         F=332.2766, p=0.0000  , df_denom=1495, df_num=1
ssr based chi2 test:   chi2=332.9434, p=0.0000  , df=1
likelihood ratio test: chi2=300.6493, p=0.0000  , df=1
parameter F test:         F=332.2766, p=0.0000  , df_denom=1495, df_num=1

Granger Causality
number of lags (no zero) 2
ssr based F test:         F=286.5832, p=0.0000  , df_denom=1492, df_num=2
ssr based chi2 test:   chi2=575.0873, p=0.0000  , df=2
likelihood ratio test: chi2=486.6647, p=0.0000  , df=2
parameter F test:         F=286.5832, p=0.0000  , df_denom=1492, df_num=2

Granger Causality
number of lags (no zero) 3
ssr based F test:         F=191.5235, p=0.0000  , df_denom=1489, df_num=3
ssr based chi2 test:   chi2=577.2717, p=0.0000  , df=3
likelihood ratio test: chi2=488.1942, p=0.0000  , df=3
parameter F test:         F=191.5235, p=0.0000  , df_denom=1489, df_num=3

Granger Causality
number of lags (no zero) 4
ssr based F test:         F=142.9972, p=0.0000  , df_denom=1486, df_num=4
ssr based chi2 test:   chi2=575.4532, p=0.0000  , df=4
likelihood ratio test: chi2=486.8338, p=0.0000  , df=4
parameter F test:         F=142.9972, p=0.0000  , df_denom=1486, df_num=4

Granger Causality
number of lags (no zero) 5
ssr based F test:         F=88.2725 , p=0.0000  , df_denom=1483, df_num=5
ssr based chi2 test:   chi2=444.6361, p=0.0000  , df=5
likelihood ratio test: chi2=389.2282, p=0.0000  , df=5
parameter F test:         F=88.2725 , p=0.0000  , df_denom=1483, df_num=5

Granger Causality
number of lags (no zero) 6
ssr based F test:         F=55.5258 , p=0.0000  , df_denom=1480, df_num=6
ssr based chi2 test:   chi2=336.0809, p=0.0000  , df=6
likelihood ratio test: chi2=303.1179, p=0.0000  , df=6
parameter F test:         F=55.5258 , p=0.0000  , df_denom=1480, df_num=6

Granger Causality
number of lags (no zero) 7
ssr based F test:         F=43.8218 , p=0.0000  , df_denom=1477, df_num=7
ssr based chi2 test:   chi2=309.8679, p=0.0000  , df=7
likelihood ratio test: chi2=281.5499, p=0.0000  , df=7
parameter F test:         F=43.8218 , p=0.0000  , df_denom=1477, df_num=7

Granger Causality
number of lags (no zero) 8
ssr based F test:         F=37.8666 , p=0.0000  , df_denom=1474, df_num=8
ssr based chi2 test:   chi2=306.4267, p=0.0000  , df=8
likelihood ratio test: chi2=278.6813, p=0.0000  , df=8
parameter F test:         F=37.8666 , p=0.0000  , df_denom=1474, df_num=8

Granger Causality
number of lags (no zero) 9
ssr based F test:         F=34.6653 , p=0.0000  , df_denom=1471, df_num=9
ssr based chi2 test:   chi2=316.0173, p=0.0000  , df=9
likelihood ratio test: chi2=286.5984, p=0.0000  , df=9
parameter F test:         F=34.6653 , p=0.0000  , df_denom=1471, df_num=9

Granger Causality
number of lags (no zero) 10
ssr based F test:         F=31.2849 , p=0.0000  , df_denom=1468, df_num=10
ssr based chi2 test:   chi2=317.3246, p=0.0000  , df=10
likelihood ratio test: chi2=287.6590, p=0.0000  , df=10
parameter F test:         F=31.2849 , p=0.0000  , df_denom=1468, df_num=10

In [7]: tests2 = gt(np.array([histoCount2, histoCount1]).T, maxlag=10)

Granger Causality
number of lags (no zero) 1
ssr based F test:         F=1.8836  , p=0.1701  , df_denom=1495, df_num=1
ssr based chi2 test:   chi2=1.8873  , p=0.1695  , df=1
likelihood ratio test: chi2=1.8862  , p=0.1696  , df=1
parameter F test:         F=1.8836  , p=0.1701  , df_denom=1495, df_num=1

Granger Causality
number of lags (no zero) 2
ssr based F test:         F=153.4552, p=0.0000  , df_denom=1492, df_num=2
ssr based chi2 test:   chi2=307.9389, p=0.0000  , df=2
likelihood ratio test: chi2=280.0342, p=0.0000  , df=2
parameter F test:         F=153.4552, p=0.0000  , df_denom=1492, df_num=2

Granger Causality
number of lags (no zero) 3
ssr based F test:         F=156.1652, p=0.0000  , df_denom=1489, df_num=3
ssr based chi2 test:   chi2=470.6981, p=0.0000  , df=3
likelihood ratio test: chi2=409.2475, p=0.0000  , df=3
parameter F test:         F=156.1652, p=0.0000  , df_denom=1489, df_num=3

Granger Causality
number of lags (no zero) 4
ssr based F test:         F=88.0877 , p=0.0000  , df_denom=1486, df_num=4
ssr based chi2 test:   chi2=354.4847, p=0.0000  , df=4
likelihood ratio test: chi2=318.1074, p=0.0000  , df=4
parameter F test:         F=88.0877 , p=0.0000  , df_denom=1486, df_num=4

Granger Causality
number of lags (no zero) 5
ssr based F test:         F=31.7431 , p=0.0000  , df_denom=1483, df_num=5
ssr based chi2 test:   chi2=159.8928, p=0.0000  , df=5
likelihood ratio test: chi2=151.9019, p=0.0000  , df=5
parameter F test:         F=31.7431 , p=0.0000  , df_denom=1483, df_num=5

Granger Causality
number of lags (no zero) 6
ssr based F test:         F=17.3703 , p=0.0000  , df_denom=1480, df_num=6
ssr based chi2 test:   chi2=105.1373, p=0.0000  , df=6
likelihood ratio test: chi2=101.6005, p=0.0000  , df=6
parameter F test:         F=17.3703 , p=0.0000  , df_denom=1480, df_num=6

Granger Causality
number of lags (no zero) 7
ssr based F test:         F=16.8234 , p=0.0000  , df_denom=1477, df_num=7
ssr based chi2 test:   chi2=118.9601, p=0.0000  , df=7
likelihood ratio test: chi2=114.4555, p=0.0000  , df=7
parameter F test:         F=16.8234 , p=0.0000  , df_denom=1477, df_num=7

Granger Causality
number of lags (no zero) 8
ssr based F test:         F=21.1108 , p=0.0000  , df_denom=1474, df_num=8
ssr based chi2 test:   chi2=170.8342, p=0.0000  , df=8
likelihood ratio test: chi2=161.7361, p=0.0000  , df=8
parameter F test:         F=21.1108 , p=0.0000  , df_denom=1474, df_num=8

Granger Causality
number of lags (no zero) 9
ssr based F test:         F=25.1659 , p=0.0000  , df_denom=1471, df_num=9
ssr based chi2 test:   chi2=229.4190, p=0.0000  , df=9
likelihood ratio test: chi2=213.3834, p=0.0000  , df=9
parameter F test:         F=25.1659 , p=0.0000  , df_denom=1471, df_num=9

Granger Causality
number of lags (no zero) 10
ssr based F test:         F=23.8355 , p=0.0000  , df_denom=1468, df_num=10
ssr based chi2 test:   chi2=241.7648, p=0.0000  , df=10
likelihood ratio test: chi2=224.0329, p=0.0000  , df=10
parameter F test:         F=23.8355 , p=0.0000  , df_denom=1468, df_num=10

*** granger matrix
- all pops, with max peak
- 2 matrices, one for max amplitude; other for peak freq
- combine in bubble plot - size = amplitude, color = freq or viceversa
*** paper fig

- split psd_granger into psd and granger
- in granger include
-- single seed, 2 x pops
-- granger matrix
-- multiple seeds for L23->PT
-- top 5/10 granger stats

*** Discussion/Conclusions
Check if consistent with hypo that PT affects IT via inh using with Granger:
- PT -> PV5/SOM5 (low, sparse freqs) so unlikely PT -> Inh -> IT
- PV5 -> IT5A and PV5 -> PT5B (both medium/high, 35/45Hz)
- SOM5 -> IT5A and SOM5 -> PT5B (both medium/high, 30/35Hz)
- Hypothesis: PT -> IT5A (high) due to receiving same inh input (correlation, not causation)



** DONE Results: Improve osc and phase-amp coupling fig - stats (Jun'19)
- using Kopells' modulation index
- index high for 1hz (phase) and 35-40 hz (amp), but if do shuffling z-score analysis not so clear
** DONE Methods: Fill missing values in paper (19Aug15)
*** notes from paper
ADD values of model cells f-I slope and rheobase

- Yamawaki 2015: 
-- f-I slope (Hz/nA): L23=63, L4=80, L5A=103
-- Ithresh (pA): L2/3=267, L4=295, L5A=163

- Suter, 2013 (temp 34$^o$C):
-- CSTR rheobase: 182 (SPI: 341); 
-- f-I slope (Hz, nA): CSTR= 61, SPI= 98

- Oswa 2013 (temp 26$^o$C):
-- fI slope (HZ/nA): CSTR=88, SPI=82, CTh=69, CC (upper layers?)=82
-- max feq (Hz): CSTR 29, SPI=34, CTh=26, CC=30
-- I50\%maxfreq (pA): CSTR=214 (15hz), SPI=273 (17hz), CT=486 (13Hz) , CC=332 (15hz)
-- at 34$^o$C all higher -- CSPI higher rates than rest

*** use 1 for upper layers, and other for lower
- IT2, IT4, CT6 use simple BS1578 with adapted L (higher rheobase/Ithresh, smaller fI slope; Yamwaki 2015, Oswa 2013)
- IT5A, IT5B, IT6 use simple/detailed BS1579 (lower rheo, higher fi slope; Yamawaki 2015, Suter 2013, Oswa 2013)
- (not using detailed BS1578) - differentiate upper (1578) vs lower (1579) ITs; and lower IT (1579) vs CT (1578)
*** use detailed IT only for L5A ??
- strong connections to IT L5A not 5B
- use detailed BS1579 for IT L5A; reduced BS1579 for IT L5B

- several diffs: eg. CT input resistance lower than IT + PT; sag higher than IT + PT; more adaptation than IT+PT ...

- in model, higher rheobase + lower firing rates: evidence in OSwa 2013 (I50\% significantly higher ~480pA vs ~250pA; no rheobase values)
*** Calculations
IClamp1_pop   IT2   IT4  IT5A  IT5B  PT5B   IT6   CT6
IClamp1_amp                                          
0.00          0.0   0.0   0.0   0.0   0.0   0.0   0.0
0.05          0.0   0.0   0.0   0.0   0.0   0.0   0.0
0.10          0.0   0.0   0.0   0.0   0.0   0.0   0.0
0.15          0.0   0.0   2.0   5.0   0.0   0.0   0.0
0.20          0.0   0.0  11.0  10.0   0.0   9.0   0.0
0.25          0.0   0.0  15.0  15.0   0.0  14.0   0.0
0.30         11.0   7.0  20.0  19.0   5.0  19.0   0.0
0.35         15.0  11.0  25.0  25.0  15.0  23.0   0.0
0.40         18.0  15.0  30.0  29.0  20.0  28.0   6.0
0.45         22.0  18.0  35.0  34.0  25.0  33.0  11.0
0.50         25.0  21.0  40.0  39.0  29.0  38.0  14.0
0.55         29.0  24.0  46.0  45.0  33.0  44.0  18.0
0.60         33.0  27.0  51.0  49.0  38.0  49.0  21.0

slope and rheobase of:
- IT5A (suter model/exp) == IT4
-- slope: 27 / (600 - 250) =  77 Hz/nA
-- rheobase: 250 

- IT5B (suter model/exp) == IT5B
-- slope: 49 / (600-100) = 98Hz/nA
-- rheobase: 100


- L2/3 + L4 IT cells (exp):
-- Yamawaki 2015: f-I slope (Hz/nA): L23=63, L4=80, L5A=103; Ithresh (pA): L2/3=267, L4=295, L5A=163
-- Avg slope: (63+80)/2 = 71.5
-- Avg rheobase = (267+295)/2 = 281

- L5A, L5B, L6 IT cells (exp):
-- Yamawaki 2015: f-I slope (Hz/nA): L23=63, L4=80, L5A=103; rheobase (pA): L2/3=267, L4=295, L5A=163
-- Suter, 2013 (temp 34$^o$C): f-I slope (Hz, nA): CSTR= 61, SPI= 98; rheobase: CSTR: 182; SPI: 341  # slope not consistent
-- Oswa 2013 (temp 26$^o$C): -- fI slope (HZ/nA): CSTR=88, SPI=82, CTh=69, CC (upper layers?)=82
-- I50\%maxfreq (pA): CSTR=214 (15hz), SPI=273 (17hz), CT=486 (13Hz) , CC=332 (15hz)
-- evidence in Oswa 2013 (I50\% significantly higher ~480pA vs ~250pA; no rheobase values)
-- calculate rheobase from I50%:
-- I50\%maxfreq (pA): CSTR=214 (max: 29.2hz; 88 hz/nA), CT=486 (max: 26Hz; 69 hz/nA), CC=332 (max: 25.2hz; 82 Hz/nA)
-- rheobase = (-(maxfreq/2) + slope*I50) / slope
-- rheo CC (L2/3+4) = ((-25.2/2) + 0.082*332) / 0.082 = 178 pA
-- rheo CSTR (L5A,5B) = ((-29.2/2) + 0.088*214) / 0.088 = 48 pA
-- rheo CT (L6) = ((-26/2) + 0.069*486) / 0.069 = 298 pA
-- Avg slope: 103 (Yama), 88 (Oswa) = (103+88)/2 = 96 Hz/nA
-- Rheobase: 163 (Yama), 48 (Oswa) = 106 pA

- L6 (exp):
-- CT=486 (max: 26Hz; 69 hz/nA); rheo CT (L6) = ((-26/2) + 0.069*486) / 0.069 = 298 pA
-- Slope: 69
-- Rheobase: 298
** DONE Results: Compare granger matrix with conn matrix (Sep'19)
*** Do I have conn matrix by pops?
- have strength matrix by pops, but tricky to interpret because PT5 use 5 syns vs 1 syn
-- have data so could potentially scale down by 5, if need to plot
- also have conn prob matrix but not comparable
- also have source data (paper fig connPops) 
- plot conn matrix for paper?? wait for reviews? maybe plot with PT5Bup vs down
*** Compare strongest projs in granger matrix
- Strong projections in Granger:
-- IT2/3 --> IT5A (yes), PV5A (no), upper PT5B (yes) and PV5B (no)
-- SOM2 --> IT5A (no), PV5A (no), upper PT5B (no) and PV5B (no)
-- PV5A (yes), PV5B (yes) and IT5B (yes) --> upper PT5B
-- IT4 --> IT5A (~, boundary effect from strong IT2->IT5A)
-- summary: present in Granger but not Conn: 
--- IT2->PV5A,PV5B; 
--- SOM2->IT5A,PV5A,PT5B,PV5B

- Strong projections in Conn matrix:
-- IT2 -> IT5A (yes), PT5B (yes)
-- IT4 -> IT2 (yes), PT5B (yes)
-- IT5A -> PT5B (yes; both low)
-- IT5B -> PT5B (yes)
-- PV2 -> IT2 (comparatively low in granger), IT4 (no)
-- PV5A -> IT5A (yes), PT5B (comparatively high in granger)
-- PV5B -> IT5A (yes), IT5B (yes), PT5B (yes), SOM5B (comparativ low in granger), PV5B (comparativ low in granger)
-- PV6 -> IT6 (no), CT6 (no) 
-- summary: present in Conn but not Granger: 
--- PV2->IT2 (comparatively low in granger), IT4 (no)
--- PV5A->PT5B (comparatively high in granger)
--- PV5B->SOM5B (comparativ low in granger)
--- PV6->IT6 (no), CT6 (no) 
** TODO Results: Compare model results to exp data (Oct'19)
*** email from elife editors
Dear Dr Dura-Bernal,

Thank you for choosing to send your work entitled "Multiscale dynamics and information flow in a data-driven model of the primary motor cortex microcircuit" for consideration at eLife. Your initial submission has been assessed by a Senior Editor in consultation with a member of the Board of Reviewing Editors. Although the work is of interest, we are not convinced that the findings presented have the potential significance that we require for publication in eLife.

A principal concern was that the paper falls between a tools and resources paper and a scientific report, without a clear goal. 
It seems to the BRE more like a resource: using the rigor and formalism of modeling to ensure the complete and reproducible assembly of a body of data. Not much in the way new prediction is presented. The authors may have made a useful resource, but as presented the match to data is not fully convincing. Also, the availability of the resource isn't clear - without that it isn't a true resource either. If this is the goal of the paper, then it might fit better in a neuroinformatics/computational journal.
It appears that the authors have excellent small-scale data: physiology, anatomy, some connections. They have some network-level readouts like LFP and population firing patterns, but as presented the authors don't make a good case for how well they have matched this to the brain biology. At the high level it is still harder to make out whether the network as a whole does the right computations for M1. This is possibly where one would go from doing a resource to doing a research study, developing predictions and analyses that could be tested. More comparisons to data would be needed, e.g., for Figures 3, 4, 5, 6, 8, 9.


We return a high proportion of articles to authors without passing them on for in-depth peer review so that they can be promptly submitted elsewhere. This is not meant as a criticism of the quality of the data or the rigor of the science, but merely reflects our desire to publish only the most influential research. We wish you good luck with your work and we hope you will consider eLife for future submissions.

Best wishes,

Ronald Calabrese
Senior Editor, eLife


*** refocus the paper on comparison to exp data!
*** Schi15 (key paper)
- Particularly focus on Schiemann et al 2015: mouse M1 in vivo

- 2 states:
-- quiet (wakefulness) --> ih = ? (1.0, 0.75, 0.25?); only bkg inputs
-- movement (self-paced, voluntary) --> ih = 0.25 + increased VL or other inputs


**** L5B (IT and PT) show enhanced vs suppressed responses from quiet to movement (Fig 1)
**** TODO reproduce Fig1
TODO stats of enhanced vs increased response in quiet vs movement
TODO run long sim with VL input (4 sec); and low vs high ih
**** Power spectra and spectrogram (Fig 3) 
-- movement increases gamma, decreases delta/theta
**** TODO reproduce Fig3
TODO freq analysis of high ih; quite and movement conditions
**** Tests 2 inputs (Fig 4):
-- L2/3 response: quiet vs movement --> same
-- Inactivate VL (motor thalamus) 
    --> reduced base/quiet rates 
    --> increased basal Vm slow osc
    --> similar relative increase for movement (but overall lower) -- unclear
    --> suggests always have some VL 
    --> unlikely main source of excitatory drive; but needed to maintain exc level
**** TODO reproduce Fig4
TODO remove VL input sims
**** 2 neuromodulation conditions (Fig 5,6)
-- Ctrl: noradrenergic inputs from LC (low ih) 
-- NA-R antagonist: NO noradrenergic inputs from LC (high ih)
    --> lowered Vm 
    --> lowered base/quiet firing rate (5 -> 1 Hz) -- suggests low ih in quiet state; but even lower in movement?
    --> reduced num of neurons that get enhanced
    --> modest supression of quiet rates vs strong suppression of movement rates

**** TODO reproduce Fig5,6
TODO very high ih sims?
TODO rates of high ih (enhanaced vs suppressed neurons)
TODO run long sim of high ih + VL
**** Open questions: 
Note: could model VL inactivation by removing VL; and assume exc input coming M2, S1, S2? not clear what triggers the movement
Note: same level of noradrenergic input in quiet vs movement??
    -- article assumes noradregenrgic -> movement, so blocking affects more movement than silent; but still some in quiet

1) noradrenergic input (ih level) in NA-R antagonist vs quiet vs movement? compared to in vitro?
- ih in vitro = 1.0
- ih NA-R antagonist = 1.0
- ih quiet = 0.75
- ih movement = 0.25

2) VL input in inactivate VL vs quiet vs movement?
- inactivate = 0
- quiet = 0-5 Hz
- movement = 0-5 Hz, higher? unknown?
**** email to Schi15 authors
Dear Ian,
 
Thanks so much for your quick response and your interest on our paper. And thanks for offering to share the Cell Reports paper data. I've also been looking at your biorxiv paper and seems like could be very useful as well. I must say I'm really excited about your research! Of course, the Neuropixel data across layers would also be incredibly interesting to tune and validate the model. A Skype meeting in the coming weeks sounds like a great idea.
 
In the meantime, I'm trying to figure out what would be a reasonable way to to compare our model to your results, and have a couple questions:
 
1) "noradrenaline modulates voltage-dependent and voltage-independent potassium conductances and HCN channel" – in our model we only modulate HCN conductance (ih) in PT cells; do you have any indication of the importance of voltage channel modulation and of channel modulation in non-PT cells in your results?
 
2) Regarding PT ih, is it reasonable to assume these 3 cases:
- "NA-R antagonist": high ih (perhaps similar to PT cells in vitro?)
- "quiet": medium (?) ih (since NA-R antagonist base rates are lower)
- "movement": low ih (since NA-R antagonist reduced SBR)
 
3) Regarding the avg firing rate of MTh inputs, is it reasonable to assume these 3 cases:
- "Muscimol": 0 Hz
- "quiet": <5 Hz (spontaneous)
- "movement": >10 Hz (perhaps the biorxiv paper provides some data?)
 
Sorry if I'm misinterpreting something from the paper! Also happy to talk about these questions via skype, if that's easier.
 
Thanks again!
Salva
*** fig 3 (spont firing)
**** DONE spike stats for high ih
**** Model stats
In [11]: IT=data1['statData'][0]

In [12]: PT=data1['statData'][1]

In [15]: CT=data1['statData'][2]

In [16]: SOM=data1['statData'][3]

In [17]: PV=data1['statData'][4]

In [18]: np.mean(IT)
Out[18]: 6.2879986268451775

In [19]: np.std(IT)
Out[19]: 8.108233558280835

In [20]: np.mean(PT)
Out[20]: 6.122336

In [21]: np.std(PT)
Out[21]: 8.148047421505597

In [22]: np.mean(CT)
Out[22]: 1.1090125673249551

In [23]: np.std(CT)
Out[23]: 2.3126808170997184

In [24]: np.mean(SOM)
Out[24]: 8.881327433628318

In [25]: np.std(SOM)
Out[25]: 17.583617274838772

In [26]: np.mean(PV)
Out[26]: 20.61330016583748

In [27]: np.std(PV)
Out[27]: 30.14233982793863


IT2: 2.94 +- 4.86
PV2: 4.82 +- 13.19
SOM2: 11.54 +- 20.03
IT4: 1.39 +- 3.31
IT5A: 11.66 +- 10.39
PV5A: 32.39 +- 41.31
SOM5A: 2.80 +- 6.50
IT5B: 4.66 +- 4.98
PT5B: 6.12 +- 8.15
PV5B: 20.48 +- 28.02
SOM5B: 0.74 +- 1.55
IT6: 6.85 +- 7.49
CT6: 1.11 +- 2.31
PV6: 4.61 +- 5.39
SOM6: 15.47 +- 21.05

**** L5 IT/PT and FS - Este18 Fig 8 (mouse M1)
***** UPDATE: author will send data (Luc Estebanez)
***** initial data extracted from paper
- using automeris.io web app
- see figs in data/rates folder
- x values = baseline firing

left panel (acoustic):
0.5039695742640582, 1.320926944167411
1.4648618119254664, 18.149407023294504
1.2940894624731492, 3.9479139968438552
3.2177865098402947, 10.995622313527436
4.023353338457383, 2.195735215512496
5.014341071862976, 13.385295947356177
6.86951364535425, 6.86763708305952
4.56361026711652, 14.872555781311164
5.7409361194475, 17.67420359013552
2.8428803101757794, 13.850616064272
11.742390068410167, 12.437004865136913
2.9802225660335147, 8.675228810557908
8.788114899248793, 8.451768039219342
1.687773780453707, 5.065110817007472
0.40307938934143905, 2.856599623464497
mean = 4.07 4Hz

Initial data provided by author
FSU:
In [34]: np.mean(data['baseline'][0][0][2][0])
Out[34]: 0.9760898680632507

In [37]: np.std(data['baseline'][0][0][2][0])
Out[37]: 2.627176093230978

PV+:
In [35]: np.mean(data['baseline'][0][0][1][0])
Out[35]: 0.47076502117329955

In [36]: np.std(data['baseline'][0][0][1][0])
Out[36]: 0.8141249297402194

RS:
In [38]: np.mean(data['baseline'][0][0][0][0])
Out[38]: 1.2058724660462825

In [39]: np.std(data['baseline']Fig[0][0][0][0])
Out[39]: 2.794292730997477

***** emails with data
email 1:
I went back to the raw data to provide you with what is the closest possible to a "clean" baseline measurement. Attached is the data for all RSU (putative pyramids), all FSUs (putative PV+ neurons, including not confirmed by optogenetics) and all optotagged PV+ neurons. 
 
I included the firing rate measured in two different times:
- across the whole session, including the reaching time (left plots in the figure)
- at the time at the start of the electrophysiological recording, where there is an idle time of a few minutes before the start of the behavioral session (right plots). To me this is what you want to consider as a baseline activity
 
Attached is a mat file (created with numpy) that contains the data. Please let me know if you are lost in the file or it or if it simply does not open (I have no access to matlab right now). 

email 2:
No problem. I have added to the data file the firing rate of the different neuron groups in response to the auditory and vibrotactile stimuli, as well as around the paw movement. I did not know what you would need specifically in terms of integration window, so for the stimuli I provided a vibration_base category that corresponds to the firing rate in the 1 sec just before the stimulus onset. In addition there are vibration_10 ; 100 and 1000 categories that correspond to the firing rate in a 10, 100 and 1000 ms window just after the stimulus onset. The same is available for the sound. 
Finally, for the movement, the base is measured from 2 to 1 s before onset, and the 10,100 and 1000 categories are measured in windows that are centered on the movement onset, rather than just after the event onset. 

***** stats from data
In [10]: for k in matData.keys():
    ...:     try:
    ...:         print(k, matData[k][0][0][2][0].mean())
    ...:     except:
    ...:         pass
    ...:     

Note: 
task = whole behavioral session, including reaching time
baseline = few minutes before the start of the behavioral session
_base = during behavioral session, before stimuli


PV+:
baseline 0.8381933678159436
task 3.3562970595196817

sound_base 2.9271506924731483
sound_10 16.74035816635072
sound_100 12.786856523441381
sound_1000 5.3094853531267985

vibration_base 3.1481288870328292
vibration_10 14.589104878142471
vibration_100 12.473976360077819
vibration_1000 5.738630888650489

movement_base 3.3156244065421903
movement_10 7.2024417430674434
movement_100 7.093480837323666
movement_1000 5.836803887579924

FS:

baseline 0.22463851958450787
task 2.9680986807432466

sound_base 2.70412062819765
sound_10 31.05408822608179
sound_100 19.993051902316676
sound_1000 6.189427658526788

vibration_base 2.5492123933884487
vibration_10 27.22905262228607
vibration_100 18.240757350284905
vibration_1000 5.74237083235043

movement_base 2.5856538067433887
movement_10 6.627879333885193
movement_100 6.604708359413665
movement_1000 5.109113267003974


RS:
task 3.9140401817450368
baseline 1.1095998674124878

sound_base 3.2125063707884856
sound_10 2.91738818654647
sound_100 6.025482278813834
sound_1000 4.3613917310145816

vibration_base 4.108988781012601
vibration_10 4.389829371169816
vibration_100 7.115003448443269
vibration_1000 5.466080561025331

movement_base 4.249572783670213
movement_10 6.577048584635832
movement_100 6.634630285486381
movement_1000 5.660519932477458


**** L2/3 IT, L5B IT/PT - Schi15 Fig 1 (mouse M1)
**** L2/3 IT, L5 IT/PT - Zhag15 Fig 1 (mouse M1)
**** L2/3 IT, L5 IT/PT - Sree16 (mouse M1)
**** PT upper vs lower - Econ18 (mouse ALM)
**** Dacr19 (mouse M1)
spont rates similar for both
*** fig ih + long-range inputs
**** Schi15 L2/3 input (=sensory thalamus?)
**** Schi15 TVL input (motor thalamus) stimulated (initiates movement!!) and inactivated 
suggesting input from the motor thalamus—either direct or indirect—is essential for maintaining L5B pyramidal neuron Vm near threshold, but is unlikely to be the main source of the increased excitatory drive.
**** Dacr19 TVL input (specific subregions of VL) inactivated
**** Este18 reaching (=sensory or motor input?)
**** Zhang15 licking (=vibrotactile trigger=sensory or reach=motor input?)
**** Econ19 reaching (upper vs lower; prepare vs execute; ALM)
**** Sree16 (before and after movement; licking)
**** Sree16 - remove S1 input (decrease L2/3 and L5 rates)
**** Sree16 - stimulate S1 input (rebound response L2/3 and L5 rates)

*** fig osc
**** Andi17 - phase-amplide coupling delta-gamma (rat PFC) - fig 3B
**** Naze18 - LFP PSD phase-amp coupling delta-gamma (cortex and striatum); phase-locking!!! Batman
**** Schi15 - Vm lfp - movement increases gamma; decreases beta
**** Zhag15 - LFP and MUA power (spont vs movement)
- during hit trial, licks (pre- and movement): anticorrelation / antiphase of enh vs suppressed in sync with LFP [low ih?!]
- during inter-trial high amp lfp: enh v suppressed in phase; antiphase with LFP
**** Zobe18 - LFP low vs high ih (fig 1); spectrogram with freq modulation (fig1); low ih increase in high freqs; decrease in delta
**** Zobe19 - reducing ih - increased delta; reduced rest of osc (related to TC osc) - fig 7
**** Mahe17 - EEG mouse; phase-amp coupling delta/theta and gamma


** TODO Write paper
% = include in paper
*** overleaf vs sharelatex
***** overleaf
- $12/month (20% less for 1 year; 30%+ for group license)
- repo from any git
- section folding
- realtime preview
- rich text mode
- full document history (like gdoc)
- find errors fast
- biorxiv
- images - add file to project; add latex code manually;
- refs - cite{ list of refs (no search)
- suggest list of latex commands
- built-in comments
- cannot customize font (too wide)
- no online tracking of changes -- see who modifies doc
- git commits all say "Updated via Overleaf" - maybe can change?
***** sharelatex
- $15/month (group discounts?) + $7/month (github private)
- real time collab (like gdoc)
- commenting+track changes like word
- cite{ - list of refs and search option
- images - adds latex code automat
- full history
- biorxiv

*** journal
- prepublish in Biorxiv -- can submit to our journals of interest http://biorxiv.org/about-biorxiv
- eLife (frances skinner, farzan nadim) - 7.5

- science advances - 12.8 (15k words, 6 figs, 40 refs)
- nature comms - 11.8 (5k words, 10 figs)
- PNAS 9.8 (7k words, 10 figs 70 refs; initial submission doesn't require special formatting)
- Cell reports 7.8 (~8,9k words, figs?; initial submission doesn't require special formatting)
- j nsci - 6
- the journal of physiology - 4.9 or 6.3 (no restrictions; free format inital submission)
- plos comp bio - 4.5 
- nature scientific reports - 4.5
- frontiers in neuroscience - 3.9
- frontiers in neural circuits - 3.1
- j nphys - 2.9
- npj systems biology and applications

- split methods - jnsci methods special issue on multiscale modeling - https://www.journals.elsevier.com/journal-of-neuroscience-methods/call-for-papers/multiscale-modelling-and-analysis-in-neuroscience (April 30) - 2.8
-- "Workflow/pipeline to build and simulate data-driven multiscale models of cortical circuits"
-- "Development of a data-driven multiscale model of mouse primary motor cortex microcircuits"
-- "Data-driven multiscale model of mouse primary motor cortex microcircuits"
 
*** title: Data-driven multiscale model of M1 microcircuits
- Data-driven full-scale spiking network model of M1 microcircuits
*** Introduction
Here, we present the first network model of the prefrontal cortex which has not only its single neuron properties and
anatomical layout tightly constrained by experimental data, but is also able to quanti- tatively reproduce a large range of
spiking, field potential, and membrane voltage statistics obtained from in vivo data, without need of specific parameter
tuning.

- M1 necessary for initiating and executing the dexterous and non-dexterous steps of this skilled movement \cite{GuoG15}

- Soltesz sublayer conn: "The superdeep model is associated with Lee et al., (2014). This detailed microcircuit model
  explores the network level effects of sublayer specific connectivity in the mouse CA1."
**** Model summary (from nys grant)
As part of an NIH-funded project we have developed the most realistic and detailed computational model of primary motor
cortex microcircuits up to date. The model simulates in full scale a cylindrical volume of diameter of 300 μm and cortical
depth 1350 μm of M1. It includes over 10 thousand cells distributed across the 6 cortical layers based on measured cell
densities, and more than 60 million synaptic connections. Neuron models have been optimized to reproduce the
electrophysiological properties of the main classes of excitatory and inhibitory cells found in M1. Special emphasis has been
placed on accurately matching the responses of layer 5 corticospinal and corticostriatal neurons. Their ionic channel (Na,
Kdr, Ka, Kd, HCN, CaL, CaN, KCa) distributions were constrained by literature and optimized to reproduce with high precision
in vitro recordings: supra- and sub-threshold membrane voltages and firing rates in response to current injections. Cells
also include detailed morphologies with 700+ compartments derived from 3D microscopy reconstructions of real M1
neurons. Network connectivity is based on multiple studies that employed optogenetic circuit mapping to elucidate the
organization of M1 microcircuits. Interestingly, these studies found connectivity depended on cell type and on the sublaminar
depth of the cell. Thus, our model goes beyond previous layer-based models by incorporating sublaminar cortical
depth-dependent connectivity. The dendritic distribution of synaptic inputs for the main projections to layer 5 neurons was
also mapped using optogenetic methods and incorporated into the model. These distinct patterns of dendritic innervation are
likely to subserve important neural coding functions -- e.g. precisely timed synaptic integration from multiple regions --
and have effects at the network level. To model was completed by adding the main long range inputs that drive and modulate M1
microcircuits. These inputs originate in multiple brain regions involved in sensorimotor processing, including Thalamus,
primary and secondary somatosensory cortex (S1, S2), contralateral M1, secondary motor cortex (M2), and occipital cortex
(OC). The Firing properties, projection strength -- as a function of target cell type and layer -- , and the target dendritic
distribution of these long-range inputs was obtained from published experimental data.

This unprecedented level of detail at multiple scales make this model suitable
The model incorporates quantitative experimental data from 12 publications and thus serves as a theoretical framework to study the dynamics and function of M1.

**** ref for intro
-
*** Methods
**** Implemented features
% 6 layers, 3 E and 2 I cell types, 13 populations with cell densities and depths based on exp data
% Model of L5 PT cell fitted to exp data (3D morph and ephys)
% Model of L5 IT cell fitted to exp data (3D morph and ephys) (prelim version; fixing new one)
% Local E->E/I connectivity as a function of cell type and cortical depth based on exp data (5 papers)
% Local I->E/I connectivity intralaminar and with probability decaying exp with distance
% AMPA and NMDA syns for E conns; GABAA and GABAB syns for I conns
% Synaptic distribution of L2/3 E -> PT cells based on sCRACM exp data
% Built using netpyne: framework that facilitates future extension+incorporation of new data to this base model
**** Missing features (for which we have data)
Multiple detailed models of PT cell (for different cortical depths)
-- justified because didn't find significant yfrac-dep chages - fig 4 Suter 2015
% Multiple detailed models of IT cell (for different layers and cortical depths) - in progress
% Synaptic distribution of L2/3 E -> PT for different PT soma depths
% Synaptic distribution of long range inputs (Thalamus, S2, M2, contra M1) -> PT
% Method to obtain individual synaptic weights from cell-to-cell conn weights
**** Missing features (for which we don't have data)
Detailed model of CT cell based on M1 exp data
Detailed model of interneurons (PV and SOM) based on M1 exp data
Model of synapses based on M1 exp data
I->E/I connectivity (weights+probabilites)
% Long range input connectivity (target populations, weights, probabilities)
% Firing patterns of long range inputs
Synaptic distribution for all other projections (E/I/long range -> IT/CT/I and L5,L6 E -> PT)

**** Volume proportional to rat S1 - Markram
- Markram radius 210um - "The horizontal dimension was defined as the smallest circle required to attain maximal
dendritic volume at a central minicolumn (brown, top); cut- off radius, 95% of the plateau volume (r = 210 mm, middle). )
- M1 radius = 150 um (proportional to cortical depth: 1350/2082 * 210 ~=140um)

**** Colocalization of AMPA, NMDA
\cite{Khaz96}
**** Inhibition->E local restricted to layer
Katz 2011 - sup table 5
-- Katzel: L2/3 post = 76.5% (L2/3), 16.5% (L5), 0% (L6)
           L5 post = 1.5% (L2/3), 87% (L5), 10% (L6)
	   (L5B has 23.8% from L6)
	   L6 post = 0.3% (L2/3), 2.2% (L5), 97.5% (L6)
**** Inh synapses
sam, for SOM->E conns you had the GABAASlow to GABAB ratio as 1:7.5  — do you remember where you got that value from?

samn [11:11 PM]
if anywhere other than a guess, would be in the neuroscience 2016 paper (calcium regulation of ...)

[11:11]
probably did that to get a decent effect from GABAB but not allowing it to dominate and produce too much inhibition

salvadord [11:13 PM]
ok thanks

[11:14]
and SOM->I you had only GABAASlow — that sound ok?

samn [11:14 PM]
yeah, since think gabab in pyramidal dends

[11:15]
at least that's what reviewers asked us - can check notes in /u/samn/mypapers/pfcrxdwm/notebook.dol - might have more info about what they asked us for (they requested we add gabab to the simulation)

salvadord [11:16 PM]
ic thanks, will check

samn [11:16 PM]
since they cited some references in their question - though suppose should be referenced in that paper of ours i mentioned
too

**** CSP tuning for network - George+Sheets
*** Results
**** Firing rates consistent with in vivo data
- raster, 1 sec
- voltage traces, 1 sec
- histogram, log rates, by cell class: IT, PT, CT, SOM, PV; compare mean/std with exp; 50 sec and 25*5 stats
- PT rate vs NCD

**** Oscillations consistent with in vivo data

**** Response to S2 pulse

**** Response to M2 pulse

**** Interaction between S2 and M2 inputs
TO DO: stimulate different populations (via long range inputs) and measure activation sequence, power spectra, nTE, Granger

**** Response to time-varying stimulus (spectra + info flow)

*** Conclusions
- Whisker behavior reduced activity in vM1 (can help justify decrease in activtiy in model)

- While PT cells receive and integrate input widely, they do not locally excite many other excitatory neurons, except for other
PT cells (Brown and Hestrin, 2009; Lefort et al., 2009; Harris and Shepherd, 2015; Jiang et al., 2015; Yamawaki and Shepherd,
2015). However, by harnessing the massive divergence of Martinotti (SOM) cells, L5 PT cells can potentially route inhibition to a
large cohort of neurons across multiple layers. Burst firing by one or a small number of L5 PT cells might therefore
represent a ‘‘call to order’’, quieting activity throughout an entire cortical column by activating frequency dependent
disynaptic inhibition.

*** Figures
**** cells
- full_model - show full morphology
- reduced models - show schematic with 3d cylinders but real lengths
- normalized dend L pt per section (total cortical depth=7*72pt=504pt) :
IT2: 96.75 / 1350 = 0.072; 0.122*504= 36pt
IT4: 164.25 / 1350 = 0.122; 0.122*504= 62pt
SOM: 176/1350 = 0.130; 0.130*504= 66pt
PV: 44/1350 = 0.0326; 0.0032*504= 16pt
IT5B: 262/1350 = 0.194; 0.194*504= 98pt
IT6: 398/1350 = 0.295; 0.295*504= 149pt
CT6: 398/1350 = 0.295; 0.295*504= 149pt

Bdend = 299/1350=0.221; 0.221*504=111pt
soma = 25/1350=0.0186; 0.0186*504=9.3pt

Full morphology cells:
In [1]: fig=sim.analysis.plotShape(includeAxon=False,includePre= None, includePost= ['PT5B'], cvar=None, saveFig=False, s
   ...: howFig=True, iv=1, ivprops={'colorSecs': 3, 'colorSyns':2 ,'style': '.', 'siz':10})
   ...:

In [2]: fig.printfile('PT.ps')
Out[2]: 1.0

In [3]: fig=sim.analysis.plotShape(includeAxon=False,includePre= None, includePost= ['IT5A'], cvar=None, saveFig=False, s
   ...: howFig=True, iv=1, ivprops={'colorSecs': 2, 'colorSyns':2 ,'style': '.', 'siz':10})
   ...:

In [4]: fig.printfile('IT.ps')
Out[4]: 1.0

moved to data/v29_manualTune/PT_morph.pdf IT_morph.pdf

- num cells per pop (total: 10171)
IT2 1766
SOM2 104
PV2 211
IT4 1005
IT5A 636
SOM45A 89
PV45A 182
IT5B 1155
PT5B 1155
SOM5B 202
PV5B 411
IT6 1465
CT6 1465
SOM6 107
PV6 218
TPO 1000
TVL 1000
S1 1000
S2 1000
cM1 1000
M2 1000
OC 1000

**** conn
- conv and div per cell / pops
- chord diagram (plotly) -- http://bokeh.pydata.org/en/latest/docs/gallery/chord_chart.html
**** sCRACM-based syn distributions
- show as num of syns / segment -- same as sam's jnphys cover



**** Fig 1: cylinder, populations, ratios
**** Fig 2: single cell tuning, fI curves
**** Fig 3: Long range conn
**** Fig 4: Local conn
**** Fig 5: dendritic conn
**** Fig 6: Rates, oscillations, traces
**** Fig 7: Long range inputs: sensory TPO/S1/S2
**** Fig 8: Long range inputs: motor TVL/M2/OC
**** Fig 9: Local pop + laminar stim
**** Fig 10: Ih modulation
**** Fig 11: Interaction of ih + long

*** Reviewers/Editors
- Olaf Sporns (editor)
- Eve Marder (editor)
- Frances Skinner (editor)

- panayiota poizari
- satish nair
- soltesz/bezaire?
- dembrow?
- torben-nielsen?
- mark goldman?
- arkhipov
- rumbell/weaver
- koszloski
- Sergio salinas (for netpyne paper?)

* TODO Paper 2: Information flow / Granger (split from paper above)
** ideas to extend paper
- info flow with low vs high ih
- info flow with different long-range inputs
- check effect of removing certain pops (e.g. PV, SOM)
- check dynamics/pathways of projections identified by granger as strongest e.g. disynptic inhibtion?}
* TODO Methods improvements
** TODO Methods: Tune model after update netpyne (0.9.1) using evolutionary algorithms
*** DONE Run same results as paper to check effect of netpyne updates
- reproduce v53_batch13 
- test first single seed to make sure it works
*** TODO Run small evol on Comet to test it works
*** TODO Run full evol on Comet 
** DONE Add VIP (and NGF?) cells; update FS/SOM conn
*** add NGF?

the allen brain V1 just has PV, SOM and 5HT3a (which includes VIP and non-VIP/NGF) … but seems clumping VIP+NGF doesnt make much sense
Im not excited about having that many types of inhib types… but finding it hard to justify excluding them if we are gonna include vip
 looks like non-VIP/NGF relatively abundant in L2/3 — 24% of inhib cells vs eg only 11% of som
 same for L6 - 20% non-VIP (NGF) vs eg 6% VIP
*** Cell params from erica's A1 version
//  - geometry and channels from Santhakumar et al 2005
//  - geometry modified to preserve VCUs different dendrites
- file from: https://senselab.med.yale.edu/modeldb/showmodel.cshtml?model=246546&file=%2fturi_et_al_2018%2fcells%2fvipcck_cell.hoc#tabs-2
- 5 sections: soma, rad1, rad2, ori1, ori2
- rad = CA1 layer radiata (superficial); ori = oriens (deep)
- 7 channels
*** Proportion of cells in each layer
**** Katz11 (mouse M1)
L5B PV = 6180, SOM = 2600 (~70-30%)
L6  PV = 2640, SOM = 1820 (~60-40%)
**** 'GABAergic interneurons in the neocortex: from cellular properties to circuits'
	LAYER					
CELL TYPE	L1	    L2/3	L4	    L5A	    L5B	    L6
PV	        01.70%	29%	    64.10%	54%	    46.50%	42.40%
SST	        4%	    11.60%	16.90%	31.90%	38.90%	31.80%
VIP	        5.20%	34.70%	9.20%	7.80%	6%	    6.40%
non-VIP	    90%	    24.70%	9.90%	6.40%	8.50%	19.30%

**** Allen Brain V1
Layer   exc frac	inh frac	PV 	    SST	    5HT3a	Total
        0.85	    0.15				
L2/3    0.85	    0.15	0.295918367	0.214285714	0.489795918	1
L4      0.85	    0.15	0.552380952	0.295238095	0.152380952	1
L5      0.85	    0.15	0.485714286	0.428571429	0.085714286	1
L6      0.85	    0.15	0.458333333	0.458333333	0.083333333	1

**** Conclusion
add both VIP and non-VIP (NGF) in all layers using Tremblay data

*** synapses
- NGF: slow GABAA an GABAB responses (Tremblay,16)
- VIP:

*** Connectivity
**** E->I
- Tremblay 2016:
-- unclear if L2/3 E -> NGF
-- callosal and thalamic matrix -> NGF

- Sohn 2016
-- E -> L2/3 VIP (apical+basal)

- Budinger et al 2018
-- L2-5 E -> NGF
-- thalamic -> VIP (bipolar)
-- thalamic + cortical -> VIP (bitufted)

- Garcia et al 2015
-- E -> NGF

- Naka 2016 (fig 1,2) (L5):
-- E do not target VIP or NGF (only PV+SOM)

- CONCLUSION:
-- NGF: 
--- L2-5 E inputs
--- thalamic matrix inputs (to L1)
--- thalamic inputs to L2-L5

-- VIP:
--- E -> VIP
--- thalamic -> VIP
**** I->E
- currently distance-dependent

- Tremblay 2016:
-- NGF -> local E and I
-- L1 NGF -> L2/3+L5 tuft
-- L2/3 NGF -> L2/3+L5 distal apical
-- L5 NGF -> L5 prox apical

- Naka 2016 (fig 1,2) (L5):
-- L2/3 VIP -> L5 apical trunk (?)
-- NGF -> L5 apical tuft (same as SOM)

- Budinger 2016 (A1):
-- L2 NGF -> L2 E (prox apic); L6 E (tuft)
-- VIP? (not clear which are)

- Pi 2013
-- VIP -> E (very low; 3/42)

**** I->I
- currently distance-dependant

- Tremblay 2016:
-- L2/3 VIP -> L2/3+L5 SOM
-- L5 VIP -> L5 SOM
-- NGF -> local E and I
-- L1 NGF -> L1 NGF
-- L2/3 NGF -> L2/3 I
-- L5/6 NGF -> L5/6 I
-- L2/3 PV -> L2/3 PV 
-- L5/6 PV -> L5/6 PV 
-- L2/3 PV -> L2/3 I except SOM 
-- L5/6 PV -> L5/6 I except SOM

- Sohn 2016:
-- PV -> L2/3 VIP (soma)
-- SOM -> L2/3 VIP (basal, apical)
-- VIP -> L2/3 VIP (low overall)
-- similar to PV/SOM -> E

- Naka 16 (fig1,2) (L5):
-- all to all (changes in weights)
-- depends on layer and area
-- VIP -> VIP (weak); FS,SOM (strong)
-- SOM -> SOM (weak); FS,VIP (strong)
-- FS -> FS (strong); SOM,VIP (weak)

- Pi 2013
-- VIP -> SOM (strong; 14/18)
-- VIP -> PV (weak; 4/15)

- Overstreet-Wadiche 2015 (mostly CA1)

** TODO Methods: Add local M1 cells around modeled volume

Option 1:
- Can be called M1perim
- Use vecstims so fast
- Create perimeter cyilinder around 300x300 cylinder
- Similar to what Allen Brain did in V1 net model
- use same local conn rules -- eg horizontal extent in Weiler paper is >0.5 mm

Option 2:
- Alternative simpler option is to add M1 long pop with 1k cells, with conn of cM1

Option 3:
- Make toroidal - useful only for dist-dep conns (prob based won't be affected)

** TODO Methods: Improve Ih distribution based on exp data
TBen argues we should improve Ih distribution in cell model based on exp data from other papers (he argues currently a weak
aspect of our model)
** TODO Multiple detailed models of PT (yfrac-dep)
** TODO Multiple detailed models of IT (layer and yfrac-dep)
** TODO CT cell detailed model
** TODO Interneuron detailed models
** TODO More realistic long range inputs (including firing patterns of presyn populations)
** TODO I->E/I connectivity weights+probabilites instead of distance-based
- check Naka19 - Complementary networks of cortical somatostatin interneurons enforce layer specific control
** TODO Improve method to obtain individual synaptic weights from cell-to-cell weights
** TODO Missing syn distribution 
- L2/3->PT at different soma yfracs
- other layers (L5, L6) -> PT
- long range inputs -> PT
- Syn distribution for other projections (eg. X->IT)

* TODO Results - things to try
** TODO Results: Map resonance for different layer inputs (SA 4.2) (combine with next SA?)
- Our preliminary simulation data has demonstrated different frequency responses with uncaging-like stimulation at different
  layers (e.g., L2/3 stimulation results in Fig 4). We will expand this study by using our network in in vivo mode with
  stimulation at different frequencies. We hypothesize that activation of particular circuits in the network will lead to
  brief periods of oscillations at key frequencies in alpha, beta and low-gamma bands, and that external input will then be
  selected/amplified based on 1.the dominant frequencies being expressed by the network based on this prior activation
  (network history – this is a highly nonstationary system); 2.phase of signal arrival; 3.laminar location of arrival.

- Fixed params:
-- Vectsim
-- 50% of cells in each layer?
-- noise: 0
-- duration: 500 ms ?

- Variable params:
-- Layer: 2/3, 4, 5A, 5B, 6
-- Frequency: 1 to 80 Hz in steps of 2hz? 4hz? 5hz?
-- Phase: 2 - 4 different

- Outputs:
-- layer firing rate and frequency peak - before and after stim
-- resonance freq

*** Previous sims on freq stim (for SfN poster)
- S2 or directly to L23 (avoid inh)
- fraction of cells or smaller weight
- 1 sec duration
- inc rate 2:2:60
- dec fraction 1/f ?
- measure amp of osc
-- input arg = approx freq
-- find 1st peak, measur amp
-- from 1st peak use est amp ton find 2nd
-- calculate avg peak amp
-- overall rate can be misleading -- unless use 1/f ?
- psd before and after --> overlap, dotted vs solid lines
- measure spec granger

- batch:
-- ih
-- interval / number grouped
-- background - on/off (addLongConn)
-- weight? fixed - to 30


** TODO Results: Develop input test-set / simultaneous multilayer multifreq inputs  (SA 4.3) (combine with prev SA?)
- using different input combinations at 4 locations (L2/3,L5A,L5B,L6), with 4 different dominant frequencies
  (alpha,beta,low-gamma,high-gamma).
- Transient  100 ms activation-packets will be presented to the network (only one cycle for alpha but more for higher
  frequencies).
- Inputs will have varying effect depending not only on the readily measurable phase of intrinsic oscillation, but also on a
  variety of hidden variables which we will seek to identify.

- We will do prolonged simulations with random 100 ms activation-packets with 500 ms interstimulus intervals in order to sample
 many responses with different histories.
- We can then datamine the resulting dataset both for commonalities in response, and for unusual responses which might be of
  particular interest for further exploration.
- We hypothesize that there will be evidence of constructive and destructive interference as well as development of beat frequencies based on the relative phase of intrinsic and extrinsic signals.

- compare for different stim frequencies (eg. alpha=suppress -- use PL paper, gamma=info flow, beta=resting?)

- Fixed params:
-- Vectsim
-- 50% of cells in each layer?
-- noise: 0
-- duration: 100 ms

- Variable params:
-- Layer: 2/3, 4, 5A, 5B, 6
-- Frequency: alpha, beta, low-gamma, high-gamma
-- Phase: 2 - 4 different (intervals of 500 hz)

- Outputs:
-- layer firing rate and frequency peak - before and after stim
-- constructive/destructive interference

** TODO Results: Present long-duration time-varying signals to networks (SA 4.4)
- to ascertain how they encode information in the oscillatory structure.
- Here we will produce ongoing inputs of differential spectral (frequency, phase, amplitude) and spatial (which cells
  activated) patternings.
- This is a valuable complement to the paradigm of assessing responses to activation-packets, since short activation-packet
  durations may be too transient for the network to encode in its oscillatory structure reliably.
- Provided longer-term, continuous signals, our model will also enable us to explicitly test network mechanisms for
  multiplexing signals or combining them.
- We will present two different time-varying signals, first individually, and then simultaneously to input layer 2/3.
- We will assess how the network transforms and represents the signals at the output layers using our information-theoretic
  tools: nTE and Granger causality.60, 98
- The output signal will consist of LFP generated by SPI/STR cells.
- We hypothesize that the network will produce nonlinearities and not simply add the two output signals.
- We expect that the network will pass-through particular signal features: frequencies, phases, amplitudes tags from the
  individual input signals.
- This will enable us to contrast how the microcircuitry encodes and processes activation-packets compared to continuous time-varying signals.

- mouse somatosensory cortex spiking datasets - http://crcns.org/data-sets/ssc

- Fixed params:
-- Vectsim
-- 2 time-varying signal (different target cells and spectral properties)
-- duration: 4000 ms
-- Input layer: 2/3

- Variable params:
-- Signal 1, signal 2, signals 1+2

- Outputs:
-- firing rates + LFP in L5A IT and L5B PT
-- nTE, Granger
-- check how signal transformed
-- chcek what features passed on: freqs, phases, amplitudes

** TODO Results: Wiring perturbations (structure-function relations) (SA 4.5)
- to assess the role of specific layers in contributing to network response to different types of signals. We hypothesize
  that L2/3 will be a controlling influence given its large size and strong downward projections

- Determine effects of L5 hyperconnectivity with reference to autism hypothesis.
A set of predictions relates the effects of hyperconnectivity in layer 5 of neocortex to physiological findings in an autism
mouse model.109 In these experimental studies of mouse anterior frontal cortex, we found hyperconnectivity in class-specific
layer 2/3 to layer 5 STR connections in a conditional-knockout mouse model of autism-spectrum disorder.

*** TODO animation showing spread of activity using john's mayavis code?
- or cliffs code

** TODO Results: Evaluate STR-SPI transformation hypothesis (rate vs temporal coding) via temporal-variability measures
TO DO: compare for different frequencies (eg. alpha=suppress -- use PL paper, gamma=info flow, beta=resting?)
TO DO: Evaluate STR-SPI transformation hypothesis (rate vs temporal coding) via temporal-variability measures

We will assess inputs to different laminae, corresponding to projections from different cortical and subcortical structures,
in evaluation of STR-SPI code transformation hypothesis. We will assess the 2 major output streams, STR and SPI, for degree
of rate-coding by utilizing a set of temporal-variability measures.


** TODO PT dendritic processing/resonance in network context
-- netClamp, dend V - IMPLEMENT
-- need to record from superficial cells - check depth of PT, 50
-- V at dend where inputs from each region
-- delay between inputs - check dend V at t=1 vs t=2
-- need to record voltages at dend locs

- Dendritic synaptic processing: IT (integrator) vs PT (coincidence detectors)
TO DO: Reproduce data in Dembrow, 2015: IT dendrites functioned as temporal integrators, particularly responsive to dendritic inputs within the gamma freq range (40 –140 Hz); PT dendrites acted as coincidence detectors, responding to spatially distributed signals in a narrow time window.

- TO DO: Study effect of low vs high frequency syn inputs on network (network correlates of cell synaptic resonance in apical
dendrites for high freq)

** TODO Reproduce sheets figs with mig ih :ih_hg1:
*** notes from chicago meeting with gmgs
- see 16may18 Chicago meeting

- purely M1 ? ih effect sheets paper fig 11?
- IT inputs - local, but similar paradigm
- effect biggest on PTs
- during ongoing activity - spiking output depends on ih current (for same input) - if blocked higher firing
- apical tuft is basically disconnected
- why? narrows temporal integration window (high pass filter) - more temporal summation
- chirp just ot characterize resonanace; but not physiological
- no effect in resting potential
- can do in single cell - with inputs
- 2nd order question: hwo does synaptic distribution affect this results? use sCRACM maps
- striatal show higher EPSPs but fire very little
- view from soma is distorted (best but still not very good)
- more dendritic effects than somatic

- Ih facilitates rate coding
- Ih modulates movement vs planning (Sheets) -- reducing Ih should reduce output of PT and keep rest of circuit similars


*** see analysis/sheets.py
*** Georg fig 2 / Harnett15 fig 7B - reversal
- old: v44_batch7 (hg rev 984)
- retuned after bug: V48_batch6 (hg rev 1205 -> run batch; rev 1208 -> analyse and plot)
*** Fig 4 - dendritic ih effect
- v43_batch7 (hg rev 969)
*** Fig 7 - somatic aEPSP, ratio, 20 hz, 5 pulses
- v43_manualTune32-40 (hg rev 965)
*** Fig 8 - reduce temp summation from L2/3
- v44_tune32 (think didn't commit :( - check params in notes)
*** Fig 9 - narrow coinc detect from L2/3
- v44_tune47 (hg rev 986)
*** Fig 11 - increase rate from exc inputs
- old: v44_tune54 (hg rev 987)
- retuned after bug: v47_tune47
*** compare tuned kole ih with migliore ih
** TODO Results: Effect of different synaptic distributions (sCRACM) on network dynamics
- focus on radial distribution vs uniform
- Test L2/3->PT and long range inputs
- mutiscale effects
- interesting dendritic coding

- Potjans fig 5: Convergence/divergence by cell type
- show density of synapses as color overlayed over 3d cell morph, one cell per input (L23, thalamus, S2 etc)

- Integration of inputs in PT cells:
"Comparing the average input profiles from S2 and VL revealed a triply complementary, inter- digitating pattern
(Fig. 6C). These results suggest that CSPs can integrate inputs from S2 and VL, with potential for convergence onto the same
dendritic branches in the perisomatic but not api- cal subarbors." Suter 2015

- check \cite{Atti16} (Kali) for effects of realistic syn distribution; and nice representations/analysis

*** Effect of subcellular synaptic distribution of L2/3 -> PT on network dynamics
Compare uniform vs 2D map vs 1D radial distributions (SfN16 poster)
Distributions computed from sCRACM data
TO DO: calculate distribution of other ~20 cells from sCRACM data
TO DO: fit membrane model of sCRACM cells (currently using BS0284) and check if matters
TO DO: find pattern as a function of cortical depth or use different maps for different soma depths

*** Effect of subcellular synaptic distribution of long range -> PT on network dynamics
TO DO: Extract syn distributions from sCRACM data
TO DO: Add Thalamus, S2, M2, contraM1 inputs to network (set firing patterns, weights, etc of long range inputs)
TO DO: Compare effect of different synaptic distributions

** TODO Results: Investigate why LFP PSD doesn't match rate PSD
- see v53_batch12
- Leave for now -- use electrode at half way 600 or 700 um;
- Contribution to LFP:
-- synaptic currents in dend and soma
-- ionic currents in dend and soma
-- spikes
-- inhibitory cells more than exc?

- investigate for next paper by isolating contributions of pops;
- Describe freqs of other pops using rate psd

- why not including multiple LFP electrodes at diff depths:
-- no sig/interesting diffs
-- prev papers we just had single LFP measure
-- not clear what contributions at each layer are; eg.
--- some electrodes deosn't match what expected
--- simplified vs detailed cell models?
--- could be contribution of synapses; EPSCs of L5B dendrites; inhibitory cells?


[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180613_171417.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180613_171600.png][fig]]
[[file+sys:/u/salvadord/Documents/ISB/Models/m1/gif/20180613_171629.png][fig]]

** TODO Plasticity in network
- interesting differential effects layer- and cell-type wise
- see 16may18 Chicago meeting

TO DO: Add synaptic plasticity (STDP or other)
TO DO: Reproduce exp data: presyn L2/3 IT conns are facilitating; presyn L5 IT conns are depressing; specific to presyn cell but independent of postsyn cell

** TODO Reproduce Weiler + A&S LSPS papers (source of conn data for model; validation of model)
- See "Method 2: use CSP neuron model, with sCRACM data for syns, to reproduce LSPS"
- Interesting and many advantages, multiscale stuff for grant, something that cannot be done experimentally, uses sCRACM syn
  distribution and cell morphology
** TODO Investigate source of oscillations (biophys mechs)
- ING / PING mechanism
- exact mechanisms resulting in oscillations
-- connectivity
-- cell properties
-- neuromodulators
- can disrupt / change frequency of oscillations by altering params?
** TODO Check and trace input/output dynamics of PT -> Inh -> IT
Check if consistent with hypo that PT affects IT via inh using with Granger:
- PT -> PV5/SOM5 (low, sparse freqs) so unlikely PT -> Inh -> IT
- PV5 -> IT5A and PV5 -> PT5B (both medium/high, 35/45Hz)
- SOM5 -> IT5A and SOM5 -> PT5B (both medium/high, 30/35Hz)
- Hypothesis: PT -> IT5A (high) due to receiving same inh input (correlation, not causation)
